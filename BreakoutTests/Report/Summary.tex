\documentclass[a4paper,landscape,10pt]{article}
\usepackage[paper=a4paper,landscape,left=20mm,right=20mm,top=20mm,bottom=20mm]{geometry}
\usepackage{longtable}
\usepackage{fancyhdr}
\usepackage[pdftex]{color}
\usepackage{colortbl}
\definecolor{green}{rgb}{0.04,0.68,0.04}
\definecolor{orange}{rgb}{0.97,0.65,0.12}
\definecolor{red}{rgb}{0.75,0.04,0.04}
\definecolor{gray}{rgb}{0.86,0.86,0.86}

\usepackage[pdftex,
            colorlinks=true, linkcolor=red, urlcolor=green, citecolor=red,%
            raiselinks=true,%
            bookmarks=true,%
            bookmarksopenlevel=1,%
            bookmarksopen=true,%
            bookmarksnumbered=true,%
            hyperindex=true,% 
            plainpages=false,% correct hyperlinks
            pdfpagelabels=true%,% view TeX pagenumber in PDF reader
            %pdfborder={0 0 0.5}
            ]{hyperref}

\hypersetup{pdftitle={Coverage Report},
            pdfauthor={ReportGenerator - 5.1.9.0}
           }

\pagestyle{fancy}
\fancyhead[LE,LO]{\leftmark}
\fancyhead[R]{\thepage}
\fancyfoot[C]{ReportGenerator - 5.1.9.0}

\begin{document}

\setcounter{secnumdepth}{-1}
\section{Summary}
\begin{longtable}[l]{ll}
\textbf{Generated on:} & 07/06/2022 - 13:39:34\\
\textbf{Coverage date:} & 07/06/2022 - 13:39:15\\
\textbf{Parser:} & Cobertura\\
\textbf{Assemblies:} & 2\\
\textbf{Classes:} & 64\\
\textbf{Files:} & 64\\
\textbf{Covered lines:} & 1526\\
\textbf{Uncovered lines:} & 2004\\
\textbf{Coverable lines:} & 3530\\
\textbf{Total lines:} & 6667\\
\textbf{Line coverage:} & 43.2\% (1526 of 3530)\\
\textbf{Covered branches:} & 379\\
\textbf{Total branches:} & 1034\\
\textbf{Branch coverage:} & 36.6\% (379 of 1034)\\
\textbf{Covered methods:} & 203\\
\textbf{Total methods:} & 544\\
\textbf{Method coverage:} & 37.3\% (203 of 544)\\
\end{longtable}
\section{Risk Hotspots}
\begin{longtable}[l]{|l|l|l|r|}
\hline
\textbf{Assembly} & \textbf{Class} & \textbf{Method} & \textbf{Cyclomatic complexity}\\
\hline
DIKUArcade & DIKUArcade.Input.Languages.DanishKeyTransformer & TransformKey(...) & \textcolor{red}{194}\\
\hline
DIKUArcade & DIKUArcade.Physics.CollisionDetection & Aabb(...) & \textcolor{red}{48}\\
\hline
\end{longtable}
\section{Coverage}
\begin{longtable}[l]{|l|r|r|r|r|r|r|r|}
\hline
\textbf{Name} & \textbf{Covered} & \textbf{Uncovered} & \textbf{Coverable} & \textbf{Total} & \textbf{Line coverage} & \textbf{Branch coverage} & \textbf{Method coverage}\\
\hline
\textbf{Breakout} & \textbf{1216} & \textbf{227} & \textbf{1443} & \textbf{2756} & \textbf{84.2\%} & \textbf{89.5\%} & \textbf{81.6\%}\\
\hline
Breakout.Ball & 134 & 10 & 144 & 244 & 93\% & 97.7\% & 87.5\%\\
\hline
Breakout.Block & 3 & 0 & 3 & 23 & 100\% &  & 100\%\\
\hline
Breakout.BreakoutBus & 3 & 0 & 3 & 15 & 100\% & 100\% & 100\%\\
\hline
Breakout.BreakoutStates.GameLost & 69 & 23 & 92 & 169 & 75\% & 90\% & 66.6\%\\
\hline
Breakout.BreakoutStates.GamePaused & 57 & 12 & 69 & 131 & 82.6\% & 90.9\% & 57.1\%\\
\hline
Breakout.BreakoutStates.GameRunning & 239 & 41 & 280 & 482 & 85.3\% & 89.2\% & 93.9\%\\
\hline
Breakout.BreakoutStates.GameWon & 69 & 23 & 92 & 169 & 75\% & 90\% & 66.6\%\\
\hline
Breakout.BreakoutStates.MainMenu & 52 & 12 & 64 & 124 & 81.2\% & 87.5\% & 57.1\%\\
\hline
Breakout.BreakoutStates.StateMachine & 49 & 0 & 49 & 87 & 100\% & 100\% & 100\%\\
\hline
Breakout.Game & 0 & 53 & 53 & 122 & 0\% & 0\% & 0\%\\
\hline
Breakout.HardenedBlock & 33 & 9 & 42 & 99 & 78.5\% & 87.5\% & 66.6\%\\
\hline
Breakout.LevelLoader & 169 & 4 & 173 & 293 & 97.6\% & 100\% & 100\%\\
\hline
Breakout.NormalBlock & 34 & 0 & 34 & 80 & 100\% & 83.3\% & 100\%\\
\hline
Breakout.Player & 137 & 11 & 148 & 264 & 92.5\% & 96\% & 94.7\%\\
\hline
Breakout.PowerUpBlock & 34 & 0 & 34 & 80 & 100\% & 83.3\% & 100\%\\
\hline
Breakout.PowerUpDrop & 43 & 6 & 49 & 100 & 87.7\% & 92.8\% & 80\%\\
\hline
Breakout.PowerUps & 35 & 0 & 35 & 70 & 100\% &  & 100\%\\
\hline
Breakout.Program & 0 & 5 & 5 & 15 & 0\% &  & 0\%\\
\hline
Breakout.UnbreakableBlock & 18 & 9 & 27 & 76 & 66.6\% & 75\% & 62.5\%\\
\hline
Points & 14 & 9 & 23 & 61 & 60.8\% & 0\% & 66.6\%\\
\hline
StateTransformer & 24 & 0 & 24 & 52 & 100\% & 100\% & 100\%\\
\hline
\textbf{DIKUArcade} & \textbf{310} & \textbf{1777} & \textbf{2087} & \textbf{3911} & \textbf{14.8\%} & \textbf{7.9\%} & \textbf{14.4\%}\\
\hline
DIKUArcade.DIKUGame & 0 & 30 & 30 & 68 & 0\% & 0\% & 0\%\\
\hline
DIKUArcade.Entities.DynamicShape & 8 & 20 & 28 & 51 & 28.5\% &  & 28.5\%\\
\hline
DIKUArcade.Entities.Entity & 13 & 6 & 19 & 40 & 68.4\% &  & 71.4\%\\
\hline
DIKUArcade.Entities.EntityContainer & 0 & 63 & 63 & 132 & 0\% & 0\% & 0\%\\
\hline
DIKUArcade.Entities.EntityContainer$<$T$>$ & 40 & 11 & 51 & 113 & 78.4\% & 75\% & 80\%\\
\hline
DIKUArcade.Entities.Shape & 11 & 50 & 61 & 114 & 18\% & 25\% & 20\%\\
\hline
DIKUArcade.Entities.StationaryShape & 4 & 7 & 11 & 23 & 36.3\% &  & 33.3\%\\
\hline
DIKUArcade.Events.GameEventBus & 18 & 156 & 174 & 285 & 10.3\% & 6.6\% & 21\%\\
\hline
DIKUArcade.Events.GameEventQueue$<$T$>$ & 0 & 30 & 30 & 97 & 0\% & 0\% & 0\%\\
\hline
DIKUArcade.Events.Generic.GameEventBus$<$T$>$ & 0 & 174 & 174 & 287 & 0\% & 0\% & 0\%\\
\hline
DIKUArcade.Events.Generic.TimedGameEvent$<$T$>$ & 0 & 13 & 13 & 46 & 0\% &  & 0\%\\
\hline
DIKUArcade.Events.TimedGameEvent & 0 & 13 & 13 & 43 & 0\% &  & 0\%\\
\hline
DIKUArcade.Graphics.Animation & 0 & 15 & 15 & 44 & 0\% &  & 0\%\\
\hline
DIKUArcade.Graphics.AnimationContainer & 0 & 40 & 40 & 72 & 0\% & 0\% & 0\%\\
\hline
DIKUArcade.Graphics.Camera & 0 & 12 & 12 & 26 & 0\% &  & 0\%\\
\hline
DIKUArcade.Graphics.ChaseCamera & 0 & 19 & 19 & 50 & 0\% & 0\% & 0\%\\
\hline
DIKUArcade.Graphics.DynamicCamera & 0 & 46 & 46 & 79 & 0\% & 0\% & 0\%\\
\hline
DIKUArcade.Graphics.FollowCamera & 0 & 13 & 13 & 23 & 0\% & 0\% & 0\%\\
\hline
DIKUArcade.Graphics.Image & 3 & 12 & 15 & 28 & 20\% &  & 20\%\\
\hline
DIKUArcade.Graphics.ImageStride & 0 & 87 & 87 & 191 & 0\% & 0\% & 0\%\\
\hline
DIKUArcade.Graphics.NoImage & 0 & 3 & 3 & 11 & 0\% &  & 0\%\\
\hline
DIKUArcade.Graphics.StaticCamera & 0 & 4 & 4 & 14 & 0\% &  & 0\%\\
\hline
DIKUArcade.Graphics.Text & 53 & 88 & 141 & 300 & 37.5\% & 7.6\% & 29.4\%\\
\hline
DIKUArcade.Graphics.Texture & 38 & 92 & 130 & 226 & 29.2\% & 21.4\% & 37.5\%\\
\hline
DIKUArcade.GUI.Window & 6 & 172 & 178 & 377 & 3.3\% & 0\% & 3.8\%\\
\hline
DIKUArcade.GUI.WindowArgs & 0 & 7 & 7 & 27 & 0\% &  & 0\%\\
\hline
DIKUArcade.Input.Languages.DanishKeyTransformer & 0 & 125 & 125 & 155 & 0\% & 0\% & 0\%\\
\hline
DIKUArcade.Math.Vec2D & 0 & 39 & 39 & 61 & 0\% &  & 0\%\\
\hline
DIKUArcade.Math.Vec2F & 14 & 31 & 45 & 70 & 31.1\% &  & 35.7\%\\
\hline
DIKUArcade.Math.Vec2I & 0 & 36 & 36 & 57 & 0\% &  & 0\%\\
\hline
DIKUArcade.Math.Vec3D & 0 & 38 & 38 & 60 & 0\% &  & 0\%\\
\hline
DIKUArcade.Math.Vec3F & 0 & 38 & 38 & 60 & 0\% &  & 0\%\\
\hline
DIKUArcade.Math.Vec3I & 5 & 33 & 38 & 60 & 13.1\% &  & 9\%\\
\hline
DIKUArcade.Math.Vec4D & 0 & 40 & 40 & 63 & 0\% &  & 0\%\\
\hline
DIKUArcade.Math.Vec4F & 0 & 40 & 40 & 63 & 0\% &  & 0\%\\
\hline
DIKUArcade.Math.Vec4I & 0 & 40 & 40 & 63 & 0\% &  & 0\%\\
\hline
DIKUArcade.Physics.CollisionData & 3 & 0 & 3 & 23 & 100\% &  & 100\%\\
\hline
DIKUArcade.Physics.CollisionDetection & 80 & 31 & 111 & 184 & 72\% & 66.6\% & 50\%\\
\hline
DIKUArcade.Timers.GameTimer & 0 & 57 & 57 & 100 & 0\% & 0\% & 0\%\\
\hline
DIKUArcade.Timers.StaticTimer & 14 & 15 & 29 & 59 & 48.2\% & 25\% & 57.1\%\\
\hline
DIKUArcade.Timers.TimePeriod & 0 & 16 & 16 & 30 & 0\% & 0\% & 0\%\\
\hline
DIKUArcade.Utilities.FileIO & 0 & 9 & 9 & 23 & 0\% & 0\% & 0\%\\
\hline
DIKUArcade.Utilities.RandomGenerator & 0 & 6 & 6 & 13 & 0\% & 0\% & 0\%\\
\hline
\end{longtable}
\newpage
\section{Breakout.Ball}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Breakout.Ball\\
\textbf{Assembly:} & Breakout\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/magnus/Desktop/SU/DIKUGames/Breakout/GameElements/Ball.cs}\end{minipage} \\
\textbf{Covered lines:} & 134\\
\textbf{Uncovered lines:} & 10\\
\textbf{Coverable lines:} & 144\\
\textbf{Total lines:} & 244\\
\textbf{Line coverage:} & 93\% (134 of 144)\\
\textbf{Covered branches:} & 43\\
\textbf{Total branches:} & 44\\
\textbf{Branch coverage:} & 97.7\% (43 of 44)\\
\textbf{Covered methods:} & 14\\
\textbf{Total methods:} & 16\\
\textbf{Method coverage:} & 87.5\% (14 of 16)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{get\_shape()} & 100\% & 1 & 100\%\\
\hline
\textbf{get\_startPos()} & 100\% & 1 & 100\%\\
\hline
\textbf{get\_isFast()} & 100\% & 1 & 100\%\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 100\%\\
\hline
\textbf{Render()} & 100\% & 1 & 0\%\\
\hline
\textbf{Move(...)} & 100\% & 6 & 100\%\\
\hline
\textbf{Bounce(...)} & 100\% & 1 & 100\%\\
\hline
\textbf{BounceBlock(...)} & 100\% & 10 & 95.65\%\\
\hline
\textbf{BouncePlayer(...)} & 87.50\% & 8 & 86.36\%\\
\hline
\textbf{BounceWall()} & 100\% & 8 & 100\%\\
\hline
\textbf{ProcessEvent(...)} & 100\% & 6 & 100\%\\
\hline
\textbf{Reset()} & 100\% & 1 & 100\%\\
\hline
\textbf{GetPosition()} & 100\% & 1 & 0\%\\
\hline
\textbf{IncSpeed()} & 100\% & 2 & 100\%\\
\hline
\textbf{DecSpeed()} & 100\% & 1 & 100\%\\
\hline
\textbf{UpdateBallPowerups()} & 100\% & 4 & 100\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/magnus/Desktop/SU/DIKUGames/Breakout/GameElements/Ball.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.Graphics;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using DIKUArcade.Math;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~using DIKUArcade.Events;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~using DIKUArcade.Physics;~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~using DIKUArcade.Timers;~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~namespace Breakout {~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~    ///  This class represents the ball. Everything to do with moving it and checking wether it~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~    /// collides with other game elements.~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~    public class Ball : Entity, IGameEventProcessor {~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~        private float Xvelocity;~\\
\cellcolor{gray} &  & \verb~15~ & & \verb~        private float Yvelocity;~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~        private static Vec2F extend;~\\
\cellcolor{green} & 510 & \verb~17~ & & \verb~        public DynamicShape shape {get;}~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~        public bool moving;~\\
\cellcolor{gray} &  & \verb~19~ & & \verb~        private Entity entity;~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~        private float hitEdge;~\\
\cellcolor{green} & 24 & \verb~21~ & & \verb~        public float startPos{get;private set;}~\\
\cellcolor{green} & 112 & \verb~22~ & & \verb~        public bool isFast{get;private set;}~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~        public int timeSpeed;~\\
\cellcolor{gray} &  & \verb~24~ & & \verb~~\\
\cellcolor{green} & 124 & \verb~25~ & & \verb~        public Ball(DynamicShape shape, IBaseImage image) : base(shape, image) {~\\
\cellcolor{green} & 62 & \verb~26~ & & \verb~            this.shape = shape;~\\
\cellcolor{green} & 62 & \verb~27~ & & \verb~            entity = new Entity(shape, image);~\\
\cellcolor{green} & 62 & \verb~28~ & & \verb~            Xvelocity = 0.05f;~\\
\cellcolor{green} & 62 & \verb~29~ & & \verb~            Yvelocity = 0.05f;~\\
\cellcolor{green} & 62 & \verb~30~ & & \verb~            moving = false;~\\
\cellcolor{green} & 62 & \verb~31~ & & \verb~            isFast = false;~\\
\cellcolor{green} & 62 & \verb~32~ & & \verb~            shape.Direction = new Vec2F(0.0f,0.01f);~\\
\cellcolor{green} & 62 & \verb~33~ & & \verb~            extend = new Vec2F(0.04f, 0.04f);~\\
\cellcolor{green} & 62 & \verb~34~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~35~ & & \verb~~\\
\cellcolor{gray} &  & \verb~36~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~37~ & & \verb~        /// renders the ball~\\
\cellcolor{gray} &  & \verb~38~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~39~ & & \verb~        public void Render() {~\\
\cellcolor{red} & 0 & \verb~40~ & & \verb~            this.RenderEntity();~\\
\cellcolor{red} & 0 & \verb~41~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~42~ & & \verb~~\\
\cellcolor{gray} &  & \verb~43~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~44~ & & \verb~        /// Moves the shape of the ball. Changes the Direction if conditions are met.~\\
\cellcolor{gray} &  & \verb~45~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~46~ & & \verb~        /// <param name="p">A plyer to check for</param>~\\
\cellcolor{gray} &  & \verb~47~ & & \verb~        /// <param name="b">a Entitycontainer<Block> to check for</param>~\\
\cellcolor{green} & 41 & \verb~48~ & & \verb~        public void Move(Player p, EntityContainer<Block> b) {~\\
\cellcolor{green} & 70 & \verb~49~ & & \verb~            if (moving){~\\
\cellcolor{green} & 29 & \verb~50~ & & \verb~                shape.Position += new Vec2F(shape.Direction.X, shape.Direction.Y) *~\\
\cellcolor{green} & 29 & \verb~51~ & & \verb~                new Vec2F(Xvelocity, Yvelocity);~\\
\cellcolor{green} & 29 & \verb~52~ & & \verb~            }~\\
\cellcolor{green} & 53 & \verb~53~ & & \verb~            if (!moving){ ///corrects players posiiton if player is wide.~\\
\cellcolor{green} & 14 & \verb~54~ & & \verb~                if (p.isWide == true){~\\
\cellcolor{green} & 2 & \verb~55~ & & \verb~                    startPos = 2.5f;~\\
\cellcolor{green} & 2 & \verb~56~ & & \verb~                }~\\
\cellcolor{green} & 10 & \verb~57~ & & \verb~                else {~\\
\cellcolor{green} & 10 & \verb~58~ & & \verb~                    startPos = 1.0f;~\\
\cellcolor{green} & 10 & \verb~59~ & & \verb~                }~\\
\cellcolor{green} & 12 & \verb~60~ & & \verb~                shape.Position = new Vec2F(p.shape.Position.X+(0.055f*startPos),~\\
\cellcolor{green} & 12 & \verb~61~ & & \verb~                p.shape.Position.Y+0.01f);~\\
\cellcolor{green} & 12 & \verb~62~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~63~ & & \verb~~\\
\cellcolor{green} & 41 & \verb~64~ & & \verb~            Bounce(p, b);~\\
\cellcolor{gray} &  & \verb~65~ & & \verb~~\\
\cellcolor{green} & 41 & \verb~66~ & & \verb~            shape.Move();~\\
\cellcolor{gray} &  & \verb~67~ & & \verb~~\\
\cellcolor{green} & 41 & \verb~68~ & & \verb~            UpdateBallPowerups();~\\
\cellcolor{gray} &  & \verb~69~ & & \verb~~\\
\cellcolor{green} & 41 & \verb~70~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~71~ & & \verb~~\\
\cellcolor{gray} &  & \verb~72~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~73~ & & \verb~        /// To check if the ball should bounce.~\\
\cellcolor{gray} &  & \verb~74~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~75~ & & \verb~        /// <param name="p">the player to check for</param>~\\
\cellcolor{gray} &  & \verb~76~ & & \verb~        /// <param name="b">the ENtitycontainer<Block> to check for</param>~\\
\cellcolor{green} & 41 & \verb~77~ & & \verb~        private void Bounce(Player p, EntityContainer<Block> b){~\\
\cellcolor{green} & 41 & \verb~78~ & & \verb~            BounceBlock(b);~\\
\cellcolor{green} & 41 & \verb~79~ & & \verb~            BouncePlayer(p);~\\
\cellcolor{green} & 41 & \verb~80~ & & \verb~            BounceWall();~\\
\cellcolor{green} & 41 & \verb~81~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~82~ & & \verb~~\\
\cellcolor{gray} &  & \verb~83~ & & \verb~~\\
\cellcolor{gray} &  & \verb~84~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~85~ & & \verb~        /// Checks if the ball should bounce on any blocks~\\
\cellcolor{gray} &  & \verb~86~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~87~ & & \verb~        /// <param name="b">the Entitycontainer<Block> to check for</param>~\\
\cellcolor{green} & 41 & \verb~88~ & & \verb~        public void BounceBlock(EntityContainer<Block> b) {~\\
\cellcolor{green} & 234 & \verb~89~ & & \verb~            foreach(Block block in b){~\\
\cellcolor{green} & 42 & \verb~90~ & & \verb~                if (CollisionDetection.Aabb(shape, block.Shape).Collision) {~\\
\cellcolor{green} & 5 & \verb~91~ & & \verb~                        BreakoutBus.GetBus().RegisterEvent( //Sends the event that damages the block~\\
\cellcolor{green} & 5 & \verb~92~ & & \verb~                            new GameEvent{~\\
\cellcolor{green} & 5 & \verb~93~ & & \verb~                                EventType = GameEventType.InputEvent,~\\
\cellcolor{green} & 5 & \verb~94~ & & \verb~                                IntArg1 = block.GetValue()~\\
\cellcolor{green} & 5 & \verb~95~ & & \verb~                            }~\\
\cellcolor{green} & 5 & \verb~96~ & & \verb~                        );~\\
\cellcolor{gray} &  & \verb~97~ & & \verb~                    //What directions to move in now.~\\
\cellcolor{green} & 5 & \verb~98~ & & \verb~                    switch ((CollisionDetection.Aabb(this.shape.AsDynamicShape(),~\\
\cellcolor{green} & 5 & \verb~99~ & & \verb~                            block.Shape).CollisionDir)) {~\\
\cellcolor{gray} &  & \verb~100~ & & \verb~                        case CollisionDirection.CollisionDirUp:~\\
\cellcolor{green} & 2 & \verb~101~ & & \verb~                            shape.Direction.Y = -shape.Direction.Y;~\\
\cellcolor{green} & 2 & \verb~102~ & & \verb~                            break;~\\
\cellcolor{gray} &  & \verb~103~ & & \verb~                        case CollisionDirection.CollisionDirDown:~\\
\cellcolor{green} & 1 & \verb~104~ & & \verb~                            shape.Direction.Y = -shape.Direction.Y;~\\
\cellcolor{green} & 1 & \verb~105~ & & \verb~                            break;~\\
\cellcolor{gray} &  & \verb~106~ & & \verb~                        case CollisionDirection.CollisionDirLeft:~\\
\cellcolor{green} & 1 & \verb~107~ & & \verb~                            shape.Direction.X = -shape.Direction.X;~\\
\cellcolor{green} & 1 & \verb~108~ & & \verb~                            break;~\\
\cellcolor{gray} &  & \verb~109~ & & \verb~                        case CollisionDirection.CollisionDirRight:~\\
\cellcolor{green} & 1 & \verb~110~ & & \verb~                            shape.Direction.X = -shape.Direction.X;~\\
\cellcolor{green} & 1 & \verb~111~ & & \verb~                            break;~\\
\cellcolor{gray} &  & \verb~112~ & & \verb~                        case CollisionDirection.CollisionDirUnchecked:~\\
\cellcolor{red} & 0 & \verb~113~ & & \verb~                            break;~\\
\cellcolor{gray} &  & \verb~114~ & & \verb~                    }~\\
\cellcolor{green} & 5 & \verb~115~ & & \verb~                }~\\
\cellcolor{green} & 37 & \verb~116~ & & \verb~            }~\\
\cellcolor{green} & 41 & \verb~117~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~118~ & & \verb~~\\
\cellcolor{gray} &  & \verb~119~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~120~ & & \verb~        /// Checks if the ball shuld bounce on a player.~\\
\cellcolor{gray} &  & \verb~121~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~122~ & & \verb~        /// <param name="p">The player to check for</param>~\\
\cellcolor{green} & 41 & \verb~123~ & & \verb~        public void BouncePlayer(Player p) {~\\
\cellcolor{green} & 41 & \verb~124~ & & \verb~            if (DIKUArcade.Physics.CollisionDetection.Aabb(~\\
\cellcolor{green} & 43 & \verb~125~ & & \verb~                this.shape, p.shape).Collision) {~\\
\cellcolor{green} & 3 & \verb~126~ & & \verb~                if (p.isWide == true) { //If wide is true corrects the hitedge~\\
\cellcolor{green} & 1 & \verb~127~ & & \verb~                    hitEdge = 0.2f;~\\
\cellcolor{green} & 1 & \verb~128~ & & \verb~                }~\\
\cellcolor{green} & 1 & \verb~129~ & & \verb~                else {~\\
\cellcolor{green} & 1 & \verb~130~ & & \verb~                    hitEdge = 0.1f;~\\
\cellcolor{green} & 1 & \verb~131~ & & \verb~                }~\\
\cellcolor{orange} & 2 & \verb~132~ & & \verb~                if (shape.Position.X > p.GetPosition().X + hitEdge) { //Right side of player~\\
\cellcolor{red} & 0 & \verb~133~ & & \verb~                    shape.Direction.X = 0.01f;~\\
\cellcolor{red} & 0 & \verb~134~ & & \verb~                    shape.Direction.Y = 0.01f;~\\
\cellcolor{red} & 0 & \verb~135~ & & \verb~                }~\\
\cellcolor{green} & 3 & \verb~136~ & & \verb~                else if (shape.Position.X < p.GetPosition().X - (0.002)) { //left side of player~\\
\cellcolor{green} & 1 & \verb~137~ & & \verb~                    shape.Direction.X = -0.01f;~\\
\cellcolor{green} & 1 & \verb~138~ & & \verb~                    shape.Direction.Y = 0.01f;~\\
\cellcolor{gray} &  & \verb~139~ & & \verb~~\\
\cellcolor{green} & 1 & \verb~140~ & & \verb~                }~\\
\cellcolor{green} & 1 & \verb~141~ & & \verb~                else { //always bounce back up~\\
\cellcolor{green} & 1 & \verb~142~ & & \verb~                    shape.Direction.Y = -shape.Direction.Y;~\\
\cellcolor{green} & 1 & \verb~143~ & & \verb~                }~\\
\cellcolor{green} & 2 & \verb~144~ & & \verb~            }~\\
\cellcolor{green} & 41 & \verb~145~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~146~ & & \verb~~\\
\cellcolor{gray} &  & \verb~147~ & & \verb~~\\
\cellcolor{gray} &  & \verb~148~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~149~ & & \verb~        /// Checks if the ball should bounce on a wall.~\\
\cellcolor{gray} &  & \verb~150~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 41 & \verb~151~ & & \verb~        private void BounceWall(){~\\
\cellcolor{green} & 43 & \verb~152~ & & \verb~            if (shape.Position.Y < -0.05f){ //bottom of screen~\\
\cellcolor{green} & 2 & \verb~153~ & & \verb~                BreakoutBus.GetBus().RegisterEvent(~\\
\cellcolor{green} & 2 & \verb~154~ & & \verb~                            new GameEvent{~\\
\cellcolor{green} & 2 & \verb~155~ & & \verb~                                EventType = GameEventType.InputEvent,~\\
\cellcolor{green} & 2 & \verb~156~ & & \verb~                                Message = "DecLife"~\\
\cellcolor{green} & 2 & \verb~157~ & & \verb~                            }~\\
\cellcolor{green} & 2 & \verb~158~ & & \verb~                );~\\
\cellcolor{green} & 2 & \verb~159~ & & \verb~                DeleteEntity();~\\
\cellcolor{green} & 2 & \verb~160~ & & \verb~                moving = false;~\\
\cellcolor{green} & 2 & \verb~161~ & & \verb~            }~\\
\cellcolor{green} & 50 & \verb~162~ & & \verb~            if (shape.Position.X > 0.95f || shape.Position.X < 0.0f) { //right side~\\
\cellcolor{green} & 9 & \verb~163~ & & \verb~                shape.Direction.X = -shape.Direction.X;~\\
\cellcolor{green} & 9 & \verb~164~ & & \verb~            }~\\
\cellcolor{green} & 43 & \verb~165~ & & \verb~            if (shape.Position.Y > 0.95f) { //left side~\\
\cellcolor{green} & 2 & \verb~166~ & & \verb~                shape.Direction.Y = -shape.Direction.Y;~\\
\cellcolor{green} & 2 & \verb~167~ & & \verb~            }~\\
\cellcolor{green} & 41 & \verb~168~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~169~ & & \verb~~\\
\cellcolor{gray} &  & \verb~170~ & & \verb~~\\
\cellcolor{gray} &  & \verb~171~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~172~ & & \verb~        /// processes a gameEvent~\\
\cellcolor{gray} &  & \verb~173~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~174~ & & \verb~        /// <param name="gameEvent">the gameEvent to process</param>~\\
\cellcolor{green} & 5 & \verb~175~ & & \verb~        public void ProcessEvent(GameEvent gameEvent){~\\
\cellcolor{green} & 9 & \verb~176~ & & \verb~            if (gameEvent.EventType == GameEventType.InputEvent) {~\\
\cellcolor{green} & 4 & \verb~177~ & & \verb~                switch (gameEvent.Message) {~\\
\cellcolor{gray} &  & \verb~178~ & & \verb~                    case "LAUNCH_BALL":~\\
\cellcolor{green} & 1 & \verb~179~ & & \verb~                        moving = true;~\\
\cellcolor{green} & 1 & \verb~180~ & & \verb~                        break;~\\
\cellcolor{gray} &  & \verb~181~ & & \verb~                    case "IncSpeed":~\\
\cellcolor{green} & 2 & \verb~182~ & & \verb~                        IncSpeed();~\\
\cellcolor{green} & 2 & \verb~183~ & & \verb~                        break;~\\
\cellcolor{gray} &  & \verb~184~ & & \verb~                    default:~\\
\cellcolor{green} & 1 & \verb~185~ & & \verb~                        break;~\\
\cellcolor{gray} &  & \verb~186~ & & \verb~                }~\\
\cellcolor{green} & 4 & \verb~187~ & & \verb~            }~\\
\cellcolor{green} & 5 & \verb~188~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~189~ & & \verb~~\\
\cellcolor{gray} &  & \verb~190~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~191~ & & \verb~        /// Resets the ball.~\\
\cellcolor{gray} &  & \verb~192~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 2 & \verb~193~ & & \verb~        public void Reset(){~\\
\cellcolor{green} & 2 & \verb~194~ & & \verb~            Xvelocity = 0.0f;~\\
\cellcolor{green} & 2 & \verb~195~ & & \verb~            Yvelocity = 0.01f;~\\
\cellcolor{green} & 2 & \verb~196~ & & \verb~            moving = false;~\\
\cellcolor{green} & 2 & \verb~197~ & & \verb~            shape.Direction.X = 0.0f;~\\
\cellcolor{green} & 2 & \verb~198~ & & \verb~            shape.Direction.Y = 0.01f;~\\
\cellcolor{green} & 2 & \verb~199~ & & \verb~            shape.Position = new Vec2F(0.3f, 0.03f);~\\
\cellcolor{green} & 2 & \verb~200~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~201~ & & \verb~~\\
\cellcolor{gray} &  & \verb~202~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~203~ & & \verb~        /// Returns the position of the ball~\\
\cellcolor{gray} &  & \verb~204~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~205~ & & \verb~        /// <returns>The position as a Vec2F</returns>~\\
\cellcolor{red} & 0 & \verb~206~ & & \verb~        public Vec2F GetPosition() {~\\
\cellcolor{red} & 0 & \verb~207~ & & \verb~            return this.shape.Position;~\\
\cellcolor{red} & 0 & \verb~208~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~209~ & & \verb~~\\
\cellcolor{gray} &  & \verb~210~ & & \verb~~\\
\cellcolor{gray} &  & \verb~211~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~212~ & & \verb~        /// Doubles the speed if it has not already been doubles, and saves the time it was doubled~\\
\cellcolor{gray} &  & \verb~213~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 2 & \verb~214~ & & \verb~        public void IncSpeed() {~\\
\cellcolor{green} & 4 & \verb~215~ & & \verb~            if (isFast == false) {~\\
\cellcolor{green} & 2 & \verb~216~ & & \verb~                isFast = true;~\\
\cellcolor{green} & 2 & \verb~217~ & & \verb~                shape.Direction.X*=2;~\\
\cellcolor{green} & 2 & \verb~218~ & & \verb~                shape.Direction.Y*=2;~\\
\cellcolor{green} & 2 & \verb~219~ & & \verb~                timeSpeed = System.Convert.ToInt32(StaticTimer.GetElapsedSeconds());~\\
\cellcolor{green} & 2 & \verb~220~ & & \verb~            }~\\
\cellcolor{green} & 2 & \verb~221~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~222~ & & \verb~~\\
\cellcolor{gray} &  & \verb~223~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~224~ & & \verb~        /// decreases the speed by half~\\
\cellcolor{gray} &  & \verb~225~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 1 & \verb~226~ & & \verb~        public void DecSpeed() {~\\
\cellcolor{green} & 1 & \verb~227~ & & \verb~            shape.Direction.X*=0.5f;~\\
\cellcolor{green} & 1 & \verb~228~ & & \verb~            shape.Direction.Y*=0.5f;~\\
\cellcolor{green} & 1 & \verb~229~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~230~ & & \verb~~\\
\cellcolor{gray} &  & \verb~231~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~232~ & & \verb~        /// Checks if the ball is fast and if the appropriate time has passed~\\
\cellcolor{gray} &  & \verb~233~ & & \verb~        /// and if so resets the poweruptimer and fields and decreases the speed~\\
\cellcolor{gray} &  & \verb~234~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 42 & \verb~235~ & & \verb~        public void UpdateBallPowerups(){~\\
\cellcolor{green} & 42 & \verb~236~ & & \verb~            if (isFast && timeSpeed + 10  < System.Convert.ToInt32(~\\
\cellcolor{green} & 43 & \verb~237~ & & \verb~                StaticTimer.GetElapsedSeconds())){~\\
\cellcolor{green} & 1 & \verb~238~ & & \verb~                timeSpeed = -100;~\\
\cellcolor{green} & 1 & \verb~239~ & & \verb~                isFast = false;~\\
\cellcolor{green} & 1 & \verb~240~ & & \verb~                DecSpeed();~\\
\cellcolor{green} & 1 & \verb~241~ & & \verb~            }~\\
\cellcolor{green} & 42 & \verb~242~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~243~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~244~ & & \verb~}~\\
\end{longtable}
\newpage
\section{Breakout.Block}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Breakout.Block\\
\textbf{Assembly:} & Breakout\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/magnus/Desktop/SU/DIKUGames/Breakout/Blocks/Block.cs}\end{minipage} \\
\textbf{Covered lines:} & 3\\
\textbf{Uncovered lines:} & 0\\
\textbf{Coverable lines:} & 3\\
\textbf{Total lines:} & 23\\
\textbf{Line coverage:} & 100\% (3 of 3)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 0\\
\textbf{Covered methods:} & 1\\
\textbf{Total methods:} & 1\\
\textbf{Method coverage:} & 100\% (1 of 1)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 100\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/magnus/Desktop/SU/DIKUGames/Breakout/Blocks/Block.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.Math;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using DIKUArcade.Graphics;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~using DIKUArcade.Events;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~namespace Breakout {~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~    public abstract class Block : Entity, IGameEventProcessor {~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~        public Shape shape;~\\
\cellcolor{green} & 312 & \verb~11~ & & \verb~        public Block(Shape shape, IBaseImage image) : base(shape, image) {~\\
\cellcolor{green} & 156 & \verb~12~ & & \verb~            this.shape = shape;~\\
\cellcolor{green} & 156 & \verb~13~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~~\\
\cellcolor{gray} &  & \verb~15~ & & \verb~        public abstract int GetHealth();~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~        public abstract void DecHealth ();~\\
\cellcolor{gray} &  & \verb~17~ & & \verb~        public abstract int GetValue();~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~        public abstract Vec2F GetPosition();~\\
\cellcolor{gray} &  & \verb~19~ & & \verb~        public abstract void SetValue(int amount);~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~        public abstract bool IsPowerUp();~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~        public abstract void ProcessEvent(GameEvent gameEvent);~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~}~\\
\end{longtable}
\newpage
\section{Breakout.BreakoutBus}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Breakout.BreakoutBus\\
\textbf{Assembly:} & Breakout\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/magnus/Desktop/SU/DIKUGames/Breakout/BreakoutBus.cs}\end{minipage} \\
\textbf{Covered lines:} & 3\\
\textbf{Uncovered lines:} & 0\\
\textbf{Coverable lines:} & 3\\
\textbf{Total lines:} & 15\\
\textbf{Line coverage:} & 100\% (3 of 3)\\
\textbf{Covered branches:} & 2\\
\textbf{Total branches:} & 2\\
\textbf{Branch coverage:} & 100\% (2 of 2)\\
\textbf{Covered methods:} & 1\\
\textbf{Total methods:} & 1\\
\textbf{Method coverage:} & 100\% (1 of 1)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{GetBus()} & 100\% & 2 & 100\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/magnus/Desktop/SU/DIKUGames/Breakout/BreakoutBus.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Events;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~namespace Breakout {~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~    public static class BreakoutBus {~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~        private static GameEventBus eventBus;~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~        /// Either crates a eventbus or returns the already created one. Only ever creates one.~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~        /// <returns>The GameEventBus</returns>~\\
\cellcolor{green} & 337 & \verb~11~ & & \verb~        public static GameEventBus GetBus() {~\\
\cellcolor{green} & 337 & \verb~12~ & & \verb~            return BreakoutBus.eventBus ?? (BreakoutBus.eventBus = new GameEventBus());~\\
\cellcolor{green} & 337 & \verb~13~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~15~ & & \verb~}~\\
\end{longtable}
\newpage
\section{Breakout.BreakoutStates.GameLost}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Breakout.BreakoutStates.GameLost\\
\textbf{Assembly:} & Breakout\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/magnus/Desktop/SU/DIKUGames/Breakout/GameStates/GameLost.cs}\end{minipage} \\
\textbf{Covered lines:} & 69\\
\textbf{Uncovered lines:} & 23\\
\textbf{Coverable lines:} & 92\\
\textbf{Total lines:} & 169\\
\textbf{Line coverage:} & 75\% (69 of 92)\\
\textbf{Covered branches:} & 18\\
\textbf{Total branches:} & 20\\
\textbf{Branch coverage:} & 90\% (18 of 20)\\
\textbf{Covered methods:} & 6\\
\textbf{Total methods:} & 9\\
\textbf{Method coverage:} & 66.6\% (6 of 9)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{GetInstance()} & 100\% & 2 & 100\%\\
\hline
\textbf{InitializeGameState(} & 100\% & 1 & 100\%\\
\hline
\textbf{ResetState()} & 100\% & 1 & 100\%\\
\hline
\textbf{UpdateState()} & 100\% & 1 & 0\%\\
\hline
\textbf{RenderState()} & 0\% & 2 & 0\%\\
\hline
\textbf{HandleKeyEvent(...)} & 100\% & 2 & 83.33\%\\
\hline
\textbf{KeyPress(...)} & 100\% & 10 & 96.77\%\\
\hline
\textbf{ProcessEvent(...)} & 100\% & 4 & 100\%\\
\hline
\textbf{GetPoints()} & 100\% & 1 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/magnus/Desktop/SU/DIKUGames/Breakout/GameStates/GameLost.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Graphics;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.State;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using DIKUArcade.Input;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~using DIKUArcade.Math;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~using DIKUArcade.Events;~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~namespace Breakout.BreakoutStates {~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~    ///  This class represents the state that is active when the game has been lost.~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~    public class GameLost : IGameState, IGameEventProcessor{~\\
\cellcolor{gray} &  & \verb~15~ & & \verb~~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~        private static GameLost instance = null;~\\
\cellcolor{gray} &  & \verb~17~ & & \verb~        private Text[] menuButtons;~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~        private Text NewGameText;~\\
\cellcolor{gray} &  & \verb~19~ & & \verb~        private Text QuitText;~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~        private Text lostGameText;~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~        public string SelectedButton;~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~        private Entity BackgroundImage;~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~        private StationaryShape shape;~\\
\cellcolor{gray} &  & \verb~24~ & & \verb~        private IBaseImage image;~\\
\cellcolor{gray} &  & \verb~25~ & & \verb~        public int points;~\\
\cellcolor{gray} &  & \verb~26~ & & \verb~        private Text pointsText;~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~~\\
\cellcolor{green} & 48 & \verb~28~ & & \verb~        public static GameLost GetInstance() {~\\
\cellcolor{green} & 49 & \verb~29~ & & \verb~            if (GameLost.instance == null) {~\\
\cellcolor{green} & 1 & \verb~30~ & & \verb~                GameLost.instance = new GameLost();~\\
\cellcolor{green} & 1 & \verb~31~ & & \verb~                GameLost.instance.InitializeGameState();~\\
\cellcolor{green} & 1 & \verb~32~ & & \verb~            }~\\
\cellcolor{green} & 48 & \verb~33~ & & \verb~            return GameLost.instance;~\\
\cellcolor{green} & 48 & \verb~34~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~35~ & & \verb~~\\
\cellcolor{gray} &  & \verb~36~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~37~ & & \verb~        /// Initializes the gamestate~\\
\cellcolor{gray} &  & \verb~38~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 1 & \verb~39~ & & \verb~        public void InitializeGameState() {~\\
\cellcolor{green} & 1 & \verb~40~ & & \verb~            lostGameText = new Text("YOU Lost", new Vec2F(0.3f, 0.25f), new Vec2F(0.5f, 0.5f));~\\
\cellcolor{green} & 1 & \verb~41~ & & \verb~            lostGameText.SetColor(new Vec3I(255,255,255));~\\
\cellcolor{green} & 1 & \verb~42~ & & \verb~            NewGameText = new Text("Main Menu", new Vec2F(0.05f, 0.0f), new Vec2F(0.5f, 0.5f));~\\
\cellcolor{green} & 1 & \verb~43~ & & \verb~            NewGameText.SetColor(new Vec3I(255,255,255));~\\
\cellcolor{green} & 1 & \verb~44~ & & \verb~            QuitText = new Text("Quit Game", new Vec2F(0.05f, -0.1f), new Vec2F(0.5f,  0.5f));~\\
\cellcolor{green} & 1 & \verb~45~ & & \verb~            QuitText.SetColor(new Vec3I(255, 0, 0));~\\
\cellcolor{green} & 1 & \verb~46~ & & \verb~            menuButtons = new Text[] {NewGameText, QuitText};~\\
\cellcolor{green} & 1 & \verb~47~ & & \verb~            SelectedButton = "Main Menu";~\\
\cellcolor{green} & 1 & \verb~48~ & & \verb~            shape = new StationaryShape(new Vec2F(0.0f, 0.0f), new Vec2F(1.0f, 1.0f));~\\
\cellcolor{green} & 1 & \verb~49~ & & \verb~            image = new Image(Path.Combine("Assets", "Images", "shipit_titlescreen.png"));~\\
\cellcolor{green} & 1 & \verb~50~ & & \verb~            BackgroundImage = new Entity(shape, image);~\\
\cellcolor{green} & 1 & \verb~51~ & & \verb~            BreakoutBus.GetBus().Subscribe(GameEventType.ControlEvent, this);~\\
\cellcolor{green} & 1 & \verb~52~ & & \verb~            pointsText = new Text("Score: " + points.ToString(), new Vec2F(0.05f, 0.2f), new Vec2F(0.5f, 0.5f));~\\
\cellcolor{green} & 1 & \verb~53~ & & \verb~            pointsText.SetColor(new Vec3I(255,255,0));~\\
\cellcolor{green} & 1 & \verb~54~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~55~ & & \verb~~\\
\cellcolor{gray} &  & \verb~56~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~57~ & & \verb~        /// Resets the state~\\
\cellcolor{gray} &  & \verb~58~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 1 & \verb~59~ & & \verb~        public void ResetState() {~\\
\cellcolor{green} & 1 & \verb~60~ & & \verb~            points = 0;~\\
\cellcolor{green} & 1 & \verb~61~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~62~ & & \verb~~\\
\cellcolor{gray} &  & \verb~63~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~64~ & & \verb~        /// Updates the state~\\
\cellcolor{gray} &  & \verb~65~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~66~ & & \verb~        public void UpdateState() {~\\
\cellcolor{red} & 0 & \verb~67~ & & \verb~            GetPoints();~\\
\cellcolor{red} & 0 & \verb~68~ & & \verb~            pointsText = pointsText = new Text("Score: " + points.ToString(), new Vec2F(0.05f, 0.2f), new Vec2F(0.5f, 0.~\\
\cellcolor{red} & 0 & \verb~69~ & & \verb~            pointsText.SetColor(new Vec3I(255,255,0));~\\
\cellcolor{red} & 0 & \verb~70~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~71~ & & \verb~~\\
\cellcolor{gray} &  & \verb~72~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~73~ & & \verb~        /// Renders the state~\\
\cellcolor{gray} &  & \verb~74~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~75~ & & \verb~        public void RenderState() {~\\
\cellcolor{red} & 0 & \verb~76~ & & \verb~            BackgroundImage.RenderEntity();~\\
\cellcolor{red} & 0 & \verb~77~ & & \verb~            foreach (Text text in menuButtons) {~\\
\cellcolor{red} & 0 & \verb~78~ & & \verb~                text.RenderText();~\\
\cellcolor{red} & 0 & \verb~79~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~80~ & & \verb~            lostGameText.RenderText();~\\
\cellcolor{red} & 0 & \verb~81~ & & \verb~            pointsText.RenderText();~\\
\cellcolor{red} & 0 & \verb~82~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~83~ & & \verb~~\\
\cellcolor{gray} &  & \verb~84~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~85~ & & \verb~        /// handles key events~\\
\cellcolor{gray} &  & \verb~86~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~87~ & & \verb~        /// <param name="action">the actio nto handle</param>~\\
\cellcolor{gray} &  & \verb~88~ & & \verb~        /// <param name="key">the key pressed or released</param>~\\
\cellcolor{green} & 5 & \verb~89~ & & \verb~        public void HandleKeyEvent(KeyboardAction action, KeyboardKey key) {~\\
\cellcolor{green} & 5 & \verb~90~ & & \verb~            switch (action) {~\\
\cellcolor{gray} &  & \verb~91~ & & \verb~                case (KeyboardAction.KeyPress):~\\
\cellcolor{green} & 5 & \verb~92~ & & \verb~                    KeyPress(key);~\\
\cellcolor{green} & 5 & \verb~93~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~94~ & & \verb~                default:~\\
\cellcolor{red} & 0 & \verb~95~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~96~ & & \verb~            }~\\
\cellcolor{green} & 5 & \verb~97~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~98~ & & \verb~~\\
\cellcolor{gray} &  & \verb~99~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~100~ & & \verb~        /// calls SetMoveRight or SetMoveLeft accordinly to the pressed key~\\
\cellcolor{gray} &  & \verb~101~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~102~ & & \verb~        /// <param name="key">pressed key</param>~\\
\cellcolor{green} & 5 & \verb~103~ & & \verb~        private void KeyPress(KeyboardKey key) { // Initiating keypresses on given keys with switch~\\
\cellcolor{green} & 5 & \verb~104~ & & \verb~            switch (key) {~\\
\cellcolor{gray} &  & \verb~105~ & & \verb~                case KeyboardKey.Up:~\\
\cellcolor{green} & 2 & \verb~106~ & & \verb~                    SelectedButton = "Main Menu";~\\
\cellcolor{green} & 2 & \verb~107~ & & \verb~                    NewGameText.SetColor(new Vec3I(255,255,255));~\\
\cellcolor{green} & 2 & \verb~108~ & & \verb~                    QuitText.SetColor(new Vec3I(255, 0, 0));~\\
\cellcolor{green} & 2 & \verb~109~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~110~ & & \verb~                case KeyboardKey.Down:~\\
\cellcolor{green} & 1 & \verb~111~ & & \verb~                    SelectedButton = "Quit Game";~\\
\cellcolor{green} & 1 & \verb~112~ & & \verb~                    NewGameText.SetColor(new Vec3I(255, 0, 0));~\\
\cellcolor{green} & 1 & \verb~113~ & & \verb~                    QuitText.SetColor(new Vec3I(255, 255, 255)); // Starting movement on press~\\
\cellcolor{green} & 1 & \verb~114~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~115~ & & \verb~                case KeyboardKey.Enter:~\\
\cellcolor{green} & 3 & \verb~116~ & & \verb~                    if (SelectedButton == "Main Menu") {~\\
\cellcolor{green} & 1 & \verb~117~ & & \verb~                        ResetState();~\\
\cellcolor{green} & 1 & \verb~118~ & & \verb~                        BreakoutBus.GetBus().RegisterEvent(~\\
\cellcolor{green} & 1 & \verb~119~ & & \verb~                            new GameEvent{~\\
\cellcolor{green} & 1 & \verb~120~ & & \verb~                                EventType = GameEventType.GameStateEvent,~\\
\cellcolor{green} & 1 & \verb~121~ & & \verb~                                Message = "CHANGE_STATE",~\\
\cellcolor{green} & 1 & \verb~122~ & & \verb~                                StringArg1 = "MAIN_MENU"~\\
\cellcolor{green} & 1 & \verb~123~ & & \verb~                            }~\\
\cellcolor{green} & 1 & \verb~124~ & & \verb~                        );~\\
\cellcolor{green} & 1 & \verb~125~ & & \verb~                    }~\\
\cellcolor{green} & 2 & \verb~126~ & & \verb~                    else if (SelectedButton == "Quit Game") {~\\
\cellcolor{green} & 1 & \verb~127~ & & \verb~                        BreakoutBus.GetBus().RegisterEvent(~\\
\cellcolor{green} & 1 & \verb~128~ & & \verb~                            new GameEvent{~\\
\cellcolor{green} & 1 & \verb~129~ & & \verb~                                EventType = GameEventType.InputEvent,~\\
\cellcolor{green} & 1 & \verb~130~ & & \verb~                                Message = "escape"~\\
\cellcolor{green} & 1 & \verb~131~ & & \verb~                            }~\\
\cellcolor{green} & 1 & \verb~132~ & & \verb~                        );~\\
\cellcolor{green} & 1 & \verb~133~ & & \verb~                    }~\\
\cellcolor{green} & 2 & \verb~134~ & & \verb~                    break;~\\
\cellcolor{red} & 0 & \verb~135~ & & \verb~                default: break;~\\
\cellcolor{gray} &  & \verb~136~ & & \verb~            }~\\
\cellcolor{green} & 5 & \verb~137~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~138~ & & \verb~~\\
\cellcolor{gray} &  & \verb~139~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~140~ & & \verb~        /// Processes the gameEvent~\\
\cellcolor{gray} &  & \verb~141~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~142~ & & \verb~        /// <param name="gameEvent">the event to process</param>~\\
\cellcolor{green} & 2 & \verb~143~ & & \verb~        public void ProcessEvent(GameEvent gameEvent){~\\
\cellcolor{green} & 4 & \verb~144~ & & \verb~            if (gameEvent.EventType == GameEventType.ControlEvent) {~\\
\cellcolor{green} & 2 & \verb~145~ & & \verb~                switch (gameEvent.Message) {~\\
\cellcolor{gray} &  & \verb~146~ & & \verb~                    case "WonLostPoints":~\\
\cellcolor{green} & 1 & \verb~147~ & & \verb~                        points = gameEvent.IntArg1;~\\
\cellcolor{green} & 1 & \verb~148~ & & \verb~                        break;~\\
\cellcolor{gray} &  & \verb~149~ & & \verb~                    default:~\\
\cellcolor{green} & 1 & \verb~150~ & & \verb~                        break;~\\
\cellcolor{gray} &  & \verb~151~ & & \verb~                }~\\
\cellcolor{green} & 2 & \verb~152~ & & \verb~            }~\\
\cellcolor{green} & 2 & \verb~153~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~154~ & & \verb~~\\
\cellcolor{gray} &  & \verb~155~ & & \verb~~\\
\cellcolor{gray} &  & \verb~156~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~157~ & & \verb~        /// creates an event that is caught by Game~\\
\cellcolor{gray} &  & \verb~158~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~159~ & & \verb~        private void GetPoints(){~\\
\cellcolor{red} & 0 & \verb~160~ & & \verb~            BreakoutBus.GetBus().RegisterEvent(~\\
\cellcolor{red} & 0 & \verb~161~ & & \verb~                            new GameEvent{~\\
\cellcolor{red} & 0 & \verb~162~ & & \verb~                                EventType = GameEventType.ControlEvent,~\\
\cellcolor{red} & 0 & \verb~163~ & & \verb~                                Message = "GetPoints",~\\
\cellcolor{red} & 0 & \verb~164~ & & \verb~                            }~\\
\cellcolor{red} & 0 & \verb~165~ & & \verb~                        );~\\
\cellcolor{red} & 0 & \verb~166~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~167~ & & \verb~~\\
\cellcolor{gray} &  & \verb~168~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~169~ & & \verb~}~\\
\end{longtable}
\newpage
\section{Breakout.BreakoutStates.GamePaused}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Breakout.BreakoutStates.GamePaused\\
\textbf{Assembly:} & Breakout\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/magnus/Desktop/SU/DIKUGames/Breakout/GameStates/GamePaused.cs}\end{minipage} \\
\textbf{Covered lines:} & 57\\
\textbf{Uncovered lines:} & 12\\
\textbf{Coverable lines:} & 69\\
\textbf{Total lines:} & 131\\
\textbf{Line coverage:} & 82.6\% (57 of 69)\\
\textbf{Covered branches:} & 20\\
\textbf{Total branches:} & 22\\
\textbf{Branch coverage:} & 90.9\% (20 of 22)\\
\textbf{Covered methods:} & 4\\
\textbf{Total methods:} & 7\\
\textbf{Method coverage:} & 57.1\% (4 of 7)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{GetInstance()} & 100\% & 2 & 100\%\\
\hline
\textbf{InitializeGameState(} & 100\% & 1 & 100\%\\
\hline
\textbf{ResetState()} & 100\% & 1 & 0\%\\
\hline
\textbf{UpdateState()} & 100\% & 1 & 0\%\\
\hline
\textbf{RenderState()} & 0\% & 2 & 0\%\\
\hline
\textbf{HandleKeyEvent(...)} & 100\% & 8 & 90.0\%\\
\hline
\textbf{KeyPress(...)} & 100\% & 10 & 96.77\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/magnus/Desktop/SU/DIKUGames/Breakout/GameStates/GamePaused.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Graphics;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.State;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using DIKUArcade.Input;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~using DIKUArcade.Math;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~using DIKUArcade.Events;~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~using DIKUArcade.Timers;~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~namespace Breakout.BreakoutStates {~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~    ///  This class represents the state that is active when the game is paused.~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~~\\
\cellcolor{gray} &  & \verb~15~ & & \verb~    public class GamePaused : IGameState {~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~~\\
\cellcolor{gray} &  & \verb~17~ & & \verb~        private static GamePaused instance = null;~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~        private Text[] pauseButtons;~\\
\cellcolor{gray} &  & \verb~19~ & & \verb~        private Text ResumeText;~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~        private Text QuitText;~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~        public string SelectedButton;~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~        private Entity BackgroundImage;~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~        private StationaryShape shape;~\\
\cellcolor{gray} &  & \verb~24~ & & \verb~        private IBaseImage image;~\\
\cellcolor{gray} &  & \verb~25~ & & \verb~~\\
\cellcolor{green} & 43 & \verb~26~ & & \verb~        public static GamePaused GetInstance() {~\\
\cellcolor{green} & 44 & \verb~27~ & & \verb~            if (GamePaused.instance == null) {~\\
\cellcolor{green} & 1 & \verb~28~ & & \verb~                GamePaused.instance = new GamePaused();~\\
\cellcolor{green} & 1 & \verb~29~ & & \verb~                GamePaused.instance.InitializeGameState();~\\
\cellcolor{green} & 1 & \verb~30~ & & \verb~            }~\\
\cellcolor{green} & 43 & \verb~31~ & & \verb~            return GamePaused.instance;~\\
\cellcolor{green} & 43 & \verb~32~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~33~ & & \verb~~\\
\cellcolor{gray} &  & \verb~34~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~35~ & & \verb~        /// Initializes the gamestate~\\
\cellcolor{gray} &  & \verb~36~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 1 & \verb~37~ & & \verb~        public void InitializeGameState() {~\\
\cellcolor{green} & 1 & \verb~38~ & & \verb~            ResumeText = new Text("Resume", new Vec2F(0.05f, 0.2f), new Vec2F(0.5f, 0.5f));~\\
\cellcolor{green} & 1 & \verb~39~ & & \verb~            ResumeText.SetColor(new Vec3I(255,255,255));~\\
\cellcolor{green} & 1 & \verb~40~ & & \verb~            QuitText = new Text("Quit Game", new Vec2F(0.05f, 0.05f), new Vec2F(0.5f,  0.5f));~\\
\cellcolor{green} & 1 & \verb~41~ & & \verb~            QuitText.SetColor(new Vec3I(255, 0, 0));~\\
\cellcolor{green} & 1 & \verb~42~ & & \verb~            pauseButtons = new Text[] {ResumeText, QuitText};~\\
\cellcolor{green} & 1 & \verb~43~ & & \verb~            SelectedButton = "Resume";~\\
\cellcolor{green} & 1 & \verb~44~ & & \verb~            shape = new StationaryShape(new Vec2F(0.0f, 0.0f), new Vec2F(1.0f, 1.0f));~\\
\cellcolor{green} & 1 & \verb~45~ & & \verb~            image = new Image(Path.Combine("Assets", "Images", "shipit_titlescreen.png"));~\\
\cellcolor{green} & 1 & \verb~46~ & & \verb~            BackgroundImage = new Entity(shape, image);~\\
\cellcolor{green} & 1 & \verb~47~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~48~ & & \verb~~\\
\cellcolor{gray} &  & \verb~49~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~50~ & & \verb~        /// Resets the state~\\
\cellcolor{gray} &  & \verb~51~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~52~ & & \verb~        public void ResetState() {~\\
\cellcolor{red} & 0 & \verb~53~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~54~ & & \verb~~\\
\cellcolor{gray} &  & \verb~55~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~56~ & & \verb~        /// Updates the state~\\
\cellcolor{gray} &  & \verb~57~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~58~ & & \verb~        public void UpdateState() {~\\
\cellcolor{red} & 0 & \verb~59~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~60~ & & \verb~~\\
\cellcolor{gray} &  & \verb~61~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~62~ & & \verb~        /// Renders the state~\\
\cellcolor{gray} &  & \verb~63~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~64~ & & \verb~        public void RenderState() {~\\
\cellcolor{red} & 0 & \verb~65~ & & \verb~            BackgroundImage.RenderEntity();~\\
\cellcolor{red} & 0 & \verb~66~ & & \verb~            foreach (Text text in pauseButtons) {~\\
\cellcolor{red} & 0 & \verb~67~ & & \verb~                text.RenderText();~\\
\cellcolor{red} & 0 & \verb~68~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~69~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~70~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~71~ & & \verb~        /// handles key events~\\
\cellcolor{gray} &  & \verb~72~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~73~ & & \verb~        /// <param name="action">the actio nto handle</param>~\\
\cellcolor{gray} &  & \verb~74~ & & \verb~        /// <param name="key">the key pressed or released</param>~\\
\cellcolor{green} & 5 & \verb~75~ & & \verb~        public void HandleKeyEvent(KeyboardAction action, KeyboardKey key) {~\\
\cellcolor{green} & 5 & \verb~76~ & & \verb~            switch (action, key) {~\\
\cellcolor{gray} &  & \verb~77~ & & \verb~                case (KeyboardAction.KeyPress, KeyboardKey.Up):~\\
\cellcolor{green} & 2 & \verb~78~ & & \verb~                    KeyPress(key);~\\
\cellcolor{green} & 2 & \verb~79~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~80~ & & \verb~                case (KeyboardAction.KeyPress, KeyboardKey.Down):~\\
\cellcolor{green} & 1 & \verb~81~ & & \verb~                    KeyPress(key);~\\
\cellcolor{green} & 1 & \verb~82~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~83~ & & \verb~                case (KeyboardAction.KeyPress, KeyboardKey.Enter):~\\
\cellcolor{green} & 2 & \verb~84~ & & \verb~                    KeyPress(key);~\\
\cellcolor{green} & 2 & \verb~85~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~86~ & & \verb~                default:~\\
\cellcolor{red} & 0 & \verb~87~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~88~ & & \verb~            }~\\
\cellcolor{green} & 5 & \verb~89~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~90~ & & \verb~~\\
\cellcolor{gray} &  & \verb~91~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~92~ & & \verb~        /// calls SetMoveRight or SetMoveLeft accordinly to the pressed key~\\
\cellcolor{gray} &  & \verb~93~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~94~ & & \verb~        /// <param name="key">pressed key</param>~\\
\cellcolor{green} & 5 & \verb~95~ & & \verb~        private void KeyPress(KeyboardKey key) { // Initiating keypresses on given keys with switch~\\
\cellcolor{green} & 5 & \verb~96~ & & \verb~            switch (key) {~\\
\cellcolor{gray} &  & \verb~97~ & & \verb~                case KeyboardKey.Up:~\\
\cellcolor{green} & 2 & \verb~98~ & & \verb~                    SelectedButton = "Resume";~\\
\cellcolor{green} & 2 & \verb~99~ & & \verb~                    ResumeText.SetColor(new Vec3I(255,255,255));~\\
\cellcolor{green} & 2 & \verb~100~ & & \verb~                    QuitText.SetColor(new Vec3I(255, 0, 0));~\\
\cellcolor{green} & 2 & \verb~101~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~102~ & & \verb~                case KeyboardKey.Down:~\\
\cellcolor{green} & 1 & \verb~103~ & & \verb~                    SelectedButton = "Quit Game";~\\
\cellcolor{green} & 1 & \verb~104~ & & \verb~                    ResumeText.SetColor(new Vec3I(255, 0, 0));~\\
\cellcolor{green} & 1 & \verb~105~ & & \verb~                    QuitText.SetColor(new Vec3I(255, 255, 255)); // Starting movement on press~\\
\cellcolor{green} & 1 & \verb~106~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~107~ & & \verb~                case KeyboardKey.Enter:~\\
\cellcolor{green} & 3 & \verb~108~ & & \verb~                    if (SelectedButton == "Resume") {~\\
\cellcolor{green} & 1 & \verb~109~ & & \verb~                        StaticTimer.ResumeTimer();~\\
\cellcolor{green} & 1 & \verb~110~ & & \verb~                        BreakoutBus.GetBus().RegisterEvent(~\\
\cellcolor{green} & 1 & \verb~111~ & & \verb~                            new GameEvent{~\\
\cellcolor{green} & 1 & \verb~112~ & & \verb~                                EventType = GameEventType.GameStateEvent,~\\
\cellcolor{green} & 1 & \verb~113~ & & \verb~                                Message = "CHANGE_STATE",~\\
\cellcolor{green} & 1 & \verb~114~ & & \verb~                                StringArg1 = "GAME_RUNNING"~\\
\cellcolor{green} & 1 & \verb~115~ & & \verb~                            }~\\
\cellcolor{green} & 1 & \verb~116~ & & \verb~                        );~\\
\cellcolor{green} & 1 & \verb~117~ & & \verb~                    }~\\
\cellcolor{green} & 2 & \verb~118~ & & \verb~                    else if (SelectedButton == "Quit Game") {~\\
\cellcolor{green} & 1 & \verb~119~ & & \verb~                        BreakoutBus.GetBus().RegisterEvent(~\\
\cellcolor{green} & 1 & \verb~120~ & & \verb~                            new GameEvent{~\\
\cellcolor{green} & 1 & \verb~121~ & & \verb~                                EventType = GameEventType.InputEvent,~\\
\cellcolor{green} & 1 & \verb~122~ & & \verb~                                Message = "escape"~\\
\cellcolor{green} & 1 & \verb~123~ & & \verb~                            }~\\
\cellcolor{green} & 1 & \verb~124~ & & \verb~                        );~\\
\cellcolor{green} & 1 & \verb~125~ & & \verb~                    }~\\
\cellcolor{green} & 2 & \verb~126~ & & \verb~                    break;~\\
\cellcolor{red} & 0 & \verb~127~ & & \verb~                default: break;~\\
\cellcolor{gray} &  & \verb~128~ & & \verb~            }~\\
\cellcolor{green} & 5 & \verb~129~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~130~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~131~ & & \verb~}~\\
\end{longtable}
\newpage
\section{Breakout.BreakoutStates.GameRunning}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Breakout.BreakoutStates.GameRunning\\
\textbf{Assembly:} & Breakout\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/magnus/Desktop/SU/DIKUGames/Breakout/GameStates/GameRunning.cs}\end{minipage} \\
\textbf{Covered lines:} & 239\\
\textbf{Uncovered lines:} & 41\\
\textbf{Coverable lines:} & 280\\
\textbf{Total lines:} & 482\\
\textbf{Line coverage:} & 85.3\% (239 of 280)\\
\textbf{Covered branches:} & 50\\
\textbf{Total branches:} & 56\\
\textbf{Branch coverage:} & 89.2\% (50 of 56)\\
\textbf{Covered methods:} & 31\\
\textbf{Total methods:} & 33\\
\textbf{Method coverage:} & 93.9\% (31 of 33)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{get\_player()} & 100\% & 1 & 100\%\\
\hline
\textbf{get\_blocks()} & 100\% & 1 & 100\%\\
\hline
\textbf{get\_gameOver()} & 100\% & 1 & 100\%\\
\hline
\textbf{get\_balls()} & 100\% & 1 & 100\%\\
\hline
\textbf{GetInstance()} & 100\% & 2 & 100\%\\
\hline
\textbf{InitializeGameState(} & 100\% & 1 & 100\%\\
\hline
\textbf{ResetState()} & 100\% & 1 & 100\%\\
\hline
\textbf{UpdateState()} & 100\% & 1 & 100\%\\
\hline
\textbf{RenderState()} & 100\% & 1 & 0\%\\
\hline
\textbf{HandleKeyEvent(...)} & 100\% & 4 & 87.50\%\\
\hline
\textbf{KeyPress(...)} & 66.66\% & 12 & 45.83\%\\
\hline
\textbf{KeyRelease(...)} & 50.0\% & 4 & 57.14\%\\
\hline
\textbf{NewLevel()} & 100\% & 4 & 82.35\%\\
\hline
\textbf{CheckGameOver()} & 100\% & 6 & 100\%\\
\hline
\textbf{ProcessEvent(...)} & 100\% & 8 & 100\%\\
\hline
\textbf{RemoveDeletedEntitie} & 100\% & 4 & 100\%\\
\hline
\textbf{OnlyUnbreakBlocks()} & 100\% & 4 & 100\%\\
\hline
\textbf{CreateBall()} & 100\% & 1 & 100\%\\
\hline
\textbf{MoveBalls()} & 100\% & 2 & 100\%\\
\hline
\textbf{ResetBalls()} & 100\% & 1 & 100\%\\
\hline
\textbf{CheckBallsEmpty()} & 100\% & 2 & 100\%\\
\hline
\textbf{GameLost()} & 100\% & 1 & 100\%\\
\hline
\textbf{GameWon()} & 100\% & 1 & 100\%\\
\hline
\textbf{GamePaused()} & 100\% & 1 & 0\%\\
\hline
\textbf{SendPoints()} & 100\% & 1 & 100\%\\
\hline
\textbf{PowerUpIterate()} & 100\% & 2 & 100\%\\
\hline
\textbf{HandleTime()} & 100\% & 2 & 100\%\\
\hline
\textbf{GetPlayer()} & 100\% & 1 & 100\%\\
\hline
\textbf{GetLevelLoader()} & 100\% & 1 & 100\%\\
\hline
\textbf{GetPointsField()} & 100\% & 1 & 100\%\\
\hline
\textbf{CallRemoveDeletedEnt} & 100\% & 1 & 100\%\\
\hline
\textbf{GetLevel()} & 100\% & 1 & 100\%\\
\hline
\textbf{GetHasTime()} & 100\% & 1 & 100\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/magnus/Desktop/SU/DIKUGames/Breakout/GameStates/GameRunning.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.Graphics;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using DIKUArcade.State;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~using DIKUArcade.Input;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~using DIKUArcade.Math;~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~using DIKUArcade.Events;~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~using Breakout;~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~using DIKUArcade.Timers;~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~using System;~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~namespace Breakout.BreakoutStates {~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~    ///  This class represents the state that is active when the game is running.~\\
\cellcolor{gray} &  & \verb~15~ & & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~    public class GameRunning : IGameState, IGameEventProcessor {~\\
\cellcolor{gray} &  & \verb~17~ & & \verb~~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~        private static GameRunning instance = null;~\\
\cellcolor{green} & 49 & \verb~19~ & & \verb~        private Player player{get; set;}~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~        private LevelLoader levelLoader;~\\
\cellcolor{green} & 81 & \verb~21~ & & \verb~        public EntityContainer<Block> blocks {get; private set;}~\\
\cellcolor{green} & 34 & \verb~22~ & & \verb~        public bool gameOver{get;set;}~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~        private int level;~\\
\cellcolor{gray} &  & \verb~24~ & & \verb~        private Points points;~\\
\cellcolor{green} & 101 & \verb~25~ & & \verb~        public EntityContainer<Ball> balls{get;private set;}~\\
\cellcolor{gray} &  & \verb~26~ & & \verb~        public int maxBalls;~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~        public EntityContainer<PowerUpDrop> powerDrops;~\\
\cellcolor{gray} &  & \verb~28~ & & \verb~        private double currentTime;~\\
\cellcolor{gray} &  & \verb~29~ & & \verb~        private Text timeText;~\\
\cellcolor{gray} &  & \verb~30~ & & \verb~        public int timeLeft;~\\
\cellcolor{gray} &  & \verb~31~ & & \verb~        public double startTime;~\\
\cellcolor{gray} &  & \verb~32~ & & \verb~        private bool hasTime;~\\
\cellcolor{gray} &  & \verb~33~ & & \verb~~\\
\cellcolor{gray} &  & \verb~34~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~35~ & & \verb~        /// GetInstance sets up the GameRunning~\\
\cellcolor{gray} &  & \verb~36~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 165 & \verb~37~ & & \verb~        public static GameRunning GetInstance() {~\\
\cellcolor{green} & 166 & \verb~38~ & & \verb~            if (GameRunning.instance == null) {~\\
\cellcolor{green} & 1 & \verb~39~ & & \verb~                GameRunning.instance = new GameRunning();~\\
\cellcolor{green} & 1 & \verb~40~ & & \verb~                GameRunning.instance.InitializeGameState();~\\
\cellcolor{green} & 1 & \verb~41~ & & \verb~            }~\\
\cellcolor{green} & 165 & \verb~42~ & & \verb~            return GameRunning.instance;~\\
\cellcolor{green} & 165 & \verb~43~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~44~ & & \verb~~\\
\cellcolor{gray} &  & \verb~45~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~46~ & & \verb~        /// Initializes all fields, and what else is needed for the methods~\\
\cellcolor{gray} &  & \verb~47~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 1 & \verb~48~ & & \verb~        public void InitializeGameState() {~\\
\cellcolor{green} & 1 & \verb~49~ & & \verb~            BreakoutBus.GetBus().Subscribe(GameEventType.StatusEvent, this);~\\
\cellcolor{green} & 1 & \verb~50~ & & \verb~            player = new Player( // player is instantiated with positions and image~\\
\cellcolor{green} & 1 & \verb~51~ & & \verb~                new DynamicShape(new Vec2F(0.425f, 0.03f), new Vec2F(0.16f, 0.020f)),~\\
\cellcolor{green} & 1 & \verb~52~ & & \verb~                new Image(Path.Combine("Assets", "Images", "player.png")));~\\
\cellcolor{green} & 1 & \verb~53~ & & \verb~            BreakoutBus.GetBus().Subscribe(GameEventType.PlayerEvent, player);~\\
\cellcolor{gray} &  & \verb~54~ & & \verb~~\\
\cellcolor{gray} &  & \verb~55~ & & \verb~            //elements~\\
\cellcolor{green} & 1 & \verb~56~ & & \verb~            blocks = new EntityContainer<Block>(288);~\\
\cellcolor{green} & 1 & \verb~57~ & & \verb~            levelLoader = new LevelLoader();~\\
\cellcolor{green} & 1 & \verb~58~ & & \verb~            gameOver = false;~\\
\cellcolor{green} & 1 & \verb~59~ & & \verb~            level = 0;~\\
\cellcolor{green} & 1 & \verb~60~ & & \verb~            points = new Points(new Vec2F(0.6f,0.5f), new Vec2F(0.5f,0.5f));~\\
\cellcolor{green} & 1 & \verb~61~ & & \verb~            BreakoutBus.GetBus().Subscribe(GameEventType.GraphicsEvent, points);~\\
\cellcolor{green} & 1 & \verb~62~ & & \verb~            maxBalls = 10;~\\
\cellcolor{green} & 1 & \verb~63~ & & \verb~            balls = new EntityContainer<Ball>(maxBalls);~\\
\cellcolor{green} & 1 & \verb~64~ & & \verb~            balls.AddEntity(CreateBall());~\\
\cellcolor{green} & 1 & \verb~65~ & & \verb~            powerDrops = new EntityContainer<PowerUpDrop>();~\\
\cellcolor{gray} &  & \verb~66~ & & \verb~~\\
\cellcolor{gray} &  & \verb~67~ & & \verb~            //Time related~\\
\cellcolor{green} & 1 & \verb~68~ & & \verb~            currentTime = 0.0;~\\
\cellcolor{green} & 1 & \verb~69~ & & \verb~            startTime = 0.0;~\\
\cellcolor{green} & 1 & \verb~70~ & & \verb~            timeLeft = 0;~\\
\cellcolor{green} & 1 & \verb~71~ & & \verb~            timeText = new Text("", new Vec2F(0.05f, 0.2f), new Vec2F(0.5f, 0.5f));~\\
\cellcolor{green} & 1 & \verb~72~ & & \verb~            timeText.SetColor(new Vec3I(255,255,255));~\\
\cellcolor{green} & 1 & \verb~73~ & & \verb~            hasTime = false;~\\
\cellcolor{green} & 1 & \verb~74~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~75~ & & \verb~~\\
\cellcolor{gray} &  & \verb~76~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~77~ & & \verb~        /// Resets the game. Used when game is over, or new level loads~\\
\cellcolor{gray} &  & \verb~78~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 14 & \verb~79~ & & \verb~        public void ResetState() {~\\
\cellcolor{green} & 14 & \verb~80~ & & \verb~            blocks.ClearContainer();~\\
\cellcolor{green} & 14 & \verb~81~ & & \verb~            powerDrops.ClearContainer();~\\
\cellcolor{green} & 14 & \verb~82~ & & \verb~            level = 0;~\\
\cellcolor{green} & 14 & \verb~83~ & & \verb~            gameOver = false;~\\
\cellcolor{green} & 14 & \verb~84~ & & \verb~            player.Reset();~\\
\cellcolor{green} & 14 & \verb~85~ & & \verb~            ResetBalls();~\\
\cellcolor{green} & 14 & \verb~86~ & & \verb~            points.ResetPoints();~\\
\cellcolor{green} & 14 & \verb~87~ & & \verb~            hasTime = false;~\\
\cellcolor{green} & 14 & \verb~88~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~89~ & & \verb~~\\
\cellcolor{gray} &  & \verb~90~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~91~ & & \verb~        /// Updates all game functionality~\\
\cellcolor{gray} &  & \verb~92~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 9 & \verb~93~ & & \verb~        public void UpdateState() {~\\
\cellcolor{green} & 9 & \verb~94~ & & \verb~            HandleTime();~\\
\cellcolor{green} & 9 & \verb~95~ & & \verb~            player.Move();~\\
\cellcolor{green} & 9 & \verb~96~ & & \verb~            MoveBalls();~\\
\cellcolor{green} & 9 & \verb~97~ & & \verb~            RemoveDeletedEntities();~\\
\cellcolor{green} & 9 & \verb~98~ & & \verb~            CheckBallsEmpty();~\\
\cellcolor{green} & 9 & \verb~99~ & & \verb~            CheckGameOver();~\\
\cellcolor{green} & 9 & \verb~100~ & & \verb~            NewLevel();~\\
\cellcolor{green} & 9 & \verb~101~ & & \verb~            PowerUpIterate();~\\
\cellcolor{green} & 9 & \verb~102~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~103~ & & \verb~~\\
\cellcolor{gray} &  & \verb~104~ & & \verb~~\\
\cellcolor{gray} &  & \verb~105~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~106~ & & \verb~        /// Renders all in game~\\
\cellcolor{gray} &  & \verb~107~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~108~ & & \verb~        public void RenderState() {~\\
\cellcolor{red} & 0 & \verb~109~ & & \verb~            player.Render();~\\
\cellcolor{red} & 0 & \verb~110~ & & \verb~            blocks.RenderEntities();~\\
\cellcolor{red} & 0 & \verb~111~ & & \verb~            balls.RenderEntities();~\\
\cellcolor{red} & 0 & \verb~112~ & & \verb~            points.RenderPoints();~\\
\cellcolor{red} & 0 & \verb~113~ & & \verb~            powerDrops.RenderEntities();~\\
\cellcolor{red} & 0 & \verb~114~ & & \verb~            timeText.RenderText();~\\
\cellcolor{red} & 0 & \verb~115~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~116~ & & \verb~~\\
\cellcolor{gray} &  & \verb~117~ & & \verb~~\\
\cellcolor{gray} &  & \verb~118~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~119~ & & \verb~        /// Delegates the KeyEvents to the PressKey() or ReleaseKey()~\\
\cellcolor{gray} &  & \verb~120~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~121~ & & \verb~        /// <param name="action"> the action performed </param>~\\
\cellcolor{gray} &  & \verb~122~ & & \verb~        /// <param name="key">the key pressed</param>~\\
\cellcolor{green} & 4 & \verb~123~ & & \verb~        public void HandleKeyEvent(KeyboardAction action, KeyboardKey key) {~\\
\cellcolor{green} & 4 & \verb~124~ & & \verb~            switch (action) {~\\
\cellcolor{gray} &  & \verb~125~ & & \verb~                case KeyboardAction.KeyPress:~\\
\cellcolor{green} & 3 & \verb~126~ & & \verb~                    KeyPress(key);~\\
\cellcolor{green} & 3 & \verb~127~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~128~ & & \verb~                case KeyboardAction.KeyRelease:~\\
\cellcolor{green} & 1 & \verb~129~ & & \verb~                    KeyRelease(key);~\\
\cellcolor{green} & 1 & \verb~130~ & & \verb~                    break;~\\
\cellcolor{red} & 0 & \verb~131~ & & \verb~                default: break;~\\
\cellcolor{gray} &  & \verb~132~ & & \verb~            }~\\
\cellcolor{green} & 4 & \verb~133~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~134~ & & \verb~~\\
\cellcolor{gray} &  & \verb~135~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~136~ & & \verb~        /// Creates the relevant GameEvents.~\\
\cellcolor{gray} &  & \verb~137~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~138~ & & \verb~        /// <param name="key">the key switch with</param>~\\
\cellcolor{green} & 3 & \verb~139~ & & \verb~        private void KeyPress(KeyboardKey key) {~\\
\cellcolor{orange} & 3 & \verb~140~ & & \verb~            switch (key) {~\\
\cellcolor{gray} &  & \verb~141~ & & \verb~                case KeyboardKey.Escape:~\\
\cellcolor{red} & 0 & \verb~142~ & & \verb~                    GamePaused();~\\
\cellcolor{red} & 0 & \verb~143~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~144~ & & \verb~                case KeyboardKey.Right:~\\
\cellcolor{green} & 1 & \verb~145~ & & \verb~                    BreakoutBus.GetBus().RegisterEvent (new GameEvent {~\\
\cellcolor{green} & 1 & \verb~146~ & & \verb~                        EventType = GameEventType.PlayerEvent, Message = "KeyPress",~\\
\cellcolor{green} & 1 & \verb~147~ & & \verb~                        IntArg1 = (int) key~\\
\cellcolor{green} & 1 & \verb~148~ & & \verb~                    });~\\
\cellcolor{gray} &  & \verb~149~ & & \verb~~\\
\cellcolor{green} & 1 & \verb~150~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~151~ & & \verb~                case KeyboardKey.Left:~\\
\cellcolor{red} & 0 & \verb~152~ & & \verb~                    BreakoutBus.GetBus().RegisterEvent (new GameEvent {~\\
\cellcolor{red} & 0 & \verb~153~ & & \verb~                        EventType = GameEventType.PlayerEvent, Message = "KeyPress",~\\
\cellcolor{red} & 0 & \verb~154~ & & \verb~                        IntArg1 = (int) key~\\
\cellcolor{red} & 0 & \verb~155~ & & \verb~                    });~\\
\cellcolor{red} & 0 & \verb~156~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~157~ & & \verb~~\\
\cellcolor{gray} &  & \verb~158~ & & \verb~                case KeyboardKey.G: // To skip a level~\\
\cellcolor{green} & 2 & \verb~159~ & & \verb~                    blocks.ClearContainer();~\\
\cellcolor{green} & 2 & \verb~160~ & & \verb~                    NewLevel();~\\
\cellcolor{green} & 2 & \verb~161~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~162~ & & \verb~~\\
\cellcolor{gray} &  & \verb~163~ & & \verb~                case KeyboardKey.Space: // Launch ball~\\
\cellcolor{red} & 0 & \verb~164~ & & \verb~                    BreakoutBus.GetBus().RegisterEvent (new GameEvent {~\\
\cellcolor{red} & 0 & \verb~165~ & & \verb~                        EventType = GameEventType.InputEvent,~\\
\cellcolor{red} & 0 & \verb~166~ & & \verb~                        Message = "LAUNCH_BALL"~\\
\cellcolor{red} & 0 & \verb~167~ & & \verb~                    });~\\
\cellcolor{red} & 0 & \verb~168~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~169~ & & \verb~                default:~\\
\cellcolor{red} & 0 & \verb~170~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~171~ & & \verb~            }~\\
\cellcolor{green} & 3 & \verb~172~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~173~ & & \verb~~\\
\cellcolor{gray} &  & \verb~174~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~175~ & & \verb~        /// Creates the relevant GameEvents.~\\
\cellcolor{gray} &  & \verb~176~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~177~ & & \verb~        /// <param name="key">the key released</param>~\\
\cellcolor{green} & 1 & \verb~178~ & & \verb~        private void KeyRelease(KeyboardKey key) {~\\
\cellcolor{orange} & 1 & \verb~179~ & & \verb~            switch (key) {~\\
\cellcolor{gray} &  & \verb~180~ & & \verb~                case KeyboardKey.Right: // Move player right~\\
\cellcolor{green} & 1 & \verb~181~ & & \verb~                    BreakoutBus.GetBus().RegisterEvent (new GameEvent {~\\
\cellcolor{green} & 1 & \verb~182~ & & \verb~                        EventType = GameEventType.PlayerEvent, Message = "KeyRelease",~\\
\cellcolor{green} & 1 & \verb~183~ & & \verb~                        IntArg1 = (int) key~\\
\cellcolor{green} & 1 & \verb~184~ & & \verb~                    });~\\
\cellcolor{green} & 1 & \verb~185~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~186~ & & \verb~                case KeyboardKey.Left: // Move player left~\\
\cellcolor{red} & 0 & \verb~187~ & & \verb~                    BreakoutBus.GetBus().RegisterEvent (new GameEvent {~\\
\cellcolor{red} & 0 & \verb~188~ & & \verb~                        EventType = GameEventType.PlayerEvent, Message = "KeyRelease",~\\
\cellcolor{red} & 0 & \verb~189~ & & \verb~                        IntArg1 = (int) key~\\
\cellcolor{red} & 0 & \verb~190~ & & \verb~                    });~\\
\cellcolor{red} & 0 & \verb~191~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~192~ & & \verb~                default:~\\
\cellcolor{red} & 0 & \verb~193~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~194~ & & \verb~            }~\\
\cellcolor{green} & 1 & \verb~195~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~196~ & & \verb~~\\
\cellcolor{gray} &  & \verb~197~ & & \verb~~\\
\cellcolor{gray} &  & \verb~198~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~199~ & & \verb~        /// Creates a batch of blocks if the entitylist blocks is empty.~\\
\cellcolor{gray} &  & \verb~200~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 11 & \verb~201~ & & \verb~        private void NewLevel(){~\\
\cellcolor{green} & 20 & \verb~202~ & & \verb~            if (blocks.CountEntities() <= 0 || OnlyUnbreakBlocks()) {~\\
\cellcolor{green} & 9 & \verb~203~ & & \verb~                try{~\\
\cellcolor{green} & 9 & \verb~204~ & & \verb~                    StaticTimer.RestartTimer();~\\
\cellcolor{green} & 9 & \verb~205~ & & \verb~                    ResetBalls();~\\
\cellcolor{green} & 9 & \verb~206~ & & \verb~                    player.Reset();~\\
\cellcolor{green} & 9 & \verb~207~ & & \verb~                    level++;~\\
\cellcolor{gray} &  & \verb~208~ & & \verb~                    //The current level as string~\\
\cellcolor{green} & 9 & \verb~209~ & & \verb~                    string levelstring = "level" + this.level + ".txt";~\\
\cellcolor{green} & 9 & \verb~210~ & & \verb~                    blocks = levelLoader.LoadLevel(levelstring);~\\
\cellcolor{red} & 0 & \verb~211~ & & \verb~                    hasTime=false;~\\
\cellcolor{red} & 0 & \verb~212~ & & \verb~                    powerDrops.ClearContainer();~\\
\cellcolor{red} & 0 & \verb~213~ & & \verb~                }~\\
\cellcolor{green} & 18 & \verb~214~ & & \verb~                catch{ //catches no more levels, and as such ends the game.~\\
\cellcolor{green} & 9 & \verb~215~ & & \verb~                    GameWon();~\\
\cellcolor{green} & 9 & \verb~216~ & & \verb~                }~\\
\cellcolor{gray} &  & \verb~217~ & & \verb~~\\
\cellcolor{green} & 9 & \verb~218~ & & \verb~            }~\\
\cellcolor{green} & 11 & \verb~219~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~220~ & & \verb~~\\
\cellcolor{gray} &  & \verb~221~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~222~ & & \verb~        /// checks if the game is over.~\\
\cellcolor{gray} &  & \verb~223~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 15 & \verb~224~ & & \verb~        public void CheckGameOver() {~\\
\cellcolor{green} & 17 & \verb~225~ & & \verb~            if(gameOver){~\\
\cellcolor{green} & 2 & \verb~226~ & & \verb~                GameLost();~\\
\cellcolor{green} & 2 & \verb~227~ & & \verb~            }~\\
\cellcolor{green} & 16 & \verb~228~ & & \verb~            if (hasTime && timeLeft < 0){~\\
\cellcolor{green} & 1 & \verb~229~ & & \verb~                GameLost();~\\
\cellcolor{green} & 1 & \verb~230~ & & \verb~            }~\\
\cellcolor{green} & 15 & \verb~231~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~232~ & & \verb~~\\
\cellcolor{gray} &  & \verb~233~ & & \verb~~\\
\cellcolor{gray} &  & \verb~234~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~235~ & & \verb~        /// Processes all events in the EventBus, but only matches on relevant.~\\
\cellcolor{gray} &  & \verb~236~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~237~ & & \verb~        /// <param name="gameEvent"></param>~\\
\cellcolor{green} & 10 & \verb~238~ & & \verb~        public void ProcessEvent(GameEvent gameEvent){~\\
\cellcolor{green} & 19 & \verb~239~ & & \verb~            if (gameEvent.EventType == GameEventType.StatusEvent) {~\\
\cellcolor{green} & 9 & \verb~240~ & & \verb~                    switch (gameEvent.Message) {~\\
\cellcolor{gray} &  & \verb~241~ & & \verb~                        case "PlayerDead":~\\
\cellcolor{green} & 1 & \verb~242~ & & \verb~                            GameLost();~\\
\cellcolor{green} & 1 & \verb~243~ & & \verb~                            break;~\\
\cellcolor{gray} &  & \verb~244~ & & \verb~                        case "Time":~\\
\cellcolor{green} & 6 & \verb~245~ & & \verb~                            startTime = int.Parse(gameEvent.StringArg1);~\\
\cellcolor{green} & 6 & \verb~246~ & & \verb~                            hasTime = true;~\\
\cellcolor{green} & 6 & \verb~247~ & & \verb~                            break;~\\
\cellcolor{gray} &  & \verb~248~ & & \verb~                        case "IncTime":~\\
\cellcolor{green} & 1 & \verb~249~ & & \verb~                            startTime = startTime+10;~\\
\cellcolor{green} & 1 & \verb~250~ & & \verb~                            break;~\\
\cellcolor{gray} &  & \verb~251~ & & \verb~                        default:~\\
\cellcolor{green} & 1 & \verb~252~ & & \verb~                            break;~\\
\cellcolor{gray} &  & \verb~253~ & & \verb~                    }~\\
\cellcolor{green} & 9 & \verb~254~ & & \verb~            }~\\
\cellcolor{green} & 10 & \verb~255~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~256~ & & \verb~~\\
\cellcolor{gray} &  & \verb~257~ & & \verb~~\\
\cellcolor{gray} &  & \verb~258~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~259~ & & \verb~        /// Removes all deleted entities.~\\
\cellcolor{gray} &  & \verb~260~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 13 & \verb~261~ & & \verb~        private void RemoveDeletedEntities() {~\\
\cellcolor{gray} &  & \verb~262~ & & \verb~            //deletes all blocks that are deleted~\\
\cellcolor{green} & 21 & \verb~263~ & & \verb~            blocks.Iterate(block => {~\\
\cellcolor{green} & 10 & \verb~264~ & & \verb~                if (block.IsDeleted()) {~\\
\cellcolor{green} & 3 & \verb~265~ & & \verb~                    if (block.IsPowerUp() == true) { // Checks if block is a PowerUpBlock~\\
\cellcolor{green} & 1 & \verb~266~ & & \verb~                        powerDrops.AddEntity(new PowerUpDrop(~\\
\cellcolor{green} & 1 & \verb~267~ & & \verb~                            // powerUpDrop is instantiated with positions and image~\\
\cellcolor{green} & 1 & \verb~268~ & & \verb~                            new DynamicShape(block.shape.Position, new Vec2F(0.06f, 0.06f)),~\\
\cellcolor{green} & 1 & \verb~269~ & & \verb~                            new Image(Path.Combine("Assets", "Images", "RocketPickUp.png"))));~\\
\cellcolor{green} & 1 & \verb~270~ & & \verb~                    }~\\
\cellcolor{green} & 2 & \verb~271~ & & \verb~                    block.DeleteEntity();~\\
\cellcolor{green} & 2 & \verb~272~ & & \verb~                }~\\
\cellcolor{green} & 21 & \verb~273~ & & \verb~            });~\\
\cellcolor{gray} &  & \verb~274~ & & \verb~            // Deletes all balls that are deleted~\\
\cellcolor{green} & 22 & \verb~275~ & & \verb~            balls.Iterate(ball => {~\\
\cellcolor{green} & 10 & \verb~276~ & & \verb~                if (ball.IsDeleted()) {~\\
\cellcolor{green} & 1 & \verb~277~ & & \verb~                    ball.DeleteEntity();~\\
\cellcolor{green} & 1 & \verb~278~ & & \verb~                }~\\
\cellcolor{green} & 22 & \verb~279~ & & \verb~            });~\\
\cellcolor{gray} &  & \verb~280~ & & \verb~            // Deletes all drops that are deleted~\\
\cellcolor{green} & 16 & \verb~281~ & & \verb~            powerDrops.Iterate(drop => {~\\
\cellcolor{green} & 4 & \verb~282~ & & \verb~                if (drop.IsDeleted()) {~\\
\cellcolor{green} & 1 & \verb~283~ & & \verb~                    drop.DeleteEntity();~\\
\cellcolor{green} & 1 & \verb~284~ & & \verb~                }~\\
\cellcolor{green} & 16 & \verb~285~ & & \verb~            });~\\
\cellcolor{green} & 13 & \verb~286~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~287~ & & \verb~~\\
\cellcolor{gray} &  & \verb~288~ & & \verb~~\\
\cellcolor{gray} &  & \verb~289~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~290~ & & \verb~        /// Checks if there are only unbreakable blocks in level~\\
\cellcolor{gray} &  & \verb~291~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~292~ & & \verb~        /// <returns></returns>~\\
\cellcolor{green} & 4 & \verb~293~ & & \verb~        private bool OnlyUnbreakBlocks() {~\\
\cellcolor{green} & 4 & \verb~294~ & & \verb~            bool onlyUnbreakBlocks = true;~\\
\cellcolor{green} & 27 & \verb~295~ & & \verb~            foreach(Block block in blocks) {~\\
\cellcolor{green} & 7 & \verb~296~ & & \verb~                if (block is not UnbreakableBlock) {~\\
\cellcolor{green} & 2 & \verb~297~ & & \verb~                    onlyUnbreakBlocks = false;~\\
\cellcolor{green} & 2 & \verb~298~ & & \verb~                }~\\
\cellcolor{green} & 5 & \verb~299~ & & \verb~            }~\\
\cellcolor{green} & 4 & \verb~300~ & & \verb~            return onlyUnbreakBlocks;~\\
\cellcolor{green} & 4 & \verb~301~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~302~ & & \verb~~\\
\cellcolor{gray} &  & \verb~303~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~304~ & & \verb~        /// Creates a ball~\\
\cellcolor{gray} &  & \verb~305~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~306~ & & \verb~        /// <returns> Returns a ball </returns>~\\
\cellcolor{green} & 26 & \verb~307~ & & \verb~        public Ball CreateBall() {~\\
\cellcolor{green} & 26 & \verb~308~ & & \verb~            Ball ball = new Ball (~\\
\cellcolor{green} & 26 & \verb~309~ & & \verb~                new DynamicShape(new Vec2F(0.49f, 0.05f), new Vec2F(0.04f, 0.04f)),~\\
\cellcolor{green} & 26 & \verb~310~ & & \verb~                new Image(Path.Combine("Assets", "Images", "ball2.png")));~\\
\cellcolor{green} & 26 & \verb~311~ & & \verb~            BreakoutBus.GetBus().Subscribe(GameEventType.InputEvent, ball);~\\
\cellcolor{green} & 26 & \verb~312~ & & \verb~            return ball;~\\
\cellcolor{green} & 26 & \verb~313~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~314~ & & \verb~~\\
\cellcolor{gray} &  & \verb~315~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~316~ & & \verb~        /// Moves all balls in the game~\\
\cellcolor{gray} &  & \verb~317~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 9 & \verb~318~ & & \verb~        private void MoveBalls() {~\\
\cellcolor{green} & 48 & \verb~319~ & & \verb~            foreach (Ball ball in balls) {~\\
\cellcolor{green} & 7 & \verb~320~ & & \verb~                ball.Move(player, blocks);~\\
\cellcolor{green} & 7 & \verb~321~ & & \verb~            }~\\
\cellcolor{green} & 9 & \verb~322~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~323~ & & \verb~~\\
\cellcolor{gray} &  & \verb~324~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~325~ & & \verb~        /// Deletes all balls and creates a new~\\
\cellcolor{gray} &  & \verb~326~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 23 & \verb~327~ & & \verb~        private void ResetBalls() {~\\
\cellcolor{green} & 47 & \verb~328~ & & \verb~            balls.Iterate(ball => {~\\
\cellcolor{green} & 24 & \verb~329~ & & \verb~                    ball.DeleteEntity();~\\
\cellcolor{green} & 47 & \verb~330~ & & \verb~            });~\\
\cellcolor{green} & 23 & \verb~331~ & & \verb~            balls.AddEntity(CreateBall());~\\
\cellcolor{green} & 23 & \verb~332~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~333~ & & \verb~~\\
\cellcolor{gray} &  & \verb~334~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~335~ & & \verb~        /// Checks if there af no more balls in game and decreases life of player.~\\
\cellcolor{gray} &  & \verb~336~ & & \verb~        /// Creates new ball~\\
\cellcolor{gray} &  & \verb~337~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 9 & \verb~338~ & & \verb~        private void CheckBallsEmpty() {~\\
\cellcolor{green} & 11 & \verb~339~ & & \verb~            if (balls.CountEntities() <= 0) {~\\
\cellcolor{green} & 2 & \verb~340~ & & \verb~                BreakoutBus.GetBus().RegisterEvent (new GameEvent {~\\
\cellcolor{green} & 2 & \verb~341~ & & \verb~                        EventType = GameEventType.PlayerEvent, Message = "DecLife"~\\
\cellcolor{green} & 2 & \verb~342~ & & \verb~                    });~\\
\cellcolor{green} & 2 & \verb~343~ & & \verb~                balls.AddEntity(CreateBall());~\\
\cellcolor{green} & 2 & \verb~344~ & & \verb~            }~\\
\cellcolor{green} & 9 & \verb~345~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~346~ & & \verb~~\\
\cellcolor{gray} &  & \verb~347~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~348~ & & \verb~        /// Game over and lost. Sends points for use in lose screen. State is changed~\\
\cellcolor{gray} &  & \verb~349~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 4 & \verb~350~ & & \verb~        private void GameLost() {~\\
\cellcolor{green} & 4 & \verb~351~ & & \verb~            SendPoints();~\\
\cellcolor{green} & 4 & \verb~352~ & & \verb~            ResetState();~\\
\cellcolor{green} & 4 & \verb~353~ & & \verb~            BreakoutBus.GetBus().RegisterEvent(~\\
\cellcolor{green} & 4 & \verb~354~ & & \verb~                        new GameEvent {~\\
\cellcolor{green} & 4 & \verb~355~ & & \verb~                            EventType = GameEventType.GameStateEvent,~\\
\cellcolor{green} & 4 & \verb~356~ & & \verb~                            Message = "CHANGE_STATE",~\\
\cellcolor{green} & 4 & \verb~357~ & & \verb~                            StringArg1 = "GAME_LOST"~\\
\cellcolor{green} & 4 & \verb~358~ & & \verb~                        }~\\
\cellcolor{green} & 4 & \verb~359~ & & \verb~            );~\\
\cellcolor{green} & 4 & \verb~360~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~361~ & & \verb~~\\
\cellcolor{gray} &  & \verb~362~ & & \verb~~\\
\cellcolor{gray} &  & \verb~363~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~364~ & & \verb~        /// Game over and won. Sends points for use in win screen. State is changed~\\
\cellcolor{gray} &  & \verb~365~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 9 & \verb~366~ & & \verb~        private void GameWon() {~\\
\cellcolor{green} & 9 & \verb~367~ & & \verb~            SendPoints();~\\
\cellcolor{green} & 9 & \verb~368~ & & \verb~            ResetState();~\\
\cellcolor{green} & 9 & \verb~369~ & & \verb~            BreakoutBus.GetBus().RegisterEvent(~\\
\cellcolor{green} & 9 & \verb~370~ & & \verb~                        new GameEvent {~\\
\cellcolor{green} & 9 & \verb~371~ & & \verb~                            EventType = GameEventType.GameStateEvent,~\\
\cellcolor{green} & 9 & \verb~372~ & & \verb~                            Message = "CHANGE_STATE",~\\
\cellcolor{green} & 9 & \verb~373~ & & \verb~                            StringArg1 = "GAME_WON"~\\
\cellcolor{green} & 9 & \verb~374~ & & \verb~                        }~\\
\cellcolor{green} & 9 & \verb~375~ & & \verb~            );~\\
\cellcolor{green} & 9 & \verb~376~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~377~ & & \verb~~\\
\cellcolor{gray} &  & \verb~378~ & & \verb~~\\
\cellcolor{gray} &  & \verb~379~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~380~ & & \verb~        /// Game pauses. Changes state to pause screen. Pauses timer.~\\
\cellcolor{gray} &  & \verb~381~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~382~ & & \verb~        private void GamePaused() {~\\
\cellcolor{red} & 0 & \verb~383~ & & \verb~            StaticTimer.PauseTimer();~\\
\cellcolor{red} & 0 & \verb~384~ & & \verb~            BreakoutBus.GetBus().RegisterEvent(~\\
\cellcolor{red} & 0 & \verb~385~ & & \verb~                        new GameEvent {~\\
\cellcolor{red} & 0 & \verb~386~ & & \verb~                            EventType = GameEventType.GameStateEvent,~\\
\cellcolor{red} & 0 & \verb~387~ & & \verb~                            Message = "CHANGE_STATE",~\\
\cellcolor{red} & 0 & \verb~388~ & & \verb~                            StringArg1 = "GAME_PAUSED"~\\
\cellcolor{red} & 0 & \verb~389~ & & \verb~                        }~\\
\cellcolor{red} & 0 & \verb~390~ & & \verb~            );~\\
\cellcolor{red} & 0 & \verb~391~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~392~ & & \verb~~\\
\cellcolor{gray} &  & \verb~393~ & & \verb~~\\
\cellcolor{gray} &  & \verb~394~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~395~ & & \verb~        /// Sends points to game over screens~\\
\cellcolor{gray} &  & \verb~396~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 13 & \verb~397~ & & \verb~        private void SendPoints() {~\\
\cellcolor{green} & 13 & \verb~398~ & & \verb~            BreakoutBus.GetBus().RegisterEvent(~\\
\cellcolor{green} & 13 & \verb~399~ & & \verb~                        new GameEvent {~\\
\cellcolor{green} & 13 & \verb~400~ & & \verb~                            EventType = GameEventType.ControlEvent,~\\
\cellcolor{green} & 13 & \verb~401~ & & \verb~                            Message = "GamePoints",~\\
\cellcolor{green} & 13 & \verb~402~ & & \verb~                            IntArg1 = points.GetPoints()~\\
\cellcolor{green} & 13 & \verb~403~ & & \verb~                        }~\\
\cellcolor{green} & 13 & \verb~404~ & & \verb~            );~\\
\cellcolor{green} & 13 & \verb~405~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~406~ & & \verb~~\\
\cellcolor{gray} &  & \verb~407~ & & \verb~~\\
\cellcolor{gray} &  & \verb~408~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~409~ & & \verb~        /// Moves all powerups and lets player catch them~\\
\cellcolor{gray} &  & \verb~410~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 11 & \verb~411~ & & \verb~        public void PowerUpIterate() {~\\
\cellcolor{green} & 36 & \verb~412~ & & \verb~            foreach (PowerUpDrop Drop in powerDrops) {~\\
\cellcolor{green} & 1 & \verb~413~ & & \verb~                Drop.Move();~\\
\cellcolor{green} & 1 & \verb~414~ & & \verb~                Drop.Consume(player,Drop.powerUpNumber);~\\
\cellcolor{green} & 1 & \verb~415~ & & \verb~            }~\\
\cellcolor{green} & 11 & \verb~416~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~417~ & & \verb~~\\
\cellcolor{gray} &  & \verb~418~ & & \verb~~\\
\cellcolor{gray} &  & \verb~419~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~420~ & & \verb~        /// Creates time in game~\\
\cellcolor{gray} &  & \verb~421~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 11 & \verb~422~ & & \verb~        public void HandleTime() {~\\
\cellcolor{green} & 15 & \verb~423~ & & \verb~            if (hasTime) {~\\
\cellcolor{green} & 4 & \verb~424~ & & \verb~                currentTime = StaticTimer.GetElapsedSeconds();~\\
\cellcolor{green} & 4 & \verb~425~ & & \verb~                timeLeft = Convert.ToInt32(startTime-currentTime);~\\
\cellcolor{green} & 4 & \verb~426~ & & \verb~                timeText = new Text(timeLeft.ToString(), new Vec2F(0.05f, 0.5f), new Vec2F(0.5f, 0.5f));~\\
\cellcolor{green} & 4 & \verb~427~ & & \verb~                timeText.SetColor(new Vec3I(255,0,0));~\\
\cellcolor{green} & 11 & \verb~428~ & & \verb~            } else {~\\
\cellcolor{green} & 7 & \verb~429~ & & \verb~                timeText = new Text("", new Vec2F(0.05f, 0.5f), new Vec2F(0.5f, 0.5f));~\\
\cellcolor{green} & 7 & \verb~430~ & & \verb~                timeText.SetColor(new Vec3I(255,0,0));~\\
\cellcolor{green} & 7 & \verb~431~ & & \verb~            }~\\
\cellcolor{green} & 11 & \verb~432~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~433~ & & \verb~~\\
\cellcolor{gray} &  & \verb~434~ & & \verb~~\\
\cellcolor{gray} &  & \verb~435~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~436~ & & \verb~        /// Returns player for testing~\\
\cellcolor{gray} &  & \verb~437~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~438~ & & \verb~        /// <returns> Returns a player </returns>~\\
\cellcolor{green} & 7 & \verb~439~ & & \verb~        public Player GetPlayer() {~\\
\cellcolor{green} & 7 & \verb~440~ & & \verb~            return player;~\\
\cellcolor{green} & 7 & \verb~441~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~442~ & & \verb~~\\
\cellcolor{gray} &  & \verb~443~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~444~ & & \verb~        /// Returns LevelLoader for testing~\\
\cellcolor{gray} &  & \verb~445~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~446~ & & \verb~        /// <returns> Returns a player </returns>~\\
\cellcolor{green} & 1 & \verb~447~ & & \verb~        public LevelLoader GetLevelLoader() {~\\
\cellcolor{green} & 1 & \verb~448~ & & \verb~            return levelLoader;~\\
\cellcolor{green} & 1 & \verb~449~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~450~ & & \verb~~\\
\cellcolor{gray} &  & \verb~451~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~452~ & & \verb~        /// Returns points for testing~\\
\cellcolor{gray} &  & \verb~453~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~454~ & & \verb~        /// <returns> Returns a player </returns>~\\
\cellcolor{green} & 1 & \verb~455~ & & \verb~        public Points GetPointsField() {~\\
\cellcolor{green} & 1 & \verb~456~ & & \verb~            return points;~\\
\cellcolor{green} & 1 & \verb~457~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~458~ & & \verb~~\\
\cellcolor{gray} &  & \verb~459~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~460~ & & \verb~        /// Makes RemoveDeletedEntities able for testing~\\
\cellcolor{gray} &  & \verb~461~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 4 & \verb~462~ & & \verb~        public void CallRemoveDeletedEntities() {~\\
\cellcolor{green} & 4 & \verb~463~ & & \verb~            RemoveDeletedEntities();~\\
\cellcolor{green} & 4 & \verb~464~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~465~ & & \verb~~\\
\cellcolor{gray} &  & \verb~466~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~467~ & & \verb~        /// Makes level able for testing~\\
\cellcolor{gray} &  & \verb~468~ & & \verb~        /// /// </summary>~\\
\cellcolor{gray} &  & \verb~469~ & & \verb~        /// <returns> Returns an int </returns>~\\
\cellcolor{green} & 1 & \verb~470~ & & \verb~        public int GetLevel() {~\\
\cellcolor{green} & 1 & \verb~471~ & & \verb~            return level;~\\
\cellcolor{green} & 1 & \verb~472~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~473~ & & \verb~~\\
\cellcolor{gray} &  & \verb~474~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~475~ & & \verb~        /// Makes hasTime able for testing~\\
\cellcolor{gray} &  & \verb~476~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~477~ & & \verb~        /// <returns> Returns a bool </returns>~\\
\cellcolor{green} & 2 & \verb~478~ & & \verb~        public bool GetHasTime() {~\\
\cellcolor{green} & 2 & \verb~479~ & & \verb~            return hasTime;~\\
\cellcolor{green} & 2 & \verb~480~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~481~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~482~ & & \verb~}~\\
\end{longtable}
\newpage
\section{Breakout.BreakoutStates.GameWon}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Breakout.BreakoutStates.GameWon\\
\textbf{Assembly:} & Breakout\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/magnus/Desktop/SU/DIKUGames/Breakout/GameStates/GameWon.cs}\end{minipage} \\
\textbf{Covered lines:} & 69\\
\textbf{Uncovered lines:} & 23\\
\textbf{Coverable lines:} & 92\\
\textbf{Total lines:} & 169\\
\textbf{Line coverage:} & 75\% (69 of 92)\\
\textbf{Covered branches:} & 18\\
\textbf{Total branches:} & 20\\
\textbf{Branch coverage:} & 90\% (18 of 20)\\
\textbf{Covered methods:} & 6\\
\textbf{Total methods:} & 9\\
\textbf{Method coverage:} & 66.6\% (6 of 9)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{GetInstance()} & 100\% & 2 & 100\%\\
\hline
\textbf{InitializeGameState(} & 100\% & 1 & 100\%\\
\hline
\textbf{ResetState()} & 100\% & 1 & 100\%\\
\hline
\textbf{UpdateState()} & 100\% & 1 & 0\%\\
\hline
\textbf{RenderState()} & 0\% & 2 & 0\%\\
\hline
\textbf{HandleKeyEvent(...)} & 100\% & 2 & 83.33\%\\
\hline
\textbf{KeyPress(...)} & 100\% & 10 & 96.77\%\\
\hline
\textbf{ProcessEvent(...)} & 100\% & 4 & 100\%\\
\hline
\textbf{GetPoints()} & 100\% & 1 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/magnus/Desktop/SU/DIKUGames/Breakout/GameStates/GameWon.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Graphics;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.State;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using DIKUArcade.Input;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~using DIKUArcade.Math;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~using DIKUArcade.Events;~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~namespace Breakout.BreakoutStates {~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~    ///  This class represents the state that is active when the game has been won.~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~    public class GameWon : IGameState, IGameEventProcessor{~\\
\cellcolor{gray} &  & \verb~15~ & & \verb~~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~        private static GameWon instance = null;~\\
\cellcolor{gray} &  & \verb~17~ & & \verb~        private Text[] menuButtons;~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~        private Text NewGameText;~\\
\cellcolor{gray} &  & \verb~19~ & & \verb~        private Text QuitText;~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~        private Text wonGameText;~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~        public string SelectedButton;~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~        private Entity BackgroundImage;~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~        private StationaryShape shape;~\\
\cellcolor{gray} &  & \verb~24~ & & \verb~        private IBaseImage image;~\\
\cellcolor{gray} &  & \verb~25~ & & \verb~        public int points;~\\
\cellcolor{gray} &  & \verb~26~ & & \verb~        private Text pointsText;~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~~\\
\cellcolor{green} & 50 & \verb~28~ & & \verb~        public static GameWon GetInstance() {~\\
\cellcolor{green} & 51 & \verb~29~ & & \verb~            if (GameWon.instance == null) {~\\
\cellcolor{green} & 1 & \verb~30~ & & \verb~                GameWon.instance = new GameWon();~\\
\cellcolor{green} & 1 & \verb~31~ & & \verb~                GameWon.instance.InitializeGameState();~\\
\cellcolor{green} & 1 & \verb~32~ & & \verb~            }~\\
\cellcolor{green} & 50 & \verb~33~ & & \verb~            return GameWon.instance;~\\
\cellcolor{green} & 50 & \verb~34~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~35~ & & \verb~~\\
\cellcolor{gray} &  & \verb~36~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~37~ & & \verb~        /// Initializes the gamestate~\\
\cellcolor{gray} &  & \verb~38~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 1 & \verb~39~ & & \verb~        public void InitializeGameState() {~\\
\cellcolor{green} & 1 & \verb~40~ & & \verb~            wonGameText = new Text("YOU WON", new Vec2F(0.3f, 0.25f), new Vec2F(0.5f, 0.5f));~\\
\cellcolor{green} & 1 & \verb~41~ & & \verb~            wonGameText.SetColor(new Vec3I(0,255,0));~\\
\cellcolor{green} & 1 & \verb~42~ & & \verb~            NewGameText = new Text("Main Menu", new Vec2F(0.05f, 0.0f), new Vec2F(0.5f, 0.5f));~\\
\cellcolor{green} & 1 & \verb~43~ & & \verb~            NewGameText.SetColor(new Vec3I(255,255,255));~\\
\cellcolor{green} & 1 & \verb~44~ & & \verb~            QuitText = new Text("Quit Game", new Vec2F(0.05f, -0.1f), new Vec2F(0.5f,  0.5f));~\\
\cellcolor{green} & 1 & \verb~45~ & & \verb~            QuitText.SetColor(new Vec3I(255, 0, 0));~\\
\cellcolor{green} & 1 & \verb~46~ & & \verb~            menuButtons = new Text[] {NewGameText, QuitText};~\\
\cellcolor{green} & 1 & \verb~47~ & & \verb~            SelectedButton = "Main Menu";~\\
\cellcolor{green} & 1 & \verb~48~ & & \verb~            shape = new StationaryShape(new Vec2F(0.0f, 0.0f), new Vec2F(1.0f, 1.0f));~\\
\cellcolor{green} & 1 & \verb~49~ & & \verb~            image = new Image(Path.Combine("Assets", "Images", "shipit_titlescreen.png"));~\\
\cellcolor{green} & 1 & \verb~50~ & & \verb~            BackgroundImage = new Entity(shape, image);~\\
\cellcolor{green} & 1 & \verb~51~ & & \verb~            BreakoutBus.GetBus().Subscribe(GameEventType.ControlEvent, this);~\\
\cellcolor{green} & 1 & \verb~52~ & & \verb~            pointsText = new Text("Score: " + points.ToString(), new Vec2F(0.05f, 0.2f), new Vec2F(0.5f, 0.5f));~\\
\cellcolor{green} & 1 & \verb~53~ & & \verb~            pointsText.SetColor(new Vec3I(255,255,0));~\\
\cellcolor{green} & 1 & \verb~54~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~55~ & & \verb~~\\
\cellcolor{gray} &  & \verb~56~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~57~ & & \verb~        /// Resets the state~\\
\cellcolor{gray} &  & \verb~58~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 1 & \verb~59~ & & \verb~        public void ResetState() {~\\
\cellcolor{green} & 1 & \verb~60~ & & \verb~            points = 0;~\\
\cellcolor{green} & 1 & \verb~61~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~62~ & & \verb~~\\
\cellcolor{gray} &  & \verb~63~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~64~ & & \verb~        /// Updates the state~\\
\cellcolor{gray} &  & \verb~65~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~66~ & & \verb~        public void UpdateState() {~\\
\cellcolor{red} & 0 & \verb~67~ & & \verb~            GetPoints();~\\
\cellcolor{red} & 0 & \verb~68~ & & \verb~            pointsText = pointsText = new Text("Score: " + points.ToString(), new Vec2F(0.05f, 0.2f), new Vec2F(0.5f, 0.~\\
\cellcolor{red} & 0 & \verb~69~ & & \verb~            pointsText.SetColor(new Vec3I(255,255,0));~\\
\cellcolor{red} & 0 & \verb~70~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~71~ & & \verb~~\\
\cellcolor{gray} &  & \verb~72~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~73~ & & \verb~        /// Renders the state~\\
\cellcolor{gray} &  & \verb~74~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~75~ & & \verb~        public void RenderState() {~\\
\cellcolor{red} & 0 & \verb~76~ & & \verb~            BackgroundImage.RenderEntity();~\\
\cellcolor{red} & 0 & \verb~77~ & & \verb~            foreach (Text text in menuButtons) {~\\
\cellcolor{red} & 0 & \verb~78~ & & \verb~                text.RenderText();~\\
\cellcolor{red} & 0 & \verb~79~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~80~ & & \verb~            wonGameText.RenderText();~\\
\cellcolor{red} & 0 & \verb~81~ & & \verb~            pointsText.RenderText();~\\
\cellcolor{red} & 0 & \verb~82~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~83~ & & \verb~~\\
\cellcolor{gray} &  & \verb~84~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~85~ & & \verb~        /// handles key events~\\
\cellcolor{gray} &  & \verb~86~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~87~ & & \verb~        /// <param name="action">the actio nto handle</param>~\\
\cellcolor{gray} &  & \verb~88~ & & \verb~        /// <param name="key">the key pressed or released</param>~\\
\cellcolor{green} & 5 & \verb~89~ & & \verb~        public void HandleKeyEvent(KeyboardAction action, KeyboardKey key) {~\\
\cellcolor{green} & 5 & \verb~90~ & & \verb~            switch (action) {~\\
\cellcolor{gray} &  & \verb~91~ & & \verb~                case (KeyboardAction.KeyPress):~\\
\cellcolor{green} & 5 & \verb~92~ & & \verb~                    KeyPress(key);~\\
\cellcolor{green} & 5 & \verb~93~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~94~ & & \verb~                default:~\\
\cellcolor{red} & 0 & \verb~95~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~96~ & & \verb~            }~\\
\cellcolor{green} & 5 & \verb~97~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~98~ & & \verb~~\\
\cellcolor{gray} &  & \verb~99~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~100~ & & \verb~        /// calls SetMoveRight or SetMoveLeft accordinly to the pressed key~\\
\cellcolor{gray} &  & \verb~101~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~102~ & & \verb~        /// <param name="key">pressed key</param>~\\
\cellcolor{green} & 5 & \verb~103~ & & \verb~        private void KeyPress(KeyboardKey key) { // Initiating keypresses on given keys with switch~\\
\cellcolor{green} & 5 & \verb~104~ & & \verb~            switch (key) {~\\
\cellcolor{gray} &  & \verb~105~ & & \verb~                case KeyboardKey.Up:~\\
\cellcolor{green} & 2 & \verb~106~ & & \verb~                    SelectedButton = "Main Menu";~\\
\cellcolor{green} & 2 & \verb~107~ & & \verb~                    NewGameText.SetColor(new Vec3I(255,255,255));~\\
\cellcolor{green} & 2 & \verb~108~ & & \verb~                    QuitText.SetColor(new Vec3I(255, 0, 0));~\\
\cellcolor{green} & 2 & \verb~109~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~110~ & & \verb~                case KeyboardKey.Down:~\\
\cellcolor{green} & 1 & \verb~111~ & & \verb~                    SelectedButton = "Quit Game";~\\
\cellcolor{green} & 1 & \verb~112~ & & \verb~                    NewGameText.SetColor(new Vec3I(255, 0, 0));~\\
\cellcolor{green} & 1 & \verb~113~ & & \verb~                    QuitText.SetColor(new Vec3I(255, 255, 255)); // Starting movement on press~\\
\cellcolor{green} & 1 & \verb~114~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~115~ & & \verb~                case KeyboardKey.Enter:~\\
\cellcolor{green} & 3 & \verb~116~ & & \verb~                    if (SelectedButton == "Main Menu") {~\\
\cellcolor{green} & 1 & \verb~117~ & & \verb~                        ResetState();~\\
\cellcolor{green} & 1 & \verb~118~ & & \verb~                        BreakoutBus.GetBus().RegisterEvent(~\\
\cellcolor{green} & 1 & \verb~119~ & & \verb~                            new GameEvent{~\\
\cellcolor{green} & 1 & \verb~120~ & & \verb~                                EventType = GameEventType.GameStateEvent,~\\
\cellcolor{green} & 1 & \verb~121~ & & \verb~                                Message = "CHANGE_STATE",~\\
\cellcolor{green} & 1 & \verb~122~ & & \verb~                                StringArg1 = "MAIN_MENU"~\\
\cellcolor{green} & 1 & \verb~123~ & & \verb~                            }~\\
\cellcolor{green} & 1 & \verb~124~ & & \verb~                        );~\\
\cellcolor{green} & 1 & \verb~125~ & & \verb~                    }~\\
\cellcolor{green} & 2 & \verb~126~ & & \verb~                    else if (SelectedButton == "Quit Game") {~\\
\cellcolor{green} & 1 & \verb~127~ & & \verb~                        BreakoutBus.GetBus().RegisterEvent(~\\
\cellcolor{green} & 1 & \verb~128~ & & \verb~                            new GameEvent{~\\
\cellcolor{green} & 1 & \verb~129~ & & \verb~                                EventType = GameEventType.InputEvent,~\\
\cellcolor{green} & 1 & \verb~130~ & & \verb~                                Message = "escape"~\\
\cellcolor{green} & 1 & \verb~131~ & & \verb~                            }~\\
\cellcolor{green} & 1 & \verb~132~ & & \verb~                        );~\\
\cellcolor{green} & 1 & \verb~133~ & & \verb~                    }~\\
\cellcolor{green} & 2 & \verb~134~ & & \verb~                    break;~\\
\cellcolor{red} & 0 & \verb~135~ & & \verb~                default: break;~\\
\cellcolor{gray} &  & \verb~136~ & & \verb~            }~\\
\cellcolor{green} & 5 & \verb~137~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~138~ & & \verb~~\\
\cellcolor{gray} &  & \verb~139~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~140~ & & \verb~        /// Processes a single event~\\
\cellcolor{gray} &  & \verb~141~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~142~ & & \verb~        /// <param name="gameEvent">the event to process</param>~\\
\cellcolor{green} & 2 & \verb~143~ & & \verb~        public void ProcessEvent(GameEvent gameEvent){~\\
\cellcolor{green} & 4 & \verb~144~ & & \verb~            if (gameEvent.EventType == GameEventType.ControlEvent) { //Checks if it a InputEvent~\\
\cellcolor{green} & 2 & \verb~145~ & & \verb~                switch (gameEvent.Message) { //switches on message, only does something with~\\
\cellcolor{gray} &  & \verb~146~ & & \verb~                                             //KeyPress and KeyRelease~\\
\cellcolor{gray} &  & \verb~147~ & & \verb~                    case "WonLostPoints":~\\
\cellcolor{green} & 1 & \verb~148~ & & \verb~                        points = gameEvent.IntArg1;~\\
\cellcolor{green} & 1 & \verb~149~ & & \verb~                        break;~\\
\cellcolor{gray} &  & \verb~150~ & & \verb~                    default:~\\
\cellcolor{green} & 1 & \verb~151~ & & \verb~                        break;~\\
\cellcolor{gray} &  & \verb~152~ & & \verb~                }~\\
\cellcolor{green} & 2 & \verb~153~ & & \verb~            }~\\
\cellcolor{green} & 2 & \verb~154~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~155~ & & \verb~~\\
\cellcolor{gray} &  & \verb~156~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~157~ & & \verb~        /// Creates an event that is caught in Game~\\
\cellcolor{gray} &  & \verb~158~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~159~ & & \verb~        private void GetPoints(){~\\
\cellcolor{red} & 0 & \verb~160~ & & \verb~            BreakoutBus.GetBus().RegisterEvent(~\\
\cellcolor{red} & 0 & \verb~161~ & & \verb~                            new GameEvent{~\\
\cellcolor{red} & 0 & \verb~162~ & & \verb~                                EventType = GameEventType.ControlEvent,~\\
\cellcolor{red} & 0 & \verb~163~ & & \verb~                                Message = "GetPoints",~\\
\cellcolor{red} & 0 & \verb~164~ & & \verb~                            }~\\
\cellcolor{red} & 0 & \verb~165~ & & \verb~                        );~\\
\cellcolor{red} & 0 & \verb~166~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~167~ & & \verb~~\\
\cellcolor{gray} &  & \verb~168~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~169~ & & \verb~}~\\
\end{longtable}
\newpage
\section{Breakout.BreakoutStates.MainMenu}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Breakout.BreakoutStates.MainMenu\\
\textbf{Assembly:} & Breakout\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/magnus/Desktop/SU/DIKUGames/Breakout/GameStates/MainMenu.cs}\end{minipage} \\
\textbf{Covered lines:} & 52\\
\textbf{Uncovered lines:} & 12\\
\textbf{Coverable lines:} & 64\\
\textbf{Total lines:} & 124\\
\textbf{Line coverage:} & 81.2\% (52 of 64)\\
\textbf{Covered branches:} & 14\\
\textbf{Total branches:} & 16\\
\textbf{Branch coverage:} & 87.5\% (14 of 16)\\
\textbf{Covered methods:} & 4\\
\textbf{Total methods:} & 7\\
\textbf{Method coverage:} & 57.1\% (4 of 7)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{GetInstance()} & 100\% & 2 & 100\%\\
\hline
\textbf{InitializeGameState(} & 100\% & 1 & 100\%\\
\hline
\textbf{ResetState()} & 100\% & 1 & 0\%\\
\hline
\textbf{UpdateState()} & 100\% & 1 & 0\%\\
\hline
\textbf{RenderState()} & 0\% & 2 & 0\%\\
\hline
\textbf{HandleKeyEvent(...)} & 100\% & 2 & 83.33\%\\
\hline
\textbf{KeyPress(...)} & 100\% & 10 & 96.66\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/magnus/Desktop/SU/DIKUGames/Breakout/GameStates/MainMenu.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Graphics;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.State;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using DIKUArcade.Input;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~using DIKUArcade.Math;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~using DIKUArcade.Events;~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~namespace Breakout.BreakoutStates {~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~    ///  This class represents the state that is active when in the mainmenu.~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~    public class MainMenu : IGameState {~\\
\cellcolor{gray} &  & \verb~15~ & & \verb~~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~        private static MainMenu instance = null;~\\
\cellcolor{gray} &  & \verb~17~ & & \verb~        private Text[] menuButtons;~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~        private Text NewGameText;~\\
\cellcolor{gray} &  & \verb~19~ & & \verb~        private Text QuitText;~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~        public string SelectedButton;~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~        private Entity BackgroundImage;~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~        private StationaryShape shape;~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~        private IBaseImage image;~\\
\cellcolor{gray} &  & \verb~24~ & & \verb~~\\
\cellcolor{green} & 43 & \verb~25~ & & \verb~        public static MainMenu GetInstance() {~\\
\cellcolor{green} & 44 & \verb~26~ & & \verb~            if (MainMenu.instance == null) {~\\
\cellcolor{green} & 1 & \verb~27~ & & \verb~                MainMenu.instance = new MainMenu();~\\
\cellcolor{green} & 1 & \verb~28~ & & \verb~                MainMenu.instance.InitializeGameState();~\\
\cellcolor{green} & 1 & \verb~29~ & & \verb~            }~\\
\cellcolor{green} & 43 & \verb~30~ & & \verb~            return MainMenu.instance;~\\
\cellcolor{green} & 43 & \verb~31~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~32~ & & \verb~~\\
\cellcolor{gray} &  & \verb~33~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~34~ & & \verb~        /// Initializes the gamestate~\\
\cellcolor{gray} &  & \verb~35~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 1 & \verb~36~ & & \verb~        public void InitializeGameState() {~\\
\cellcolor{green} & 1 & \verb~37~ & & \verb~            NewGameText = new Text("New Game", new Vec2F(0.05f, 0.2f), new Vec2F(0.5f, 0.5f));~\\
\cellcolor{green} & 1 & \verb~38~ & & \verb~            NewGameText.SetColor(new Vec3I(255,255,255));~\\
\cellcolor{green} & 1 & \verb~39~ & & \verb~            QuitText = new Text("Quit Game", new Vec2F(0.05f, 0.05f), new Vec2F(0.5f,  0.5f));~\\
\cellcolor{green} & 1 & \verb~40~ & & \verb~            QuitText.SetColor(new Vec3I(255, 0, 0));~\\
\cellcolor{green} & 1 & \verb~41~ & & \verb~            menuButtons = new Text[] {NewGameText, QuitText};~\\
\cellcolor{green} & 1 & \verb~42~ & & \verb~            SelectedButton = "New Game";~\\
\cellcolor{green} & 1 & \verb~43~ & & \verb~            shape = new StationaryShape(new Vec2F(0.0f, 0.0f), new Vec2F(1.0f, 1.0f));~\\
\cellcolor{green} & 1 & \verb~44~ & & \verb~            image = new Image(Path.Combine("Assets", "Images", "shipit_titlescreen.png"));~\\
\cellcolor{green} & 1 & \verb~45~ & & \verb~            BackgroundImage = new Entity(shape, image);~\\
\cellcolor{green} & 1 & \verb~46~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~47~ & & \verb~~\\
\cellcolor{gray} &  & \verb~48~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~49~ & & \verb~        /// Resets the state~\\
\cellcolor{gray} &  & \verb~50~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~51~ & & \verb~        public void ResetState() {~\\
\cellcolor{red} & 0 & \verb~52~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~53~ & & \verb~~\\
\cellcolor{gray} &  & \verb~54~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~55~ & & \verb~        /// Updates the state~\\
\cellcolor{gray} &  & \verb~56~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~57~ & & \verb~        public void UpdateState() {~\\
\cellcolor{red} & 0 & \verb~58~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~59~ & & \verb~~\\
\cellcolor{gray} &  & \verb~60~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~61~ & & \verb~        /// Renders the state~\\
\cellcolor{gray} &  & \verb~62~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~63~ & & \verb~        public void RenderState() {~\\
\cellcolor{red} & 0 & \verb~64~ & & \verb~            BackgroundImage.RenderEntity();~\\
\cellcolor{red} & 0 & \verb~65~ & & \verb~            foreach (Text text in menuButtons) {~\\
\cellcolor{red} & 0 & \verb~66~ & & \verb~                text.RenderText();~\\
\cellcolor{red} & 0 & \verb~67~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~68~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~69~ & & \verb~~\\
\cellcolor{gray} &  & \verb~70~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~71~ & & \verb~        /// handles key events~\\
\cellcolor{gray} &  & \verb~72~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~73~ & & \verb~        /// <param name="action">the actio nto handle</param>~\\
\cellcolor{gray} &  & \verb~74~ & & \verb~        /// <param name="key">the key pressed or released</param>~\\
\cellcolor{green} & 5 & \verb~75~ & & \verb~        public void HandleKeyEvent(KeyboardAction action, KeyboardKey key) {~\\
\cellcolor{green} & 5 & \verb~76~ & & \verb~            switch (action) {~\\
\cellcolor{gray} &  & \verb~77~ & & \verb~                case (KeyboardAction.KeyPress):~\\
\cellcolor{green} & 5 & \verb~78~ & & \verb~                    KeyPress(key);~\\
\cellcolor{green} & 5 & \verb~79~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~80~ & & \verb~                default:~\\
\cellcolor{red} & 0 & \verb~81~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~82~ & & \verb~            }~\\
\cellcolor{green} & 5 & \verb~83~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~84~ & & \verb~~\\
\cellcolor{gray} &  & \verb~85~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~86~ & & \verb~        /// calls SetMoveRight or SetMoveLeft accordinly to the pressed key~\\
\cellcolor{gray} &  & \verb~87~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~88~ & & \verb~        /// <param name="key">pressed key</param>~\\
\cellcolor{green} & 5 & \verb~89~ & & \verb~        private void KeyPress(KeyboardKey key) { // Initiating keypresses on given keys with switch~\\
\cellcolor{green} & 5 & \verb~90~ & & \verb~            switch (key) {~\\
\cellcolor{gray} &  & \verb~91~ & & \verb~                case KeyboardKey.Up:~\\
\cellcolor{green} & 2 & \verb~92~ & & \verb~                    SelectedButton = "New Game";~\\
\cellcolor{green} & 2 & \verb~93~ & & \verb~                    NewGameText.SetColor(new Vec3I(255,255,255));~\\
\cellcolor{green} & 2 & \verb~94~ & & \verb~                    QuitText.SetColor(new Vec3I(255, 0, 0));~\\
\cellcolor{green} & 2 & \verb~95~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~96~ & & \verb~                case KeyboardKey.Down:~\\
\cellcolor{green} & 1 & \verb~97~ & & \verb~                    SelectedButton = "Quit Game";~\\
\cellcolor{green} & 1 & \verb~98~ & & \verb~                    NewGameText.SetColor(new Vec3I(255, 0, 0));~\\
\cellcolor{green} & 1 & \verb~99~ & & \verb~                    QuitText.SetColor(new Vec3I(255, 255, 255)); // Starting movement on press~\\
\cellcolor{green} & 1 & \verb~100~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~101~ & & \verb~                case KeyboardKey.Enter:~\\
\cellcolor{green} & 3 & \verb~102~ & & \verb~                    if (SelectedButton == "New Game") {~\\
\cellcolor{green} & 1 & \verb~103~ & & \verb~                        BreakoutBus.GetBus().RegisterEvent(~\\
\cellcolor{green} & 1 & \verb~104~ & & \verb~                            new GameEvent{~\\
\cellcolor{green} & 1 & \verb~105~ & & \verb~                                EventType = GameEventType.GameStateEvent,~\\
\cellcolor{green} & 1 & \verb~106~ & & \verb~                                Message = "CHANGE_STATE",~\\
\cellcolor{green} & 1 & \verb~107~ & & \verb~                                StringArg1 = "GAME_RUNNING"~\\
\cellcolor{green} & 1 & \verb~108~ & & \verb~                            }~\\
\cellcolor{green} & 1 & \verb~109~ & & \verb~                        );~\\
\cellcolor{green} & 1 & \verb~110~ & & \verb~                    }~\\
\cellcolor{green} & 2 & \verb~111~ & & \verb~                    else if (SelectedButton == "Quit Game") {~\\
\cellcolor{green} & 1 & \verb~112~ & & \verb~                        BreakoutBus.GetBus().RegisterEvent(~\\
\cellcolor{green} & 1 & \verb~113~ & & \verb~                            new GameEvent{~\\
\cellcolor{green} & 1 & \verb~114~ & & \verb~                                EventType = GameEventType.InputEvent,~\\
\cellcolor{green} & 1 & \verb~115~ & & \verb~                                Message = "escape"~\\
\cellcolor{green} & 1 & \verb~116~ & & \verb~                            }~\\
\cellcolor{green} & 1 & \verb~117~ & & \verb~                        );~\\
\cellcolor{green} & 1 & \verb~118~ & & \verb~                    }~\\
\cellcolor{green} & 2 & \verb~119~ & & \verb~                    break;~\\
\cellcolor{red} & 0 & \verb~120~ & & \verb~                default: break;~\\
\cellcolor{gray} &  & \verb~121~ & & \verb~            }~\\
\cellcolor{green} & 5 & \verb~122~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~123~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~124~ & & \verb~}~\\
\end{longtable}
\newpage
\section{Breakout.BreakoutStates.StateMachine}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Breakout.BreakoutStates.StateMachine\\
\textbf{Assembly:} & Breakout\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/magnus/Desktop/SU/DIKUGames/Breakout/GameStateMachinery/StateMachine.cs}\end{minipage} \\
\textbf{Covered lines:} & 49\\
\textbf{Uncovered lines:} & 0\\
\textbf{Coverable lines:} & 49\\
\textbf{Total lines:} & 87\\
\textbf{Line coverage:} & 100\% (49 of 49)\\
\textbf{Covered branches:} & 10\\
\textbf{Total branches:} & 10\\
\textbf{Branch coverage:} & 100\% (10 of 10)\\
\textbf{Covered methods:} & 7\\
\textbf{Total methods:} & 7\\
\textbf{Method coverage:} & 100\% (7 of 7)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{get\_ActiveState()} & 100\% & 1 & 100\%\\
\hline
\textbf{get\_gameStates()} & 100\% & 1 & 100\%\\
\hline
\textbf{get\_stateTypes()} & 100\% & 1 & 100\%\\
\hline
\textbf{.ctor()} & 100\% & 1 & 100\%\\
\hline
\textbf{SwitchState(...)} & 100\% & 4 & 100\%\\
\hline
\textbf{ProcessEvent(...)} & 100\% & 4 & 100\%\\
\hline
\textbf{FillStateTypeToBreak} & 100\% & 2 & 100\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/magnus/Desktop/SU/DIKUGames/Breakout/GameStateMachinery/StateMachine.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Events;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.State;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using DIKUArcade.Input;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~namespace Breakout.BreakoutStates {~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~    ///  This class represents handles swithcing bewteen states and containing the active state.~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~    public class StateMachine : IGameEventProcessor {~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~~\\
\cellcolor{green} & 31 & \verb~13~ & & \verb~        public IGameState ActiveState { get; private set; }~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~        private IDictionary<GameStateType, IGameState> stateDic;~\\
\cellcolor{green} & 96 & \verb~15~ & & \verb~        private List<IGameState> gameStates {get;}~\\
\cellcolor{green} & 160 & \verb~16~ & & \verb~        private List<GameStateType> stateTypes{get;}~\\
\cellcolor{gray} &  & \verb~17~ & & \verb~~\\
\cellcolor{green} & 32 & \verb~18~ & & \verb~        public StateMachine() {~\\
\cellcolor{green} & 16 & \verb~19~ & & \verb~            BreakoutBus.GetBus().Subscribe(GameEventType.GameStateEvent, this);~\\
\cellcolor{green} & 16 & \verb~20~ & & \verb~            BreakoutBus.GetBus().Subscribe(GameEventType.InputEvent, this);~\\
\cellcolor{green} & 16 & \verb~21~ & & \verb~            ActiveState = MainMenu.GetInstance();~\\
\cellcolor{green} & 16 & \verb~22~ & & \verb~            GameRunning.GetInstance();~\\
\cellcolor{green} & 16 & \verb~23~ & & \verb~            GamePaused.GetInstance();~\\
\cellcolor{green} & 16 & \verb~24~ & & \verb~            GameLost.GetInstance();~\\
\cellcolor{green} & 16 & \verb~25~ & & \verb~            GameWon.GetInstance();~\\
\cellcolor{gray} &  & \verb~26~ & & \verb~~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~            //Initializing the lists and Adding the states and IGameStates to lists~\\
\cellcolor{green} & 16 & \verb~28~ & & \verb~            gameStates = new List<IGameState>();~\\
\cellcolor{green} & 16 & \verb~29~ & & \verb~            stateTypes = new List<GameStateType>();~\\
\cellcolor{green} & 16 & \verb~30~ & & \verb~            stateDic = new Dictionary<GameStateType, IGameState>();~\\
\cellcolor{green} & 16 & \verb~31~ & & \verb~            gameStates.Add(MainMenu.GetInstance());~\\
\cellcolor{green} & 16 & \verb~32~ & & \verb~            gameStates.Add(GameRunning.GetInstance());~\\
\cellcolor{green} & 16 & \verb~33~ & & \verb~            gameStates.Add(GamePaused.GetInstance());~\\
\cellcolor{green} & 16 & \verb~34~ & & \verb~            gameStates.Add(GameLost.GetInstance());~\\
\cellcolor{green} & 16 & \verb~35~ & & \verb~            gameStates.Add(GameWon.GetInstance());~\\
\cellcolor{green} & 16 & \verb~36~ & & \verb~            stateTypes.Add(GameStateType.MainMenu);~\\
\cellcolor{green} & 16 & \verb~37~ & & \verb~            stateTypes.Add(GameStateType.GameRunning);~\\
\cellcolor{green} & 16 & \verb~38~ & & \verb~            stateTypes.Add(GameStateType.GamePaused);~\\
\cellcolor{green} & 16 & \verb~39~ & & \verb~            stateTypes.Add(GameStateType.GameLost);~\\
\cellcolor{green} & 16 & \verb~40~ & & \verb~            stateTypes.Add(GameStateType.GameWon);~\\
\cellcolor{gray} &  & \verb~41~ & & \verb~~\\
\cellcolor{gray} &  & \verb~42~ & & \verb~            //Initializing and Filling the dictionary~\\
\cellcolor{green} & 16 & \verb~43~ & & \verb~            stateDic = new Dictionary<GameStateType, IGameState>();~\\
\cellcolor{green} & 16 & \verb~44~ & & \verb~            FillStateTypeToBreakoutStatesDic();~\\
\cellcolor{green} & 16 & \verb~45~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~46~ & & \verb~~\\
\cellcolor{gray} &  & \verb~47~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~48~ & & \verb~        /// switches the state~\\
\cellcolor{gray} &  & \verb~49~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~50~ & & \verb~        /// <param name="stateType">the state to switch to</param>~\\
\cellcolor{green} & 3 & \verb~51~ & & \verb~        public void SwitchState(GameStateType stateType) {~\\
\cellcolor{green} & 54 & \verb~52~ & & \verb~            foreach(var elm in stateDic){~\\
\cellcolor{green} & 18 & \verb~53~ & & \verb~                if (elm.Key == stateType){~\\
\cellcolor{green} & 3 & \verb~54~ & & \verb~                    ActiveState = elm.Value;~\\
\cellcolor{green} & 3 & \verb~55~ & & \verb~                }~\\
\cellcolor{green} & 15 & \verb~56~ & & \verb~            }~\\
\cellcolor{green} & 3 & \verb~57~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~58~ & & \verb~~\\
\cellcolor{gray} &  & \verb~59~ & & \verb~~\\
\cellcolor{gray} &  & \verb~60~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~61~ & & \verb~        /// Processes an event~\\
\cellcolor{gray} &  & \verb~62~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~63~ & & \verb~        /// <param name="gameEvent">the event to process</param>~\\
\cellcolor{green} & 4 & \verb~64~ & & \verb~        public void ProcessEvent (GameEvent gameEvent) {~\\
\cellcolor{green} & 7 & \verb~65~ & & \verb~            if (gameEvent.EventType == GameEventType.GameStateEvent) {~\\
\cellcolor{green} & 3 & \verb~66~ & & \verb~                switch (gameEvent.Message) {~\\
\cellcolor{gray} &  & \verb~67~ & & \verb~                    case "CHANGE_STATE":~\\
\cellcolor{green} & 1 & \verb~68~ & & \verb~                        SwitchState(StateTransformer.TransformStringToState(gameEvent.StringArg1));~\\
\cellcolor{green} & 1 & \verb~69~ & & \verb~                        break;~\\
\cellcolor{gray} &  & \verb~70~ & & \verb~                    default:~\\
\cellcolor{green} & 2 & \verb~71~ & & \verb~                        break;~\\
\cellcolor{gray} &  & \verb~72~ & & \verb~                }~\\
\cellcolor{green} & 3 & \verb~73~ & & \verb~            }~\\
\cellcolor{green} & 4 & \verb~74~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~75~ & & \verb~~\\
\cellcolor{gray} &  & \verb~76~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~77~ & & \verb~        /// Fils the dictionary~\\
\cellcolor{gray} &  & \verb~78~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 16 & \verb~79~ & & \verb~        private void FillStateTypeToBreakoutStatesDic(){~\\
\cellcolor{green} & 16 & \verb~80~ & & \verb~            int i = 0;~\\
\cellcolor{green} & 288 & \verb~81~ & & \verb~            foreach (IGameState state in gameStates){~\\
\cellcolor{green} & 80 & \verb~82~ & & \verb~                stateDic.Add(stateTypes[i], state);~\\
\cellcolor{green} & 80 & \verb~83~ & & \verb~                i++;~\\
\cellcolor{green} & 80 & \verb~84~ & & \verb~            }~\\
\cellcolor{green} & 16 & \verb~85~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~86~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~87~ & & \verb~}~\\
\end{longtable}
\newpage
\section{Breakout.Game}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Breakout.Game\\
\textbf{Assembly:} & Breakout\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/magnus/Desktop/SU/DIKUGames/Breakout/Game.cs}\end{minipage} \\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 53\\
\textbf{Coverable lines:} & 53\\
\textbf{Total lines:} & 122\\
\textbf{Line coverage:} & 0\% (0 of 53)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 14\\
\textbf{Branch coverage:} & 0\% (0 of 14)\\
\textbf{Covered methods:} & 0\\
\textbf{Total methods:} & 7\\
\textbf{Method coverage:} & 0\% (0 of 7)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{KeyHandler(...)} & 0\% & 4 & 0\%\\
\hline
\textbf{Render()} & 100\% & 1 & 0\%\\
\hline
\textbf{Update()} & 100\% & 1 & 0\%\\
\hline
\textbf{KeyPress(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{KeyRelease(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{ProcessEvent(...)} & 0\% & 10 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/magnus/Desktop/SU/DIKUGames/Breakout/Game.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.GUI;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using DIKUArcade.Input;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~using DIKUArcade.Events;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~using DIKUArcade.Math;~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~using DIKUArcade.Graphics;~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~using Breakout.BreakoutStates;~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~namespace Breakout {~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~~\\
\cellcolor{gray} &  & \verb~15~ & & \verb~~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~    public class Game : DIKUGame, IGameEventProcessor {~\\
\cellcolor{gray} &  & \verb~17~ & & \verb~~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~        private StateMachine state;~\\
\cellcolor{gray} &  & \verb~19~ & & \verb~        private int points;~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~21~ & & \verb~        public Game(WindowArgs windowArgs) : base(windowArgs) {~\\
\cellcolor{red} & 0 & \verb~22~ & & \verb~            BreakoutBus.GetBus().InitializeEventBus(new List<GameEventType> {~\\
\cellcolor{red} & 0 & \verb~23~ & & \verb~                 GameEventType.InputEvent,~\\
\cellcolor{red} & 0 & \verb~24~ & & \verb~            GameEventType.PlayerEvent, GameEventType.GameStateEvent,~\\
\cellcolor{red} & 0 & \verb~25~ & & \verb~            GameEventType.GraphicsEvent, GameEventType.StatusEvent, GameEventType.ControlEvent});~\\
\cellcolor{red} & 0 & \verb~26~ & & \verb~            BreakoutBus.GetBus().Subscribe(GameEventType.InputEvent, this);~\\
\cellcolor{red} & 0 & \verb~27~ & & \verb~            BreakoutBus.GetBus().Subscribe(GameEventType.ControlEvent, this);~\\
\cellcolor{red} & 0 & \verb~28~ & & \verb~            window.SetKeyEventHandler(KeyHandler);~\\
\cellcolor{red} & 0 & \verb~29~ & & \verb~            state = new StateMachine();~\\
\cellcolor{red} & 0 & \verb~30~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~31~ & & \verb~~\\
\cellcolor{gray} &  & \verb~32~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~33~ & & \verb~        /// Handles KeyboardActions and KeyboardKeys~\\
\cellcolor{gray} &  & \verb~34~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~35~ & & \verb~        /// <param name="action">A KeyBoardAction</param>~\\
\cellcolor{gray} &  & \verb~36~ & & \verb~        /// <param name="key">A KeyBoardKey</param>~\\
\cellcolor{red} & 0 & \verb~37~ & & \verb~        private void KeyHandler(KeyboardAction action, KeyboardKey key) {~\\
\cellcolor{red} & 0 & \verb~38~ & & \verb~            switch (action) {~\\
\cellcolor{gray} &  & \verb~39~ & & \verb~                case KeyboardAction.KeyPress:~\\
\cellcolor{red} & 0 & \verb~40~ & & \verb~                    KeyPress(key);~\\
\cellcolor{red} & 0 & \verb~41~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~42~ & & \verb~                case KeyboardAction.KeyRelease:~\\
\cellcolor{red} & 0 & \verb~43~ & & \verb~                    KeyRelease(key);~\\
\cellcolor{red} & 0 & \verb~44~ & & \verb~                    break;~\\
\cellcolor{red} & 0 & \verb~45~ & & \verb~                default: break;~\\
\cellcolor{gray} &  & \verb~46~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~47~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~48~ & & \verb~~\\
\cellcolor{gray} &  & \verb~49~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~50~ & & \verb~        /// Renders everything~\\
\cellcolor{gray} &  & \verb~51~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~52~ & & \verb~        public override void Render() {~\\
\cellcolor{red} & 0 & \verb~53~ & & \verb~            state.ActiveState.RenderState();~\\
\cellcolor{red} & 0 & \verb~54~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~55~ & & \verb~~\\
\cellcolor{gray} &  & \verb~56~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~57~ & & \verb~        /// Updates everything~\\
\cellcolor{gray} &  & \verb~58~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~59~ & & \verb~        public override void Update() {~\\
\cellcolor{red} & 0 & \verb~60~ & & \verb~            state.ActiveState.UpdateState();~\\
\cellcolor{red} & 0 & \verb~61~ & & \verb~            BreakoutBus.GetBus().ProcessEventsSequentially();~\\
\cellcolor{red} & 0 & \verb~62~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~63~ & & \verb~~\\
\cellcolor{gray} &  & \verb~64~ & & \verb~~\\
\cellcolor{gray} &  & \verb~65~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~66~ & & \verb~        /// Sends out the appropriate EventType for the KeyBoardKey pressed.~\\
\cellcolor{gray} &  & \verb~67~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~68~ & & \verb~        /// <param name="key">The pressed key</param>~\\
\cellcolor{red} & 0 & \verb~69~ & & \verb~        private void KeyPress(KeyboardKey key) { // Initiating keypresses on given keys with switch~\\
\cellcolor{red} & 0 & \verb~70~ & & \verb~            state.ActiveState.HandleKeyEvent(KeyboardAction.KeyPress, key);~\\
\cellcolor{red} & 0 & \verb~71~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~72~ & & \verb~~\\
\cellcolor{gray} &  & \verb~73~ & & \verb~~\\
\cellcolor{gray} &  & \verb~74~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~75~ & & \verb~        /// Sends out the appropriate EventType for the KeyBoardKey released.~\\
\cellcolor{gray} &  & \verb~76~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~77~ & & \verb~        /// <param name="key">The released key</param>~\\
\cellcolor{red} & 0 & \verb~78~ & & \verb~        private void KeyRelease(KeyboardKey key) {~\\
\cellcolor{red} & 0 & \verb~79~ & & \verb~            state.ActiveState.HandleKeyEvent(KeyboardAction.KeyRelease, key);~\\
\cellcolor{red} & 0 & \verb~80~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~81~ & & \verb~~\\
\cellcolor{gray} &  & \verb~82~ & & \verb~~\\
\cellcolor{gray} &  & \verb~83~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~84~ & & \verb~        /// Processes all events in the bus and responds accordingly.~\\
\cellcolor{gray} &  & \verb~85~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~86~ & & \verb~        /// <param name="gameEvent">the gamEvent to process</param>~\\
\cellcolor{red} & 0 & \verb~87~ & & \verb~        public void ProcessEvent(GameEvent gameEvent) {~\\
\cellcolor{red} & 0 & \verb~88~ & & \verb~            if (gameEvent.EventType == GameEventType.InputEvent) { //Checks if it a InputEvent~\\
\cellcolor{red} & 0 & \verb~89~ & & \verb~                switch (gameEvent.Message) { //switches on message, only does something with~\\
\cellcolor{gray} &  & \verb~90~ & & \verb~                                             //KeyPress and KeyRelease~\\
\cellcolor{gray} &  & \verb~91~ & & \verb~                    case "escape":~\\
\cellcolor{red} & 0 & \verb~92~ & & \verb~                        window.CloseWindow();~\\
\cellcolor{red} & 0 & \verb~93~ & & \verb~                        break;~\\
\cellcolor{gray} &  & \verb~94~ & & \verb~                    default:~\\
\cellcolor{red} & 0 & \verb~95~ & & \verb~                        break;~\\
\cellcolor{gray} &  & \verb~96~ & & \verb~                }~\\
\cellcolor{red} & 0 & \verb~97~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~98~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~99~ & & \verb~            if (gameEvent.EventType == GameEventType.ControlEvent) { //Checks if it a InputEvent~\\
\cellcolor{red} & 0 & \verb~100~ & & \verb~                switch (gameEvent.Message) { //switches on message, only does something with~\\
\cellcolor{gray} &  & \verb~101~ & & \verb~                                             //KeyPress and KeyRelease~\\
\cellcolor{gray} &  & \verb~102~ & & \verb~                    case "GamePoints":~\\
\cellcolor{red} & 0 & \verb~103~ & & \verb~                        points = gameEvent.IntArg1;~\\
\cellcolor{red} & 0 & \verb~104~ & & \verb~                        break;~\\
\cellcolor{gray} &  & \verb~105~ & & \verb~                    case "GetPoints":~\\
\cellcolor{red} & 0 & \verb~106~ & & \verb~                        BreakoutBus.GetBus().RegisterEvent(~\\
\cellcolor{red} & 0 & \verb~107~ & & \verb~                            new GameEvent{~\\
\cellcolor{red} & 0 & \verb~108~ & & \verb~                                EventType = GameEventType.ControlEvent,~\\
\cellcolor{red} & 0 & \verb~109~ & & \verb~                                Message = "WonLostPoints",~\\
\cellcolor{red} & 0 & \verb~110~ & & \verb~                                IntArg1 = points~\\
\cellcolor{red} & 0 & \verb~111~ & & \verb~                            }~\\
\cellcolor{red} & 0 & \verb~112~ & & \verb~                        );~\\
\cellcolor{red} & 0 & \verb~113~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~114~ & & \verb~                    default:~\\
\cellcolor{red} & 0 & \verb~115~ & & \verb~                        break;~\\
\cellcolor{gray} &  & \verb~116~ & & \verb~                }~\\
\cellcolor{red} & 0 & \verb~117~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~118~ & & \verb~~\\
\cellcolor{gray} &  & \verb~119~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~120~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~121~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~122~ & & \verb~}~\\
\end{longtable}
\newpage
\section{Breakout.HardenedBlock}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Breakout.HardenedBlock\\
\textbf{Assembly:} & Breakout\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/magnus/Desktop/SU/DIKUGames/Breakout/Blocks/HardenedBlock.cs}\end{minipage} \\
\textbf{Covered lines:} & 33\\
\textbf{Uncovered lines:} & 9\\
\textbf{Coverable lines:} & 42\\
\textbf{Total lines:} & 99\\
\textbf{Line coverage:} & 78.5\% (33 of 42)\\
\textbf{Covered branches:} & 7\\
\textbf{Total branches:} & 8\\
\textbf{Branch coverage:} & 87.5\% (7 of 8)\\
\textbf{Covered methods:} & 6\\
\textbf{Total methods:} & 9\\
\textbf{Method coverage:} & 66.6\% (6 of 9)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 100\%\\
\hline
\textbf{GetHealth()} & 100\% & 1 & 100\%\\
\hline
\textbf{DecHealth()} & 100\% & 4 & 100\%\\
\hline
\textbf{GetValue()} & 100\% & 1 & 0\%\\
\hline
\textbf{SetValue(...)} & 100\% & 1 & 100\%\\
\hline
\textbf{GetPosition()} & 100\% & 1 & 0\%\\
\hline
\textbf{ChangeImage()} & 100\% & 1 & 100\%\\
\hline
\textbf{IsPowerUp()} & 100\% & 1 & 0\%\\
\hline
\textbf{ProcessEvent(...)} & 75.00\% & 4 & 100\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/magnus/Desktop/SU/DIKUGames/Breakout/Blocks/HardenedBlock.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.Graphics;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using DIKUArcade.Events;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~using DIKUArcade.Math;~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~namespace Breakout {~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~    ///  This class represents Hardened Blocks. Has two lives and changes picture.~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~    public class HardenedBlock : Block {~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~        private int health;~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~        private int value;~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~        private string Color;~\\
\cellcolor{gray} &  & \verb~15~ & & \verb~~\\
\cellcolor{green} & 18 & \verb~16~ & & \verb~        public HardenedBlock(Shape shape, IBaseImage image, string color) : base(shape, image) {~\\
\cellcolor{green} & 9 & \verb~17~ & & \verb~            Color = color;~\\
\cellcolor{green} & 9 & \verb~18~ & & \verb~            this.shape = shape;~\\
\cellcolor{green} & 9 & \verb~19~ & & \verb~            health = 2;~\\
\cellcolor{green} & 9 & \verb~20~ & & \verb~            value = 1;~\\
\cellcolor{green} & 9 & \verb~21~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~24~ & & \verb~        /// Returns the health field of the block~\\
\cellcolor{gray} &  & \verb~25~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~26~ & & \verb~        /// <returns>health</returns>~\\
\cellcolor{green} & 4 & \verb~27~ & & \verb~        public override int GetHealth() {~\\
\cellcolor{green} & 4 & \verb~28~ & & \verb~            return health;~\\
\cellcolor{green} & 4 & \verb~29~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~30~ & & \verb~~\\
\cellcolor{gray} &  & \verb~31~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~32~ & & \verb~        /// Decreases the healthfield by one, and changes the image if needed, and~\\
\cellcolor{gray} &  & \verb~33~ & & \verb~        /// crates a GameEvent if needed~\\
\cellcolor{gray} &  & \verb~34~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 6 & \verb~35~ & & \verb~        public override void DecHealth () {~\\
\cellcolor{green} & 6 & \verb~36~ & & \verb~            health--;~\\
\cellcolor{green} & 10 & \verb~37~ & & \verb~            if (health == 1) {~\\
\cellcolor{green} & 4 & \verb~38~ & & \verb~                ChangeImage();~\\
\cellcolor{green} & 4 & \verb~39~ & & \verb~            }~\\
\cellcolor{green} & 8 & \verb~40~ & & \verb~            if (health == 0){~\\
\cellcolor{green} & 2 & \verb~41~ & & \verb~                DeleteEntity();~\\
\cellcolor{green} & 2 & \verb~42~ & & \verb~                BreakoutBus.GetBus().RegisterEvent (new GameEvent {~\\
\cellcolor{green} & 2 & \verb~43~ & & \verb~                        EventType = GameEventType.GraphicsEvent, IntArg1 = 10,~\\
\cellcolor{green} & 2 & \verb~44~ & & \verb~                    });~\\
\cellcolor{green} & 2 & \verb~45~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~46~ & & \verb~~\\
\cellcolor{green} & 6 & \verb~47~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~48~ & & \verb~~\\
\cellcolor{gray} &  & \verb~49~ & & \verb~~\\
\cellcolor{gray} &  & \verb~50~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~51~ & & \verb~        /// Returns the block value~\\
\cellcolor{gray} &  & \verb~52~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~53~ & & \verb~        /// <returns></returns>~\\
\cellcolor{red} & 0 & \verb~54~ & & \verb~        public override int GetValue() {~\\
\cellcolor{red} & 0 & \verb~55~ & & \verb~            return value;~\\
\cellcolor{red} & 0 & \verb~56~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~57~ & & \verb~~\\
\cellcolor{gray} &  & \verb~58~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~59~ & & \verb~        /// Sets the valu to the amount~\\
\cellcolor{gray} &  & \verb~60~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~61~ & & \verb~        /// <param name="amount">what to set value to</param>~\\
\cellcolor{green} & 2 & \verb~62~ & & \verb~        public override void SetValue(int amount) {~\\
\cellcolor{green} & 2 & \verb~63~ & & \verb~            value = amount;~\\
\cellcolor{green} & 2 & \verb~64~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~65~ & & \verb~~\\
\cellcolor{gray} &  & \verb~66~ & & \verb~~\\
\cellcolor{gray} &  & \verb~67~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~68~ & & \verb~        /// Returns the positon of the shape of the block~\\
\cellcolor{gray} &  & \verb~69~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~70~ & & \verb~        /// <returns></returns>~\\
\cellcolor{red} & 0 & \verb~71~ & & \verb~        public override Vec2F GetPosition() {~\\
\cellcolor{red} & 0 & \verb~72~ & & \verb~            return shape.Position;~\\
\cellcolor{red} & 0 & \verb~73~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~74~ & & \verb~~\\
\cellcolor{gray} &  & \verb~75~ & & \verb~~\\
\cellcolor{gray} &  & \verb~76~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~77~ & & \verb~        /// changes the image to the damaged version~\\
\cellcolor{gray} &  & \verb~78~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 4 & \verb~79~ & & \verb~        public void ChangeImage() {~\\
\cellcolor{green} & 4 & \verb~80~ & & \verb~            Color = Color + "-block-damaged.png";~\\
\cellcolor{green} & 4 & \verb~81~ & & \verb~            Image = new Image(Path.Combine("Assets","Images", Color));~\\
\cellcolor{green} & 4 & \verb~82~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~83~ & & \verb~~\\
\cellcolor{gray} &  & \verb~84~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~85~ & & \verb~        public override bool IsPowerUp() {~\\
\cellcolor{red} & 0 & \verb~86~ & & \verb~            return false;~\\
\cellcolor{red} & 0 & \verb~87~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~88~ & & \verb~~\\
\cellcolor{gray} &  & \verb~89~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~90~ & & \verb~        /// processes a gameEvent~\\
\cellcolor{gray} &  & \verb~91~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~92~ & & \verb~        /// <param name="gameEvent">the gameEvent to process</param>~\\
\cellcolor{green} & 7 & \verb~93~ & & \verb~        public override void ProcessEvent(GameEvent gameEvent){~\\
\cellcolor{orange} & 13 & \verb~94~ & & \verb~            if (gameEvent.EventType == GameEventType.InputEvent && gameEvent.IntArg1 == value) { //Checks if it a InputE~\\
\cellcolor{green} & 6 & \verb~95~ & & \verb~                DecHealth();~\\
\cellcolor{green} & 6 & \verb~96~ & & \verb~            }~\\
\cellcolor{green} & 7 & \verb~97~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~98~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~99~ & & \verb~}~\\
\end{longtable}
\newpage
\section{Breakout.LevelLoader}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Breakout.LevelLoader\\
\textbf{Assembly:} & Breakout\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/magnus/Desktop/SU/DIKUGames/Breakout/GameElements/LevelLoader.cs}\end{minipage} \\
\textbf{Covered lines:} & 169\\
\textbf{Uncovered lines:} & 4\\
\textbf{Coverable lines:} & 173\\
\textbf{Total lines:} & 293\\
\textbf{Line coverage:} & 97.6\% (169 of 173)\\
\textbf{Covered branches:} & 54\\
\textbf{Total branches:} & 54\\
\textbf{Branch coverage:} & 100\% (54 of 54)\\
\textbf{Covered methods:} & 17\\
\textbf{Total methods:} & 17\\
\textbf{Method coverage:} & 100\% (17 of 17)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{get\_map()} & 100\% & 1 & 100\%\\
\hline
\textbf{get\_meta()} & 100\% & 1 & 100\%\\
\hline
\textbf{get\_legend()} & 100\% & 1 & 100\%\\
\hline
\textbf{get\_Blocks()} & 100\% & 1 & 100\%\\
\hline
\textbf{.ctor()} & 100\% & 1 & 100\%\\
\hline
\textbf{ReadAscii(...)} & 100\% & 10 & 100\%\\
\hline
\textbf{AddBlocks()} & 100\% & 4 & 100\%\\
\hline
\textbf{AddMetaElement(...)} & 100\% & 22 & 100\%\\
\hline
\textbf{AddNormalBlock(...)} & 100\% & 4 & 100\%\\
\hline
\textbf{IsMeta(...)} & 100\% & 4 & 100\%\\
\hline
\textbf{IncXnY()} & 100\% & 2 & 100\%\\
\hline
\textbf{LoadLevel(...)} & 100\% & 1 & 100\%\\
\hline
\textbf{FillMetaDic()} & 100\% & 2 & 83.33\%\\
\hline
\textbf{FillLegendDics()} & 100\% & 2 & 83.33\%\\
\hline
\textbf{Reset()} & 100\% & 1 & 100\%\\
\hline
\textbf{OnlyUsedForTestingPr} & 100\% & 1 & 100\%\\
\hline
\textbf{AddTimer()} & 100\% & 4 & 100\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/magnus/Desktop/SU/DIKUGames/Breakout/GameElements/LevelLoader.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.GUI;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using System;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~using DIKUArcade.Events;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~using DIKUArcade.Math;~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~using DIKUArcade.Graphics;~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~namespace Breakout {~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~    ///  This class loads new levels from only an ascii-file.~\\
\cellcolor{gray} &  & \verb~15~ & & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~~\\
\cellcolor{gray} &  & \verb~17~ & & \verb~    public class LevelLoader {~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~~\\
\cellcolor{green} & 1837 & \verb~19~ & & \verb~        public List<char> map {get; private set;}~\\
\cellcolor{green} & 63 & \verb~20~ & & \verb~        public List<string> meta {get; private set;}~\\
\cellcolor{green} & 61 & \verb~21~ & & \verb~        public List<string> legend {get; private set;}~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~        private int x;~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~        private int y;~\\
\cellcolor{green} & 89 & \verb~24~ & & \verb~        private EntityContainer<Block> Blocks {get;}~\\
\cellcolor{gray} &  & \verb~25~ & & \verb~        private int currBlockValue;~\\
\cellcolor{gray} &  & \verb~26~ & & \verb~~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~        IDictionary<string, string> metaDic;~\\
\cellcolor{gray} &  & \verb~28~ & & \verb~        IDictionary<char, DIKUArcade.Graphics.Image> legendImageDic;~\\
\cellcolor{gray} &  & \verb~29~ & & \verb~        IDictionary<char, string> legendStringDic;~\\
\cellcolor{gray} &  & \verb~30~ & & \verb~~\\
\cellcolor{gray} &  & \verb~31~ & & \verb~~\\
\cellcolor{gray} &  & \verb~32~ & & \verb~~\\
\cellcolor{green} & 30 & \verb~33~ & & \verb~        public LevelLoader(){~\\
\cellcolor{green} & 15 & \verb~34~ & & \verb~            x = 0;~\\
\cellcolor{green} & 15 & \verb~35~ & & \verb~            y = 0;~\\
\cellcolor{green} & 15 & \verb~36~ & & \verb~            Blocks = new EntityContainer<Block>(288);~\\
\cellcolor{green} & 15 & \verb~37~ & & \verb~            map = new List<char>{};~\\
\cellcolor{green} & 15 & \verb~38~ & & \verb~            meta = new List<string>{};~\\
\cellcolor{green} & 15 & \verb~39~ & & \verb~            legend = new List<string>{};~\\
\cellcolor{green} & 15 & \verb~40~ & & \verb~            metaDic = new Dictionary<string,string>();~\\
\cellcolor{green} & 15 & \verb~41~ & & \verb~            legendImageDic = new Dictionary<char, DIKUArcade.Graphics.Image>();~\\
\cellcolor{green} & 15 & \verb~42~ & & \verb~            legendStringDic = new Dictionary<char, string>();~\\
\cellcolor{green} & 15 & \verb~43~ & & \verb~            currBlockValue = 0;~\\
\cellcolor{green} & 15 & \verb~44~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~45~ & & \verb~~\\
\cellcolor{gray} &  & \verb~46~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~47~ & & \verb~        /// Takes an ascii file and inserts it into three lists, map, meta and legends.~\\
\cellcolor{gray} &  & \verb~48~ & & \verb~        /// Only Takes Working Ascii Files, but handles FileNotFound.~\\
\cellcolor{gray} &  & \verb~49~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~50~ & & \verb~        /// <param name="filename">A string that is the name of an Ascii file</param>~\\
\cellcolor{green} & 18 & \verb~51~ & & \verb~        private void ReadAscii(string filename){~\\
\cellcolor{green} & 18 & \verb~52~ & & \verb~            string[] FileLines = System.IO.File.ReadAllLines(Path.Combine("Assets", "Levels", filename));~\\
\cellcolor{gray} &  & \verb~53~ & & \verb~~\\
\cellcolor{gray} &  & \verb~54~ & & \verb~                //Adding Map section to map~\\
\cellcolor{green} & 8 & \verb~55~ & & \verb~                int StartMapIndex = Array.IndexOf(FileLines, "Map:")+1;~\\
\cellcolor{green} & 8 & \verb~56~ & & \verb~                int EndMapIndex = Array.IndexOf(FileLines, "Map/")-1;~\\
\cellcolor{green} & 466 & \verb~57~ & & \verb~                for (int Enumerator = StartMapIndex; Enumerator <= EndMapIndex; Enumerator++){~\\
\cellcolor{green} & 5850 & \verb~58~ & & \verb~                    foreach(char elm  in FileLines[Enumerator]){~\\
\cellcolor{green} & 3600 & \verb~59~ & & \verb~                        if (elm != '/'){~\\
\cellcolor{green} & 1800 & \verb~60~ & & \verb~                            map.Add(elm);~\\
\cellcolor{green} & 1800 & \verb~61~ & & \verb~                        }~\\
\cellcolor{green} & 1800 & \verb~62~ & & \verb~                    }~\\
\cellcolor{green} & 150 & \verb~63~ & & \verb~                }~\\
\cellcolor{gray} &  & \verb~64~ & & \verb~~\\
\cellcolor{gray} &  & \verb~65~ & & \verb~                //Adding Meta section to Meta~\\
\cellcolor{green} & 8 & \verb~66~ & & \verb~                int StartMetaIndex = Array.IndexOf(FileLines, "Meta:")+1;~\\
\cellcolor{green} & 8 & \verb~67~ & & \verb~                int EndMetaIndex = Array.IndexOf(FileLines, "Meta/")-1;~\\
\cellcolor{green} & 94 & \verb~68~ & & \verb~                for (int Enumerator = StartMetaIndex; Enumerator <= EndMetaIndex; Enumerator++){~\\
\cellcolor{green} & 26 & \verb~69~ & & \verb~                        meta.Add(FileLines[Enumerator]);~\\
\cellcolor{green} & 26 & \verb~70~ & & \verb~                }~\\
\cellcolor{gray} &  & \verb~71~ & & \verb~~\\
\cellcolor{gray} &  & \verb~72~ & & \verb~                //Adding Legend section to legend~\\
\cellcolor{green} & 8 & \verb~73~ & & \verb~                int StartLegendIndex = Array.IndexOf(FileLines, "Legend:")+1;~\\
\cellcolor{green} & 8 & \verb~74~ & & \verb~                int EndLegendIndex = Array.IndexOf(FileLines, "Legend/")-1;~\\
\cellcolor{green} & 88 & \verb~75~ & & \verb~                for (int Enumerator = StartLegendIndex; Enumerator <= EndLegendIndex; Enumerator++){~\\
\cellcolor{green} & 24 & \verb~76~ & & \verb~                        legend.Add(FileLines[Enumerator]);~\\
\cellcolor{green} & 24 & \verb~77~ & & \verb~                }~\\
\cellcolor{green} & 8 & \verb~78~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~79~ & & \verb~~\\
\cellcolor{gray} &  & \verb~80~ & & \verb~~\\
\cellcolor{gray} &  & \verb~81~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~82~ & & \verb~        /// Adds blocks to the EntityContainer blocks, and handles meta data accordingly.~\\
\cellcolor{gray} &  & \verb~83~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 5 & \verb~84~ & & \verb~        private void AddBlocks(){~\\
\cellcolor{green} & 2715 & \verb~85~ & & \verb~            foreach (char charElm in map){~\\
\cellcolor{green} & 900 & \verb~86~ & & \verb~                currBlockValue++;~\\
\cellcolor{green} & 906 & \verb~87~ & & \verb~                if (IsMeta(charElm)) {~\\
\cellcolor{green} & 6 & \verb~88~ & & \verb~                    AddMetaElement(charElm);~\\
\cellcolor{green} & 900 & \verb~89~ & & \verb~                } else {~\\
\cellcolor{green} & 894 & \verb~90~ & & \verb~                    AddNormalBlock(charElm);~\\
\cellcolor{green} & 894 & \verb~91~ & & \verb~                }~\\
\cellcolor{green} & 900 & \verb~92~ & & \verb~                IncXnY();~\\
\cellcolor{green} & 900 & \verb~93~ & & \verb~            }~\\
\cellcolor{green} & 5 & \verb~94~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~95~ & & \verb~~\\
\cellcolor{gray} &  & \verb~96~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~97~ & & \verb~        /// Adds a metaelent~\\
\cellcolor{gray} &  & \verb~98~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~99~ & & \verb~        /// <param name="c">the char to decide what legend.key to use</param>~\\
\cellcolor{green} & 6 & \verb~100~ & & \verb~        private void AddMetaElement(char c) {~\\
\cellcolor{green} & 90 & \verb~101~ & & \verb~            foreach (var legendElm in legendStringDic){~\\
\cellcolor{green} & 432 & \verb~102~ & & \verb~                foreach(var metaElm in metaDic){~\\
\cellcolor{green} & 122 & \verb~103~ & & \verb~                    if (c == legendElm.Key && legendElm.Key.ToString() == metaElm.Value && metaElm.Key == "Hardened") {~\\
\cellcolor{gray} &  & \verb~104~ & & \verb~~\\
\cellcolor{green} & 2 & \verb~105~ & & \verb~                        string textPart = legendElm.Value.Substring(0, legendElm.Value.Length-10);~\\
\cellcolor{green} & 2 & \verb~106~ & & \verb~                        var newBlock = new HardenedBlock(~\\
\cellcolor{green} & 2 & \verb~107~ & & \verb~                            new DynamicShape(new Vec2F(~\\
\cellcolor{green} & 2 & \verb~108~ & & \verb~                                0.0f + x * 1.0f/12, 0.9f - y * (1.0f/12)/3f),~\\
\cellcolor{green} & 2 & \verb~109~ & & \verb~                            new Vec2F(1.0f/12, (1.0f/12)/3f)),~\\
\cellcolor{green} & 2 & \verb~110~ & & \verb~                            new Image(Path.Combine("Assets", "Images", legendElm.Value)),~\\
\cellcolor{green} & 2 & \verb~111~ & & \verb~                            textPart);~\\
\cellcolor{green} & 2 & \verb~112~ & & \verb~                        newBlock.SetValue(currBlockValue);~\\
\cellcolor{green} & 2 & \verb~113~ & & \verb~                        Blocks.AddEntity(newBlock);~\\
\cellcolor{green} & 2 & \verb~114~ & & \verb~                        BreakoutBus.GetBus().Subscribe(GameEventType.InputEvent, newBlock);~\\
\cellcolor{green} & 2 & \verb~115~ & & \verb~                    }~\\
\cellcolor{gray} &  & \verb~116~ & & \verb~~\\
\cellcolor{green} & 122 & \verb~117~ & & \verb~                    if (c == legendElm.Key && legendElm.Key.ToString() == metaElm.Value && metaElm.Key == "Unbreakable")~\\
\cellcolor{green} & 2 & \verb~118~ & & \verb~                        var newBlock = new UnbreakableBlock(~\\
\cellcolor{green} & 2 & \verb~119~ & & \verb~                            new DynamicShape(new Vec2F(~\\
\cellcolor{green} & 2 & \verb~120~ & & \verb~                                0.0f + x * 1.0f/12, 0.9f - y * (1.0f/12)/3f),~\\
\cellcolor{green} & 2 & \verb~121~ & & \verb~                            new Vec2F(1.0f/12, (1.0f/12)/3f)),~\\
\cellcolor{green} & 2 & \verb~122~ & & \verb~                            new Image(Path.Combine("Assets", "Images", legendElm.Value))~\\
\cellcolor{green} & 2 & \verb~123~ & & \verb~                            );~\\
\cellcolor{gray} &  & \verb~124~ & & \verb~~\\
\cellcolor{green} & 2 & \verb~125~ & & \verb~                        newBlock.SetValue(currBlockValue);~\\
\cellcolor{green} & 2 & \verb~126~ & & \verb~                        Blocks.AddEntity(newBlock);~\\
\cellcolor{green} & 2 & \verb~127~ & & \verb~                        BreakoutBus.GetBus().Subscribe(GameEventType.InputEvent, newBlock);~\\
\cellcolor{green} & 2 & \verb~128~ & & \verb~                    }~\\
\cellcolor{gray} &  & \verb~129~ & & \verb~~\\
\cellcolor{green} & 122 & \verb~130~ & & \verb~                    if (c == legendElm.Key && legendElm.Key.ToString() == metaElm.Value && metaElm.Key == "PowerUp") {~\\
\cellcolor{green} & 2 & \verb~131~ & & \verb~                        var newBlock = new PowerUpBlock(~\\
\cellcolor{green} & 2 & \verb~132~ & & \verb~                            new DynamicShape(new Vec2F(~\\
\cellcolor{green} & 2 & \verb~133~ & & \verb~                                0.0f + x * 1.0f/12, 0.9f - y * (1.0f/12)/3f),~\\
\cellcolor{green} & 2 & \verb~134~ & & \verb~                            new Vec2F(1.0f/12, (1.0f/12)/3f)),~\\
\cellcolor{green} & 2 & \verb~135~ & & \verb~                            new Image(Path.Combine("Assets", "Images", legendElm.Value))~\\
\cellcolor{green} & 2 & \verb~136~ & & \verb~                            );~\\
\cellcolor{gray} &  & \verb~137~ & & \verb~~\\
\cellcolor{green} & 2 & \verb~138~ & & \verb~                        newBlock.SetValue(currBlockValue);~\\
\cellcolor{green} & 2 & \verb~139~ & & \verb~                        Blocks.AddEntity(newBlock);~\\
\cellcolor{green} & 2 & \verb~140~ & & \verb~                        BreakoutBus.GetBus().Subscribe(GameEventType.InputEvent, newBlock);~\\
\cellcolor{green} & 2 & \verb~141~ & & \verb~                    }~\\
\cellcolor{green} & 120 & \verb~142~ & & \verb~                }~\\
\cellcolor{green} & 24 & \verb~143~ & & \verb~            }~\\
\cellcolor{green} & 6 & \verb~144~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~145~ & & \verb~~\\
\cellcolor{gray} &  & \verb~146~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~147~ & & \verb~        /// Adds the normal blocks~\\
\cellcolor{gray} &  & \verb~148~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~149~ & & \verb~        /// <param name="charElm">the char to chek with the LegegendImageDic elm.Key with.</param>~\\
\cellcolor{green} & 894 & \verb~150~ & & \verb~        private void AddNormalBlock(char charElm){~\\
\cellcolor{green} & 13410 & \verb~151~ & & \verb~            foreach (var elm in legendImageDic){~\\
\cellcolor{green} & 3654 & \verb~152~ & & \verb~                        if (charElm == elm.Key) {~\\
\cellcolor{green} & 78 & \verb~153~ & & \verb~                            var newBlock = new NormalBlock(~\\
\cellcolor{green} & 78 & \verb~154~ & & \verb~                                            new DynamicShape(new Vec2F(~\\
\cellcolor{green} & 78 & \verb~155~ & & \verb~                                                0.0f + x * 1.0f/12, 0.9f - y * (1.0f/12)/3f),~\\
\cellcolor{green} & 78 & \verb~156~ & & \verb~                                            new Vec2F(1.0f/12, (1.0f/12)/3f)),~\\
\cellcolor{green} & 78 & \verb~157~ & & \verb~                                            elm.Value);~\\
\cellcolor{green} & 78 & \verb~158~ & & \verb~                            newBlock.SetValue(currBlockValue);~\\
\cellcolor{green} & 78 & \verb~159~ & & \verb~                            Blocks.AddEntity(newBlock);~\\
\cellcolor{green} & 78 & \verb~160~ & & \verb~                            BreakoutBus.GetBus().Subscribe(GameEventType.InputEvent, newBlock);~\\
\cellcolor{green} & 78 & \verb~161~ & & \verb~                        }~\\
\cellcolor{green} & 3576 & \verb~162~ & & \verb~                    }~\\
\cellcolor{green} & 894 & \verb~163~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~164~ & & \verb~~\\
\cellcolor{gray} &  & \verb~165~ & & \verb~~\\
\cellcolor{gray} &  & \verb~166~ & & \verb~~\\
\cellcolor{gray} &  & \verb~167~ & & \verb~~\\
\cellcolor{gray} &  & \verb~168~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~169~ & & \verb~        /// Handles meta chars. Checks if a char is in the meta sections og the Ascii file.~\\
\cellcolor{gray} &  & \verb~170~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~171~ & & \verb~        /// <param name="c">A char</param>~\\
\cellcolor{gray} &  & \verb~172~ & & \verb~        /// <returns></returns>~\\
\cellcolor{green} & 900 & \verb~173~ & & \verb~        private bool IsMeta(char c){~\\
\cellcolor{green} & 15276 & \verb~174~ & & \verb~            foreach(var metaDicElm in metaDic){~\\
\cellcolor{green} & 4200 & \verb~175~ & & \verb~                if (c.ToString() == metaDicElm.Value){~\\
\cellcolor{green} & 6 & \verb~176~ & & \verb~                    return true;~\\
\cellcolor{gray} &  & \verb~177~ & & \verb~                }~\\
\cellcolor{green} & 4188 & \verb~178~ & & \verb~            }~\\
\cellcolor{green} & 894 & \verb~179~ & & \verb~            return false;~\\
\cellcolor{green} & 900 & \verb~180~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~181~ & & \verb~~\\
\cellcolor{gray} &  & \verb~182~ & & \verb~~\\
\cellcolor{gray} &  & \verb~183~ & & \verb~~\\
\cellcolor{gray} &  & \verb~184~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~185~ & & \verb~        /// increments x and if x is bigger than 12 it resets x to 0 and increments y.~\\
\cellcolor{gray} &  & \verb~186~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 900 & \verb~187~ & & \verb~        private void IncXnY(){~\\
\cellcolor{green} & 900 & \verb~188~ & & \verb~            x++;~\\
\cellcolor{green} & 975 & \verb~189~ & & \verb~            if (x == 12){~\\
\cellcolor{green} & 75 & \verb~190~ & & \verb~                y++;~\\
\cellcolor{green} & 75 & \verb~191~ & & \verb~                x=0;~\\
\cellcolor{green} & 75 & \verb~192~ & & \verb~            }~\\
\cellcolor{green} & 900 & \verb~193~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~194~ & & \verb~~\\
\cellcolor{gray} &  & \verb~195~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~196~ & & \verb~        /// Reads the specified Asciifile and calls the ReadAscii function on it, Adds the blocks~\\
\cellcolor{gray} &  & \verb~197~ & & \verb~        /// and returns an entitycontainer now woth blocks~\\
\cellcolor{gray} &  & \verb~198~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~199~ & & \verb~        /// <param name="filename">A string with the name of an Ascii file</param>~\\
\cellcolor{gray} &  & \verb~200~ & & \verb~        /// <returns></returns>~\\
\cellcolor{green} & 15 & \verb~201~ & & \verb~        public EntityContainer<Block> LoadLevel(string filename){~\\
\cellcolor{gray} &  & \verb~202~ & & \verb~~\\
\cellcolor{gray} &  & \verb~203~ & & \verb~            //clear the levelloader~\\
\cellcolor{green} & 15 & \verb~204~ & & \verb~            Reset();~\\
\cellcolor{gray} &  & \verb~205~ & & \verb~~\\
\cellcolor{gray} &  & \verb~206~ & & \verb~            //Read the ascii into lists, fill the dictionaries and add the blocks~\\
\cellcolor{green} & 15 & \verb~207~ & & \verb~            ReadAscii(filename);~\\
\cellcolor{green} & 5 & \verb~208~ & & \verb~            FillMetaDic();~\\
\cellcolor{green} & 5 & \verb~209~ & & \verb~            FillLegendDics();~\\
\cellcolor{green} & 5 & \verb~210~ & & \verb~            AddBlocks();~\\
\cellcolor{green} & 5 & \verb~211~ & & \verb~            AddTimer();~\\
\cellcolor{green} & 5 & \verb~212~ & & \verb~            return Blocks;~\\
\cellcolor{green} & 5 & \verb~213~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~214~ & & \verb~~\\
\cellcolor{gray} &  & \verb~215~ & & \verb~~\\
\cellcolor{gray} &  & \verb~216~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~217~ & & \verb~        /// Fills the metaDic~\\
\cellcolor{gray} &  & \verb~218~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 5 & \verb~219~ & & \verb~        private void FillMetaDic(){~\\
\cellcolor{green} & 57 & \verb~220~ & & \verb~            foreach (string elm in meta){~\\
\cellcolor{green} & 14 & \verb~221~ & & \verb~                int IndexOfSplit = elm.IndexOf(":");~\\
\cellcolor{green} & 14 & \verb~222~ & & \verb~                string key = elm.Substring(0, IndexOfSplit);~\\
\cellcolor{green} & 14 & \verb~223~ & & \verb~                string val = elm.Substring(IndexOfSplit+2, elm.Length-IndexOfSplit-2);~\\
\cellcolor{green} & 14 & \verb~224~ & & \verb~                try{~\\
\cellcolor{green} & 14 & \verb~225~ & & \verb~                    metaDic.Add(key, val);~\\
\cellcolor{green} & 14 & \verb~226~ & & \verb~                }~\\
\cellcolor{red} & 0 & \verb~227~ & & \verb~                catch{~\\
\cellcolor{red} & 0 & \verb~228~ & & \verb~                    Console.WriteLine("Duplicate key in meta");}~\\
\cellcolor{green} & 14 & \verb~229~ & & \verb~            }~\\
\cellcolor{green} & 5 & \verb~230~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~231~ & & \verb~~\\
\cellcolor{gray} &  & \verb~232~ & & \verb~~\\
\cellcolor{gray} &  & \verb~233~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~234~ & & \verb~        /// Fills the legend dics~\\
\cellcolor{gray} &  & \verb~235~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 5 & \verb~236~ & & \verb~        private void FillLegendDics(){~\\
\cellcolor{green} & 51 & \verb~237~ & & \verb~            foreach (string elm in legend){~\\
\cellcolor{green} & 12 & \verb~238~ & & \verb~                char key = elm[0];~\\
\cellcolor{green} & 12 & \verb~239~ & & \verb~                string val = elm.Substring(3, elm.Length-3);~\\
\cellcolor{green} & 12 & \verb~240~ & & \verb~                try{~\\
\cellcolor{green} & 12 & \verb~241~ & & \verb~                    legendImageDic.Add(key, new Image(Path.Combine("Assets", "Images", val)));~\\
\cellcolor{green} & 12 & \verb~242~ & & \verb~                    legendStringDic.Add(key, val);~\\
\cellcolor{green} & 12 & \verb~243~ & & \verb~                }~\\
\cellcolor{red} & 0 & \verb~244~ & & \verb~                catch{~\\
\cellcolor{red} & 0 & \verb~245~ & & \verb~                    Console.WriteLine("Duplicate key in legend");}~\\
\cellcolor{green} & 12 & \verb~246~ & & \verb~            }~\\
\cellcolor{green} & 5 & \verb~247~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~248~ & & \verb~~\\
\cellcolor{gray} &  & \verb~249~ & & \verb~~\\
\cellcolor{gray} &  & \verb~250~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~251~ & & \verb~        /// Resets the LevelLoader~\\
\cellcolor{gray} &  & \verb~252~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 15 & \verb~253~ & & \verb~        private void Reset(){~\\
\cellcolor{green} & 15 & \verb~254~ & & \verb~            map.Clear();~\\
\cellcolor{green} & 15 & \verb~255~ & & \verb~            meta.Clear();~\\
\cellcolor{green} & 15 & \verb~256~ & & \verb~            legend.Clear();~\\
\cellcolor{green} & 15 & \verb~257~ & & \verb~            metaDic.Clear();~\\
\cellcolor{green} & 15 & \verb~258~ & & \verb~            legendImageDic.Clear();~\\
\cellcolor{green} & 15 & \verb~259~ & & \verb~            legendStringDic.Clear();~\\
\cellcolor{green} & 15 & \verb~260~ & & \verb~            x = 0;~\\
\cellcolor{green} & 15 & \verb~261~ & & \verb~            y = 0;~\\
\cellcolor{gray} &  & \verb~262~ & & \verb~            //currBlockValue = 0;~\\
\cellcolor{green} & 15 & \verb~263~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~264~ & & \verb~~\\
\cellcolor{gray} &  & \verb~265~ & & \verb~~\\
\cellcolor{gray} &  & \verb~266~ & & \verb~~\\
\cellcolor{gray} &  & \verb~267~ & & \verb~~\\
\cellcolor{gray} &  & \verb~268~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~269~ & & \verb~        /// May only be used to test AsciiReader.~\\
\cellcolor{gray} &  & \verb~270~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~271~ & & \verb~        /// <param name="filename">The file to test AsciiReaderWith</param>~\\
\cellcolor{green} & 3 & \verb~272~ & & \verb~        public void OnlyUsedForTestingPrivateReadAscii(string filename){~\\
\cellcolor{green} & 3 & \verb~273~ & & \verb~            ReadAscii(filename);~\\
\cellcolor{green} & 3 & \verb~274~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~275~ & & \verb~~\\
\cellcolor{gray} &  & \verb~276~ & & \verb~~\\
\cellcolor{gray} &  & \verb~277~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~278~ & & \verb~        /// Adds a timer to the level if the meta segment specifies it, by creating an event.~\\
\cellcolor{gray} &  & \verb~279~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 5 & \verb~280~ & & \verb~        private void AddTimer(){~\\
\cellcolor{green} & 57 & \verb~281~ & & \verb~            foreach(var metaElm in metaDic){~\\
\cellcolor{green} & 17 & \verb~282~ & & \verb~                if (metaElm.Key == "Time"){~\\
\cellcolor{green} & 3 & \verb~283~ & & \verb~                    BreakoutBus.GetBus().RegisterEvent (new GameEvent {~\\
\cellcolor{green} & 3 & \verb~284~ & & \verb~                        EventType = GameEventType.StatusEvent, Message = "Time",~\\
\cellcolor{green} & 3 & \verb~285~ & & \verb~                        StringArg1 = metaElm.Value~\\
\cellcolor{green} & 3 & \verb~286~ & & \verb~                    });~\\
\cellcolor{green} & 3 & \verb~287~ & & \verb~                }~\\
\cellcolor{gray} &  & \verb~288~ & & \verb~~\\
\cellcolor{green} & 14 & \verb~289~ & & \verb~            }~\\
\cellcolor{green} & 5 & \verb~290~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~291~ & & \verb~~\\
\cellcolor{gray} &  & \verb~292~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~293~ & & \verb~}~\\
\end{longtable}
\newpage
\section{Breakout.NormalBlock}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Breakout.NormalBlock\\
\textbf{Assembly:} & Breakout\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/magnus/Desktop/SU/DIKUGames/Breakout/Blocks/NormalBlock.cs}\end{minipage} \\
\textbf{Covered lines:} & 34\\
\textbf{Uncovered lines:} & 0\\
\textbf{Coverable lines:} & 34\\
\textbf{Total lines:} & 80\\
\textbf{Line coverage:} & 100\% (34 of 34)\\
\textbf{Covered branches:} & 5\\
\textbf{Total branches:} & 6\\
\textbf{Branch coverage:} & 83.3\% (5 of 6)\\
\textbf{Covered methods:} & 8\\
\textbf{Total methods:} & 8\\
\textbf{Method coverage:} & 100\% (8 of 8)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 100\%\\
\hline
\textbf{GetHealth()} & 100\% & 1 & 100\%\\
\hline
\textbf{DecHealth()} & 100\% & 2 & 100\%\\
\hline
\textbf{GetValue()} & 100\% & 1 & 100\%\\
\hline
\textbf{SetValue(...)} & 100\% & 1 & 100\%\\
\hline
\textbf{GetPosition()} & 100\% & 1 & 100\%\\
\hline
\textbf{IsPowerUp()} & 100\% & 1 & 100\%\\
\hline
\textbf{ProcessEvent(...)} & 75.00\% & 4 & 100\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/magnus/Desktop/SU/DIKUGames/Breakout/Blocks/NormalBlock.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.Graphics;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using DIKUArcade.Events;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~using DIKUArcade.Math;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~namespace Breakout {~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~    ///  This class represents normal Blocks.~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~    public class NormalBlock : Block {~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~        private int health;~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~        private int value;~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~~\\
\cellcolor{green} & 194 & \verb~14~ & & \verb~        public NormalBlock(Shape shape, IBaseImage image) : base(shape, image) {~\\
\cellcolor{green} & 97 & \verb~15~ & & \verb~            this.shape = shape;~\\
\cellcolor{green} & 97 & \verb~16~ & & \verb~            health = 1;~\\
\cellcolor{green} & 97 & \verb~17~ & & \verb~            value = 1;~\\
\cellcolor{green} & 97 & \verb~18~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~19~ & & \verb~~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~        /// Returs the health of the Block.~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~24~ & & \verb~        /// <returns>the health of the block in int</returns>~\\
\cellcolor{green} & 3 & \verb~25~ & & \verb~        public override int GetHealth() {~\\
\cellcolor{green} & 3 & \verb~26~ & & \verb~            return health;~\\
\cellcolor{green} & 3 & \verb~27~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~28~ & & \verb~~\\
\cellcolor{gray} &  & \verb~29~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~30~ & & \verb~        /// Decreases the health field.~\\
\cellcolor{gray} &  & \verb~31~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 3 & \verb~32~ & & \verb~        public override void DecHealth(){~\\
\cellcolor{green} & 3 & \verb~33~ & & \verb~            health--;~\\
\cellcolor{green} & 6 & \verb~34~ & & \verb~            if (health <= 0){~\\
\cellcolor{green} & 3 & \verb~35~ & & \verb~                DeleteEntity();~\\
\cellcolor{green} & 3 & \verb~36~ & & \verb~                BreakoutBus.GetBus().RegisterEvent (new GameEvent {~\\
\cellcolor{green} & 3 & \verb~37~ & & \verb~                        EventType = GameEventType.GraphicsEvent, IntArg1 = 5,~\\
\cellcolor{green} & 3 & \verb~38~ & & \verb~                    });~\\
\cellcolor{green} & 3 & \verb~39~ & & \verb~            }~\\
\cellcolor{green} & 3 & \verb~40~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~41~ & & \verb~~\\
\cellcolor{gray} &  & \verb~42~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~43~ & & \verb~        /// Returns the value field. Only there not to get warning for now.~\\
\cellcolor{gray} &  & \verb~44~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~45~ & & \verb~        /// <returns></returns>~\\
\cellcolor{green} & 2 & \verb~46~ & & \verb~        public override int GetValue(){~\\
\cellcolor{green} & 2 & \verb~47~ & & \verb~            return value;~\\
\cellcolor{green} & 2 & \verb~48~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~49~ & & \verb~~\\
\cellcolor{gray} &  & \verb~50~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~51~ & & \verb~        /// Sets the vakue to amount.~\\
\cellcolor{gray} &  & \verb~52~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~53~ & & \verb~        /// <param name="amount">what to set value to</param>~\\
\cellcolor{green} & 79 & \verb~54~ & & \verb~        public override void SetValue(int amount) {~\\
\cellcolor{green} & 79 & \verb~55~ & & \verb~            value = amount;~\\
\cellcolor{green} & 79 & \verb~56~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~57~ & & \verb~~\\
\cellcolor{gray} &  & \verb~58~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~59~ & & \verb~        /// Returns the position of the shape of the block.~\\
\cellcolor{gray} &  & \verb~60~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~61~ & & \verb~        /// <returns></returns>~\\
\cellcolor{green} & 2 & \verb~62~ & & \verb~        public override Vec2F GetPosition() {~\\
\cellcolor{green} & 2 & \verb~63~ & & \verb~            return shape.Position;~\\
\cellcolor{green} & 2 & \verb~64~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~65~ & & \verb~~\\
\cellcolor{green} & 1 & \verb~66~ & & \verb~        public override bool IsPowerUp() {~\\
\cellcolor{green} & 1 & \verb~67~ & & \verb~            return false;~\\
\cellcolor{green} & 1 & \verb~68~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~69~ & & \verb~~\\
\cellcolor{gray} &  & \verb~70~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~71~ & & \verb~        /// processes a gameEvent~\\
\cellcolor{gray} &  & \verb~72~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~73~ & & \verb~        /// <param name="gameEvent">the gameEvent to process</param>~\\
\cellcolor{green} & 4 & \verb~74~ & & \verb~        public override void ProcessEvent(GameEvent gameEvent){~\\
\cellcolor{orange} & 7 & \verb~75~ & & \verb~            if (gameEvent.EventType == GameEventType.InputEvent && gameEvent.IntArg1 == value) { //Checks if it a InputE~\\
\cellcolor{green} & 3 & \verb~76~ & & \verb~                DecHealth();~\\
\cellcolor{green} & 3 & \verb~77~ & & \verb~            }~\\
\cellcolor{green} & 4 & \verb~78~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~79~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~80~ & & \verb~}~\\
\end{longtable}
\newpage
\section{Breakout.Player}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Breakout.Player\\
\textbf{Assembly:} & Breakout\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/magnus/Desktop/SU/DIKUGames/Breakout/GameElements/Player.cs}\end{minipage} \\
\textbf{Covered lines:} & 137\\
\textbf{Uncovered lines:} & 11\\
\textbf{Coverable lines:} & 148\\
\textbf{Total lines:} & 264\\
\textbf{Line coverage:} & 92.5\% (137 of 148)\\
\textbf{Covered branches:} & 48\\
\textbf{Total branches:} & 50\\
\textbf{Branch coverage:} & 96\% (48 of 50)\\
\textbf{Covered methods:} & 18\\
\textbf{Total methods:} & 19\\
\textbf{Method coverage:} & 94.7\% (18 of 19)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{get\_shape()} & 100\% & 1 & 100\%\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 100\%\\
\hline
\textbf{Render()} & 100\% & 1 & 0\%\\
\hline
\textbf{Move()} & 90.0\% & 10 & 100\%\\
\hline
\textbf{SetMoveLeft(...)} & 100\% & 2 & 100\%\\
\hline
\textbf{SetMoveRight(...)} & 100\% & 2 & 100\%\\
\hline
\textbf{UpdateDirection()} & 100\% & 1 & 100\%\\
\hline
\textbf{GetPosition()} & 100\% & 1 & 100\%\\
\hline
\textbf{ProcessEvent(...)} & 100\% & 14 & 100\%\\
\hline
\textbf{KeyPress(...)} & 100\% & 4 & 87.50\%\\
\hline
\textbf{KeyRelease(...)} & 100\% & 4 & 87.50\%\\
\hline
\textbf{Reset()} & 100\% & 1 & 100\%\\
\hline
\textbf{DecLife()} & 100\% & 2 & 100\%\\
\hline
\textbf{IncLife()} & 100\% & 1 & 100\%\\
\hline
\textbf{IncWidth()} & 100\% & 2 & 100\%\\
\hline
\textbf{IncSpeed()} & 100\% & 2 & 100\%\\
\hline
\textbf{UpdatePlayerPowerups} & 87.50\% & 8 & 66.66\%\\
\hline
\textbf{C1GetWindowLimit()} & 100\% & 1 & 100\%\\
\hline
\textbf{C1UpdatePlayerPoweru} & 100\% & 1 & 100\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/magnus/Desktop/SU/DIKUGames/Breakout/GameElements/Player.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.Graphics;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using DIKUArcade.Math;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~using DIKUArcade.Events;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~using DIKUArcade.Input;~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~using DIKUArcade.Timers;~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~namespace Breakout {~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~    ///  This class represents the player. Everything to do with moving it and handling the player~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~    /// specific powerups.~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~    public class Player : Entity, IGameEventProcessor {~\\
\cellcolor{green} & 494 & \verb~14~ & & \verb~        public Shape shape { get;}~\\
\cellcolor{gray} &  & \verb~15~ & & \verb~        private float moveLeft;~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~        private float moveRight;~\\
\cellcolor{gray} &  & \verb~17~ & & \verb~        private float MOVEMENT_SPEED;~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~        public int life;~\\
\cellcolor{gray} &  & \verb~19~ & & \verb~        private Text display;~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~        public int timeSpeed;~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~        public int timeWidth;~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~        private float windowLimit;~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~        public bool isWide;~\\
\cellcolor{gray} &  & \verb~24~ & & \verb~        public bool isFast;~\\
\cellcolor{gray} &  & \verb~25~ & & \verb~~\\
\cellcolor{green} & 192 & \verb~26~ & & \verb~        public Player(Shape shape, IBaseImage image) : base(shape, image) {~\\
\cellcolor{green} & 96 & \verb~27~ & & \verb~            this.shape = shape;~\\
\cellcolor{green} & 96 & \verb~28~ & & \verb~            moveLeft = 0.0f;~\\
\cellcolor{green} & 96 & \verb~29~ & & \verb~            moveRight = 0.0f;~\\
\cellcolor{green} & 96 & \verb~30~ & & \verb~            MOVEMENT_SPEED = 0.02f;~\\
\cellcolor{green} & 96 & \verb~31~ & & \verb~            Shape = shape;~\\
\cellcolor{green} & 96 & \verb~32~ & & \verb~            shape.Position = new Vec2F(0.425f, 0.03f);~\\
\cellcolor{green} & 96 & \verb~33~ & & \verb~            life = 3;~\\
\cellcolor{green} & 96 & \verb~34~ & & \verb~            isWide = false;~\\
\cellcolor{green} & 96 & \verb~35~ & & \verb~            isFast = false;~\\
\cellcolor{green} & 96 & \verb~36~ & & \verb~            display = new Text ("HP: " + life.ToString(), new Vec2F(0.05f, -0.4f), new Vec2F(0.5f,0.5f));~\\
\cellcolor{green} & 96 & \verb~37~ & & \verb~            display.SetColor(new Vec3I(255, 0, 0));~\\
\cellcolor{green} & 96 & \verb~38~ & & \verb~            timeSpeed=-100;~\\
\cellcolor{green} & 96 & \verb~39~ & & \verb~            timeWidth=-100;~\\
\cellcolor{green} & 96 & \verb~40~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~41~ & & \verb~~\\
\cellcolor{gray} &  & \verb~42~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~43~ & & \verb~        /// renders the player and points~\\
\cellcolor{gray} &  & \verb~44~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~45~ & & \verb~        public void Render() {~\\
\cellcolor{red} & 0 & \verb~46~ & & \verb~            this.RenderEntity();~\\
\cellcolor{red} & 0 & \verb~47~ & & \verb~            display.SetText("HP: " + life.ToString());~\\
\cellcolor{red} & 0 & \verb~48~ & & \verb~            display.RenderText();~\\
\cellcolor{red} & 0 & \verb~49~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~50~ & & \verb~~\\
\cellcolor{gray} &  & \verb~51~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~52~ & & \verb~        /// checks if the player can move.~\\
\cellcolor{gray} &  & \verb~53~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 22 & \verb~54~ & & \verb~        public void Move() {~\\
\cellcolor{green} & 22 & \verb~55~ & & \verb~            if (isWide == true)~\\
\cellcolor{green} & 2 & \verb~56~ & & \verb~                windowLimit = 0.681f;~\\
\cellcolor{gray} &  & \verb~57~ & & \verb~            else~\\
\cellcolor{green} & 20 & \verb~58~ & & \verb~                windowLimit = 0.845f;~\\
\cellcolor{orange} & 22 & \verb~59~ & & \verb~            if (shape.Position.X + shape.AsDynamicShape().Direction.X > 0.0f && shape.Position.X +~\\
\cellcolor{green} & 41 & \verb~60~ & & \verb~            shape.AsDynamicShape().Direction.X < windowLimit) {~\\
\cellcolor{green} & 19 & \verb~61~ & & \verb~                shape.Move();~\\
\cellcolor{green} & 19 & \verb~62~ & & \verb~            }~\\
\cellcolor{green} & 4 & \verb~63~ & & \verb~            else if (isWide == true && shape.Position.X + shape.AsDynamicShape().Direction.X > windowLimit){~\\
\cellcolor{green} & 1 & \verb~64~ & & \verb~                shape.Position.X = 0.681f;~\\
\cellcolor{green} & 1 & \verb~65~ & & \verb~            }~\\
\cellcolor{green} & 22 & \verb~66~ & & \verb~            UpdatePlayerPowerups();~\\
\cellcolor{green} & 22 & \verb~67~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~68~ & & \verb~~\\
\cellcolor{gray} &  & \verb~69~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~70~ & & \verb~        /// sets the left movement bool~\\
\cellcolor{gray} &  & \verb~71~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~72~ & & \verb~        /// <param name="val">if the move right field should change or not</param>~\\
\cellcolor{green} & 104 & \verb~73~ & & \verb~        private void SetMoveLeft(bool val) {~\\
\cellcolor{green} & 207 & \verb~74~ & & \verb~            if (val == true) {~\\
\cellcolor{green} & 103 & \verb~75~ & & \verb~                moveLeft -= MOVEMENT_SPEED;~\\
\cellcolor{green} & 103 & \verb~76~ & & \verb~                UpdateDirection();~\\
\cellcolor{green} & 103 & \verb~77~ & & \verb~            }~\\
\cellcolor{green} & 1 & \verb~78~ & & \verb~            else {~\\
\cellcolor{green} & 1 & \verb~79~ & & \verb~                moveLeft = 0.0f;~\\
\cellcolor{green} & 1 & \verb~80~ & & \verb~                UpdateDirection();~\\
\cellcolor{green} & 1 & \verb~81~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~82~ & & \verb~~\\
\cellcolor{green} & 104 & \verb~83~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~84~ & & \verb~~\\
\cellcolor{gray} &  & \verb~85~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~86~ & & \verb~        /// Sets the right movement bool~\\
\cellcolor{gray} &  & \verb~87~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~88~ & & \verb~        /// <param name="val">if the move right field should change or not</param>~\\
\cellcolor{green} & 104 & \verb~89~ & & \verb~        private void SetMoveRight(bool val) {~\\
\cellcolor{green} & 207 & \verb~90~ & & \verb~            if (val == true) {~\\
\cellcolor{green} & 103 & \verb~91~ & & \verb~                moveRight += MOVEMENT_SPEED;~\\
\cellcolor{green} & 103 & \verb~92~ & & \verb~                UpdateDirection();~\\
\cellcolor{green} & 103 & \verb~93~ & & \verb~            }~\\
\cellcolor{green} & 1 & \verb~94~ & & \verb~            else {~\\
\cellcolor{green} & 1 & \verb~95~ & & \verb~                moveRight = 0.0f;~\\
\cellcolor{green} & 1 & \verb~96~ & & \verb~                UpdateDirection();~\\
\cellcolor{green} & 1 & \verb~97~ & & \verb~            }~\\
\cellcolor{green} & 104 & \verb~98~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~99~ & & \verb~~\\
\cellcolor{gray} &  & \verb~100~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~101~ & & \verb~        /// updates the direction of the player~\\
\cellcolor{gray} &  & \verb~102~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 208 & \verb~103~ & & \verb~        private void UpdateDirection() {~\\
\cellcolor{green} & 208 & \verb~104~ & & \verb~            shape.AsDynamicShape().Direction.X = moveRight + moveLeft;~\\
\cellcolor{green} & 208 & \verb~105~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~106~ & & \verb~~\\
\cellcolor{gray} &  & \verb~107~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~108~ & & \verb~        /// returns the players position~\\
\cellcolor{gray} &  & \verb~109~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~110~ & & \verb~        /// <returns>the players position</returns>~\\
\cellcolor{green} & 15 & \verb~111~ & & \verb~        public Vec2F GetPosition() {~\\
\cellcolor{green} & 15 & \verb~112~ & & \verb~            return shape.Position;~\\
\cellcolor{green} & 15 & \verb~113~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~114~ & & \verb~~\\
\cellcolor{gray} &  & \verb~115~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~116~ & & \verb~        /// processes all events. only takes PlayerEvents.~\\
\cellcolor{gray} &  & \verb~117~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~118~ & & \verb~        /// <param name="gameEvent">the gamevent to process.</param>~\\
\cellcolor{green} & 216 & \verb~119~ & & \verb~        public void ProcessEvent(GameEvent gameEvent) {~\\
\cellcolor{green} & 431 & \verb~120~ & & \verb~            if (gameEvent.EventType == GameEventType.PlayerEvent) {~\\
\cellcolor{green} & 215 & \verb~121~ & & \verb~                switch (gameEvent.Message) {~\\
\cellcolor{gray} &  & \verb~122~ & & \verb~                    case "KeyPress":~\\
\cellcolor{green} & 206 & \verb~123~ & & \verb~                        KeyPress((KeyboardKey)gameEvent.IntArg1);~\\
\cellcolor{green} & 206 & \verb~124~ & & \verb~                        break;~\\
\cellcolor{gray} &  & \verb~125~ & & \verb~                    case "KeyRelease":~\\
\cellcolor{green} & 2 & \verb~126~ & & \verb~                        KeyRelease((KeyboardKey)gameEvent.IntArg1);~\\
\cellcolor{green} & 2 & \verb~127~ & & \verb~                        break;~\\
\cellcolor{gray} &  & \verb~128~ & & \verb~                    case "IncLife":~\\
\cellcolor{green} & 1 & \verb~129~ & & \verb~                        IncLife();~\\
\cellcolor{green} & 1 & \verb~130~ & & \verb~                        break;~\\
\cellcolor{gray} &  & \verb~131~ & & \verb~                    case "DecLife":~\\
\cellcolor{green} & 1 & \verb~132~ & & \verb~                        DecLife();~\\
\cellcolor{green} & 1 & \verb~133~ & & \verb~                        break;~\\
\cellcolor{gray} &  & \verb~134~ & & \verb~                    case "IncWidth":~\\
\cellcolor{green} & 2 & \verb~135~ & & \verb~                        IncWidth();~\\
\cellcolor{green} & 2 & \verb~136~ & & \verb~                        break;~\\
\cellcolor{gray} &  & \verb~137~ & & \verb~                    case "IncSpeed":~\\
\cellcolor{green} & 2 & \verb~138~ & & \verb~                        IncSpeed();~\\
\cellcolor{green} & 2 & \verb~139~ & & \verb~                        break;~\\
\cellcolor{gray} &  & \verb~140~ & & \verb~                    default:~\\
\cellcolor{green} & 1 & \verb~141~ & & \verb~                        break;~\\
\cellcolor{gray} &  & \verb~142~ & & \verb~                }~\\
\cellcolor{green} & 215 & \verb~143~ & & \verb~            }~\\
\cellcolor{green} & 216 & \verb~144~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~145~ & & \verb~~\\
\cellcolor{gray} &  & \verb~146~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~147~ & & \verb~        /// calls SetMoveRight or SetMoveLeft accordinly to the pressed key~\\
\cellcolor{gray} &  & \verb~148~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~149~ & & \verb~        /// <param name="key">pressed key</param>~\\
\cellcolor{green} & 206 & \verb~150~ & & \verb~        private void KeyPress(KeyboardKey key) { // Initiating keypresses on given keys with switch~\\
\cellcolor{green} & 206 & \verb~151~ & & \verb~            switch (key) {~\\
\cellcolor{gray} &  & \verb~152~ & & \verb~                case KeyboardKey.Right:~\\
\cellcolor{green} & 103 & \verb~153~ & & \verb~                    SetMoveRight(true); // Starting movement on press~\\
\cellcolor{green} & 103 & \verb~154~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~155~ & & \verb~                case KeyboardKey.Left:~\\
\cellcolor{green} & 103 & \verb~156~ & & \verb~                    SetMoveLeft(true); // Starting movement on press~\\
\cellcolor{green} & 103 & \verb~157~ & & \verb~                    break;~\\
\cellcolor{red} & 0 & \verb~158~ & & \verb~                default: break;~\\
\cellcolor{gray} &  & \verb~159~ & & \verb~            }~\\
\cellcolor{green} & 206 & \verb~160~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~161~ & & \verb~~\\
\cellcolor{gray} &  & \verb~162~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~163~ & & \verb~        /// calls SetMoveRight or SetMoveLeft accordinly to the released key~\\
\cellcolor{gray} &  & \verb~164~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~165~ & & \verb~        /// <param name="key">released key</param>~\\
\cellcolor{green} & 2 & \verb~166~ & & \verb~        private void KeyRelease(KeyboardKey key) {~\\
\cellcolor{green} & 2 & \verb~167~ & & \verb~            switch (key) {~\\
\cellcolor{gray} &  & \verb~168~ & & \verb~                case KeyboardKey.Right:~\\
\cellcolor{green} & 1 & \verb~169~ & & \verb~                    SetMoveRight(false); // Stopping movement on release~\\
\cellcolor{green} & 1 & \verb~170~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~171~ & & \verb~                case KeyboardKey.Left:~\\
\cellcolor{green} & 1 & \verb~172~ & & \verb~                    SetMoveLeft(false); // Stopping movement on release~\\
\cellcolor{green} & 1 & \verb~173~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~174~ & & \verb~                default:~\\
\cellcolor{red} & 0 & \verb~175~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~176~ & & \verb~            }~\\
\cellcolor{green} & 2 & \verb~177~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~178~ & & \verb~~\\
\cellcolor{gray} &  & \verb~179~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~180~ & & \verb~        /// Resets the player~\\
\cellcolor{gray} &  & \verb~181~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 23 & \verb~182~ & & \verb~        public void Reset(){~\\
\cellcolor{green} & 23 & \verb~183~ & & \verb~            shape.Position = new Vec2F(0.425f, 0.03f);~\\
\cellcolor{green} & 23 & \verb~184~ & & \verb~            life = 3;~\\
\cellcolor{green} & 23 & \verb~185~ & & \verb~            MOVEMENT_SPEED = 0.02f;~\\
\cellcolor{green} & 23 & \verb~186~ & & \verb~            Shape = shape;~\\
\cellcolor{green} & 23 & \verb~187~ & & \verb~            isFast = false;~\\
\cellcolor{green} & 23 & \verb~188~ & & \verb~            shape.Extent = new Vec2F(0.16f, 0.020f);~\\
\cellcolor{green} & 23 & \verb~189~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~190~ & & \verb~~\\
\cellcolor{gray} &  & \verb~191~ & & \verb~~\\
\cellcolor{gray} &  & \verb~192~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~193~ & & \verb~        /// Decreases the life field of player, and if life is under or equal to zero~\\
\cellcolor{gray} &  & \verb~194~ & & \verb~        /// sends out an event that when caught by gamerunning will end the game.~\\
\cellcolor{gray} &  & \verb~195~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 1 & \verb~196~ & & \verb~        private void DecLife(){~\\
\cellcolor{green} & 1 & \verb~197~ & & \verb~            life--;~\\
\cellcolor{green} & 2 & \verb~198~ & & \verb~            if (life <= 0){~\\
\cellcolor{green} & 1 & \verb~199~ & & \verb~                BreakoutBus.GetBus().RegisterEvent(~\\
\cellcolor{green} & 1 & \verb~200~ & & \verb~                        new GameEvent{~\\
\cellcolor{green} & 1 & \verb~201~ & & \verb~                            EventType = GameEventType.StatusEvent,~\\
\cellcolor{green} & 1 & \verb~202~ & & \verb~                            Message = "PlayerDead"~\\
\cellcolor{green} & 1 & \verb~203~ & & \verb~                        }~\\
\cellcolor{green} & 1 & \verb~204~ & & \verb~                    );~\\
\cellcolor{green} & 1 & \verb~205~ & & \verb~            }~\\
\cellcolor{green} & 1 & \verb~206~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~207~ & & \verb~~\\
\cellcolor{gray} &  & \verb~208~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~209~ & & \verb~        /// Increases the life field by one~\\
\cellcolor{gray} &  & \verb~210~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 1 & \verb~211~ & & \verb~        private void IncLife(){~\\
\cellcolor{green} & 1 & \verb~212~ & & \verb~            life++;~\\
\cellcolor{green} & 1 & \verb~213~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~214~ & & \verb~~\\
\cellcolor{gray} &  & \verb~215~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~216~ & & \verb~        /// doubles the exstent of player if it has not already been, and saves the time it is done.~\\
\cellcolor{gray} &  & \verb~217~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 2 & \verb~218~ & & \verb~        private void IncWidth() {~\\
\cellcolor{green} & 4 & \verb~219~ & & \verb~            if (isWide == false) {~\\
\cellcolor{green} & 2 & \verb~220~ & & \verb~                isWide = true;~\\
\cellcolor{green} & 2 & \verb~221~ & & \verb~                this.shape.ScaleX(2.0f);~\\
\cellcolor{green} & 2 & \verb~222~ & & \verb~                timeWidth = System.Convert.ToInt32(StaticTimer.GetElapsedSeconds());~\\
\cellcolor{green} & 2 & \verb~223~ & & \verb~            }~\\
\cellcolor{green} & 2 & \verb~224~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~225~ & & \verb~~\\
\cellcolor{gray} &  & \verb~226~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~227~ & & \verb~        /// If the player is not already fast its speed is doubled by two and the time is saved.~\\
\cellcolor{gray} &  & \verb~228~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 2 & \verb~229~ & & \verb~        private void IncSpeed() {~\\
\cellcolor{green} & 4 & \verb~230~ & & \verb~            if (isFast == false) {~\\
\cellcolor{green} & 2 & \verb~231~ & & \verb~                isFast = true;~\\
\cellcolor{green} & 2 & \verb~232~ & & \verb~                MOVEMENT_SPEED*=2.0f;~\\
\cellcolor{green} & 2 & \verb~233~ & & \verb~                timeSpeed = System.Convert.ToInt32(StaticTimer.GetElapsedSeconds());~\\
\cellcolor{green} & 2 & \verb~234~ & & \verb~            }~\\
\cellcolor{green} & 2 & \verb~235~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~236~ & & \verb~~\\
\cellcolor{gray} &  & \verb~237~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~238~ & & \verb~        /// Updates the player powerups by cheching if an powerup is active and if the appropriate~\\
\cellcolor{gray} &  & \verb~239~ & & \verb~        /// tie has passed to end the poweeup.~\\
\cellcolor{gray} &  & \verb~240~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 23 & \verb~241~ & & \verb~        private void UpdatePlayerPowerups(){~\\
\cellcolor{green} & 25 & \verb~242~ & & \verb~                if (isWide && timeWidth + 10  < System.Convert.ToInt32(StaticTimer.GetElapsedSeconds())){~\\
\cellcolor{green} & 2 & \verb~243~ & & \verb~                    timeWidth = -100;~\\
\cellcolor{green} & 2 & \verb~244~ & & \verb~                    isWide = false;~\\
\cellcolor{green} & 2 & \verb~245~ & & \verb~                    shape.Extent = new Vec2F(0.16f, 0.020f);~\\
\cellcolor{green} & 2 & \verb~246~ & & \verb~                }~\\
\cellcolor{orange} & 23 & \verb~247~ & & \verb~                if (isFast && timeSpeed + 10 < System.Convert.ToInt32(StaticTimer.GetElapsedSeconds())){~\\
\cellcolor{red} & 0 & \verb~248~ & & \verb~                    timeSpeed = -100;~\\
\cellcolor{red} & 0 & \verb~249~ & & \verb~                    isFast = false;~\\
\cellcolor{red} & 0 & \verb~250~ & & \verb~                    MOVEMENT_SPEED = 0.02f;~\\
\cellcolor{red} & 0 & \verb~251~ & & \verb~                }~\\
\cellcolor{green} & 23 & \verb~252~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~253~ & & \verb~~\\
\cellcolor{gray} &  & \verb~254~ & & \verb~        //Returns the window limit for C1 testing.~\\
\cellcolor{green} & 4 & \verb~255~ & & \verb~        public float C1GetWindowLimit() {~\\
\cellcolor{green} & 4 & \verb~256~ & & \verb~            return windowLimit;~\\
\cellcolor{green} & 4 & \verb~257~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~258~ & & \verb~~\\
\cellcolor{gray} &  & \verb~259~ & & \verb~        //Updates player powerups for C1 testing.~\\
\cellcolor{green} & 1 & \verb~260~ & & \verb~        public void C1UpdatePlayerPowerups(){~\\
\cellcolor{green} & 1 & \verb~261~ & & \verb~            UpdatePlayerPowerups();~\\
\cellcolor{green} & 1 & \verb~262~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~263~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~264~ & & \verb~}~\\
\end{longtable}
\newpage
\section{Breakout.PowerUpBlock}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Breakout.PowerUpBlock\\
\textbf{Assembly:} & Breakout\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/magnus/Desktop/SU/DIKUGames/Breakout/Blocks/PowerUpBlock.cs}\end{minipage} \\
\textbf{Covered lines:} & 34\\
\textbf{Uncovered lines:} & 0\\
\textbf{Coverable lines:} & 34\\
\textbf{Total lines:} & 80\\
\textbf{Line coverage:} & 100\% (34 of 34)\\
\textbf{Covered branches:} & 5\\
\textbf{Total branches:} & 6\\
\textbf{Branch coverage:} & 83.3\% (5 of 6)\\
\textbf{Covered methods:} & 8\\
\textbf{Total methods:} & 8\\
\textbf{Method coverage:} & 100\% (8 of 8)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 100\%\\
\hline
\textbf{GetHealth()} & 100\% & 1 & 100\%\\
\hline
\textbf{DecHealth()} & 100\% & 2 & 100\%\\
\hline
\textbf{GetValue()} & 100\% & 1 & 100\%\\
\hline
\textbf{SetValue(...)} & 100\% & 1 & 100\%\\
\hline
\textbf{GetPosition()} & 100\% & 1 & 100\%\\
\hline
\textbf{IsPowerUp()} & 100\% & 1 & 100\%\\
\hline
\textbf{ProcessEvent(...)} & 75.00\% & 4 & 100\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/magnus/Desktop/SU/DIKUGames/Breakout/Blocks/PowerUpBlock.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.Graphics;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using DIKUArcade.Events;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~using DIKUArcade.Math;~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~namespace Breakout {~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~    ///  This class represents PowerUpBlocks Blocks. Only class where IsPowerUp returns true.~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~    public class PowerUpBlock : Block {~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~        private int health;~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~        private int value;~\\
\cellcolor{green} & 86 & \verb~15~ & & \verb~        public PowerUpBlock(Shape shape, IBaseImage image) : base(shape, image) {~\\
\cellcolor{green} & 43 & \verb~16~ & & \verb~            this.shape = shape;~\\
\cellcolor{green} & 43 & \verb~17~ & & \verb~            health = 1;~\\
\cellcolor{green} & 43 & \verb~18~ & & \verb~            value = 1;~\\
\cellcolor{green} & 43 & \verb~19~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~        /// Returns the health of the block.~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~24~ & & \verb~        /// <returns> int health field</returns>~\\
\cellcolor{green} & 3 & \verb~25~ & & \verb~        public override int GetHealth() {~\\
\cellcolor{green} & 3 & \verb~26~ & & \verb~            return health;~\\
\cellcolor{green} & 3 & \verb~27~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~28~ & & \verb~~\\
\cellcolor{gray} &  & \verb~29~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~30~ & & \verb~        /// Does nothing, because unbreakable blocks cannot loose health.~\\
\cellcolor{gray} &  & \verb~31~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 3 & \verb~32~ & & \verb~        public override void DecHealth () {~\\
\cellcolor{green} & 3 & \verb~33~ & & \verb~            health--;~\\
\cellcolor{green} & 6 & \verb~34~ & & \verb~            if (health <= 0){~\\
\cellcolor{green} & 3 & \verb~35~ & & \verb~                DeleteEntity();~\\
\cellcolor{green} & 3 & \verb~36~ & & \verb~                BreakoutBus.GetBus().RegisterEvent (new GameEvent {~\\
\cellcolor{green} & 3 & \verb~37~ & & \verb~                        EventType = GameEventType.GraphicsEvent, IntArg1 = 5,~\\
\cellcolor{green} & 3 & \verb~38~ & & \verb~                    });~\\
\cellcolor{green} & 3 & \verb~39~ & & \verb~            }~\\
\cellcolor{green} & 3 & \verb~40~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~41~ & & \verb~~\\
\cellcolor{gray} &  & \verb~42~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~43~ & & \verb~        /// Returns the value field.~\\
\cellcolor{gray} &  & \verb~44~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~45~ & & \verb~        /// <returns></returns>~\\
\cellcolor{green} & 7 & \verb~46~ & & \verb~        public override int GetValue() {~\\
\cellcolor{green} & 7 & \verb~47~ & & \verb~            return value;~\\
\cellcolor{green} & 7 & \verb~48~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~49~ & & \verb~~\\
\cellcolor{gray} &  & \verb~50~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~51~ & & \verb~        /// sets the value field to amount.~\\
\cellcolor{gray} &  & \verb~52~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~53~ & & \verb~        /// <param name="amount">what to set value field to</param>~\\
\cellcolor{green} & 3 & \verb~54~ & & \verb~        public override void SetValue(int amount) {~\\
\cellcolor{green} & 3 & \verb~55~ & & \verb~            value = amount;~\\
\cellcolor{green} & 3 & \verb~56~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~57~ & & \verb~~\\
\cellcolor{gray} &  & \verb~58~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~59~ & & \verb~        /// gets the position of the shape of the Block~\\
\cellcolor{gray} &  & \verb~60~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~61~ & & \verb~        /// <returns></returns>~\\
\cellcolor{green} & 2 & \verb~62~ & & \verb~        public override Vec2F GetPosition() {~\\
\cellcolor{green} & 2 & \verb~63~ & & \verb~            return shape.Position;~\\
\cellcolor{green} & 2 & \verb~64~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~65~ & & \verb~~\\
\cellcolor{green} & 2 & \verb~66~ & & \verb~        public override bool IsPowerUp() {~\\
\cellcolor{green} & 2 & \verb~67~ & & \verb~            return true;~\\
\cellcolor{green} & 2 & \verb~68~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~69~ & & \verb~~\\
\cellcolor{gray} &  & \verb~70~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~71~ & & \verb~        /// processes a gameEvent~\\
\cellcolor{gray} &  & \verb~72~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~73~ & & \verb~        /// <param name="gameEvent">the gameEvent to process</param>~\\
\cellcolor{green} & 4 & \verb~74~ & & \verb~        public override void ProcessEvent(GameEvent gameEvent){~\\
\cellcolor{orange} & 7 & \verb~75~ & & \verb~            if (gameEvent.EventType == GameEventType.InputEvent && gameEvent.IntArg1 == value) { //Checks if it a InputE~\\
\cellcolor{green} & 3 & \verb~76~ & & \verb~                DecHealth();~\\
\cellcolor{green} & 3 & \verb~77~ & & \verb~            }~\\
\cellcolor{green} & 4 & \verb~78~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~79~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~80~ & & \verb~}~\\
\end{longtable}
\newpage
\section{Breakout.PowerUpDrop}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Breakout.PowerUpDrop\\
\textbf{Assembly:} & Breakout\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/magnus/Desktop/SU/DIKUGames/Breakout/GameElements/PowerUpDrop.cs}\end{minipage} \\
\textbf{Covered lines:} & 43\\
\textbf{Uncovered lines:} & 6\\
\textbf{Coverable lines:} & 49\\
\textbf{Total lines:} & 100\\
\textbf{Line coverage:} & 87.7\% (43 of 49)\\
\textbf{Covered branches:} & 13\\
\textbf{Total branches:} & 14\\
\textbf{Branch coverage:} & 92.8\% (13 of 14)\\
\textbf{Covered methods:} & 4\\
\textbf{Total methods:} & 5\\
\textbf{Method coverage:} & 80\% (4 of 5)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{get\_shape()} & 100\% & 1 & 100\%\\
\hline
\textbf{.ctor(...)} & 100\% & 6 & 95.83\%\\
\hline
\textbf{Render()} & 100\% & 1 & 0\%\\
\hline
\textbf{Move()} & 100\% & 1 & 100\%\\
\hline
\textbf{Consume(...)} & 87.50\% & 8 & 88.23\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/magnus/Desktop/SU/DIKUGames/Breakout/GameElements/PowerUpDrop.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using System;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~using DIKUArcade.Graphics;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~using DIKUArcade.Math;~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~using DIKUArcade.Physics;~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~namespace Breakout {~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~    ///  This class represents the powerupdrops, which are the powerups that go down the screen~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~    /// when a powerupblock is hit. What the powerup does is randomly decided.~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~    public class PowerUpDrop : Entity {~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~        private float Yvelocity;~\\
\cellcolor{gray} &  & \verb~15~ & & \verb~        private static Vec2F extend;~\\
\cellcolor{green} & 3518 & \verb~16~ & & \verb~        public DynamicShape shape {get;}~\\
\cellcolor{gray} &  & \verb~17~ & & \verb~        private Entity entity;~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~        private int randNumber;~\\
\cellcolor{gray} &  & \verb~19~ & & \verb~        private Random rand;~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~        public int powerUpNumber;~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~        private PowerUps pwUp;~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~~\\
\cellcolor{green} & 30 & \verb~23~ & & \verb~        public PowerUpDrop(DynamicShape shape, IBaseImage image) : base(shape, image) {~\\
\cellcolor{green} & 15 & \verb~24~ & & \verb~            this.shape = shape;~\\
\cellcolor{green} & 15 & \verb~25~ & & \verb~            entity = new Entity(shape, image);~\\
\cellcolor{green} & 15 & \verb~26~ & & \verb~            Yvelocity = 0.1f;~\\
\cellcolor{green} & 15 & \verb~27~ & & \verb~            shape.Direction = new Vec2F(0.0f,-0.01f);~\\
\cellcolor{green} & 15 & \verb~28~ & & \verb~            extend = new Vec2F(0.1f, 0.1f);~\\
\cellcolor{green} & 15 & \verb~29~ & & \verb~            rand = new Random();~\\
\cellcolor{green} & 15 & \verb~30~ & & \verb~            randNumber = rand.Next(5);~\\
\cellcolor{green} & 15 & \verb~31~ & & \verb~            powerUpNumber = randNumber;~\\
\cellcolor{green} & 15 & \verb~32~ & & \verb~            pwUp = new PowerUps();~\\
\cellcolor{green} & 15 & \verb~33~ & & \verb~            switch (powerUpNumber) {~\\
\cellcolor{gray} &  & \verb~34~ & & \verb~                case 0:~\\
\cellcolor{green} & 1 & \verb~35~ & & \verb~                    Image = new Image(Path.Combine("Assets", "Images", "LifePickUp.png"));~\\
\cellcolor{green} & 1 & \verb~36~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~37~ & & \verb~                case 1:~\\
\cellcolor{green} & 2 & \verb~38~ & & \verb~                    Image = new Image(Path.Combine("Assets", "Images", "DoubleSpeedPowerUp.png"));~\\
\cellcolor{green} & 2 & \verb~39~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~40~ & & \verb~                case 2:~\\
\cellcolor{green} & 4 & \verb~41~ & & \verb~                    Image = new Image(Path.Combine("Assets", "Images", "SpeedPickUp.png"));~\\
\cellcolor{green} & 4 & \verb~42~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~43~ & & \verb~                case 3:~\\
\cellcolor{green} & 6 & \verb~44~ & & \verb~                    Image = new Image(Path.Combine("Assets", "Images", "hourglass.png"));~\\
\cellcolor{green} & 6 & \verb~45~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~46~ & & \verb~                case 4:~\\
\cellcolor{green} & 2 & \verb~47~ & & \verb~                    Image = new Image(Path.Combine("Assets", "Images", "WidePowerUp.png"));~\\
\cellcolor{green} & 2 & \verb~48~ & & \verb~                    break;~\\
\cellcolor{red} & 0 & \verb~49~ & & \verb~                default: break;~\\
\cellcolor{green} & 15 & \verb~50~ & & \verb~                };~\\
\cellcolor{green} & 15 & \verb~51~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~52~ & & \verb~~\\
\cellcolor{gray} &  & \verb~53~ & & \verb~~\\
\cellcolor{gray} &  & \verb~54~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~55~ & & \verb~        /// renders the powerupdrop.~\\
\cellcolor{gray} &  & \verb~56~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~57~ & & \verb~        public void Render() {~\\
\cellcolor{red} & 0 & \verb~58~ & & \verb~            this.RenderEntity();~\\
\cellcolor{red} & 0 & \verb~59~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~60~ & & \verb~~\\
\cellcolor{gray} &  & \verb~61~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~62~ & & \verb~        /// Moves the powerupdrop down.~\\
\cellcolor{gray} &  & \verb~63~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 703 & \verb~64~ & & \verb~        public void Move() {~\\
\cellcolor{green} & 703 & \verb~65~ & & \verb~            shape.Position += new Vec2F(shape.Direction.X, shape.Direction.Y) * new Vec2F(0.0f, Yvelocity);~\\
\cellcolor{green} & 703 & \verb~66~ & & \verb~            shape.Move();~\\
\cellcolor{green} & 703 & \verb~67~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~68~ & & \verb~~\\
\cellcolor{gray} &  & \verb~69~ & & \verb~~\\
\cellcolor{gray} &  & \verb~70~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~71~ & & \verb~        /// If there is collision bewteen player and the powerupdrop the appropriate powerup is~\\
\cellcolor{gray} &  & \verb~72~ & & \verb~        /// activated by calling Powerups functions that in turn creates an event.~\\
\cellcolor{gray} &  & \verb~73~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~74~ & & \verb~        /// <param name="player">The player to check collision with</param>~\\
\cellcolor{gray} &  & \verb~75~ & & \verb~        /// <param name="number">the number of the powerup, deciding what the powerup is</param>~\\
\cellcolor{green} & 702 & \verb~76~ & & \verb~        public void Consume(Player player, int number) {~\\
\cellcolor{green} & 709 & \verb~77~ & & \verb~            if (CollisionDetection.Aabb(shape, player.Shape).Collision) {~\\
\cellcolor{orange} & 7 & \verb~78~ & & \verb~                switch (number) {~\\
\cellcolor{gray} &  & \verb~79~ & & \verb~                    case 0:~\\
\cellcolor{red} & 0 & \verb~80~ & & \verb~                        pwUp.LifePowerUp();~\\
\cellcolor{red} & 0 & \verb~81~ & & \verb~                        break;~\\
\cellcolor{gray} &  & \verb~82~ & & \verb~                    case 1:~\\
\cellcolor{green} & 2 & \verb~83~ & & \verb~                        pwUp.DoubleSpeedPowerUp();~\\
\cellcolor{green} & 2 & \verb~84~ & & \verb~                        break;~\\
\cellcolor{gray} &  & \verb~85~ & & \verb~                    case 2:~\\
\cellcolor{green} & 1 & \verb~86~ & & \verb~                        pwUp.PlayerSpeedPowerUp();~\\
\cellcolor{green} & 1 & \verb~87~ & & \verb~                        break;~\\
\cellcolor{gray} &  & \verb~88~ & & \verb~                    case 3:~\\
\cellcolor{green} & 1 & \verb~89~ & & \verb~                        pwUp.MoreTimePowerUp();~\\
\cellcolor{green} & 1 & \verb~90~ & & \verb~                        break;~\\
\cellcolor{gray} &  & \verb~91~ & & \verb~                    case 4:~\\
\cellcolor{green} & 1 & \verb~92~ & & \verb~                        pwUp.WidePowerUp();~\\
\cellcolor{green} & 1 & \verb~93~ & & \verb~                        break;~\\
\cellcolor{green} & 2 & \verb~94~ & & \verb~                default: break;~\\
\cellcolor{gray} &  & \verb~95~ & & \verb~            }~\\
\cellcolor{green} & 7 & \verb~96~ & & \verb~                this.DeleteEntity();~\\
\cellcolor{green} & 7 & \verb~97~ & & \verb~            }~\\
\cellcolor{green} & 702 & \verb~98~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~99~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~100~ & & \verb~}~\\
\end{longtable}
\newpage
\section{Breakout.PowerUps}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Breakout.PowerUps\\
\textbf{Assembly:} & Breakout\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/magnus/Desktop/SU/DIKUGames/Breakout/GameElements/PowerUps.cs}\end{minipage} \\
\textbf{Covered lines:} & 35\\
\textbf{Uncovered lines:} & 0\\
\textbf{Coverable lines:} & 35\\
\textbf{Total lines:} & 70\\
\textbf{Line coverage:} & 100\% (35 of 35)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 0\\
\textbf{Covered methods:} & 5\\
\textbf{Total methods:} & 5\\
\textbf{Method coverage:} & 100\% (5 of 5)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{LifePowerUp()} & 100\% & 1 & 100\%\\
\hline
\textbf{WidePowerUp()} & 100\% & 1 & 100\%\\
\hline
\textbf{PlayerSpeedPowerUp()} & 100\% & 1 & 100\%\\
\hline
\textbf{DoubleSpeedPowerUp()} & 100\% & 1 & 100\%\\
\hline
\textbf{MoreTimePowerUp()} & 100\% & 1 & 100\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/magnus/Desktop/SU/DIKUGames/Breakout/GameElements/PowerUps.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.Graphics;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using DIKUArcade.Events;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~using DIKUArcade.Math;~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~namespace Breakout {~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~    ///  Contains the different methods which activates the specific powerups. Its methods are~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~    /// called in powerupdrops.~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~    public class PowerUps {~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~~\\
\cellcolor{gray} &  & \verb~15~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~        /// Creates an event that is caught by player to increase life~\\
\cellcolor{gray} &  & \verb~17~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 2 & \verb~18~ & & \verb~        public void LifePowerUp() {~\\
\cellcolor{green} & 2 & \verb~19~ & & \verb~            BreakoutBus.GetBus().RegisterEvent (~\\
\cellcolor{green} & 2 & \verb~20~ & & \verb~                new GameEvent {~\\
\cellcolor{green} & 2 & \verb~21~ & & \verb~                    EventType = GameEventType.PlayerEvent,~\\
\cellcolor{green} & 2 & \verb~22~ & & \verb~                    Message = "IncLife"~\\
\cellcolor{green} & 2 & \verb~23~ & & \verb~            });~\\
\cellcolor{green} & 2 & \verb~24~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~25~ & & \verb~~\\
\cellcolor{gray} &  & \verb~26~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~        /// Creates an event that is caught by player to increase width~\\
\cellcolor{gray} &  & \verb~28~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 3 & \verb~29~ & & \verb~        public void WidePowerUp() {~\\
\cellcolor{green} & 3 & \verb~30~ & & \verb~            BreakoutBus.GetBus().RegisterEvent (~\\
\cellcolor{green} & 3 & \verb~31~ & & \verb~                new GameEvent {~\\
\cellcolor{green} & 3 & \verb~32~ & & \verb~                    EventType = GameEventType.PlayerEvent,~\\
\cellcolor{green} & 3 & \verb~33~ & & \verb~                    Message = "IncWidth"~\\
\cellcolor{green} & 3 & \verb~34~ & & \verb~            });~\\
\cellcolor{green} & 3 & \verb~35~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~36~ & & \verb~~\\
\cellcolor{gray} &  & \verb~37~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~38~ & & \verb~        /// Creates an event that is caught by player to increase speed~\\
\cellcolor{gray} &  & \verb~39~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 3 & \verb~40~ & & \verb~        public void PlayerSpeedPowerUp() {~\\
\cellcolor{green} & 3 & \verb~41~ & & \verb~            BreakoutBus.GetBus().RegisterEvent (~\\
\cellcolor{green} & 3 & \verb~42~ & & \verb~                new GameEvent {~\\
\cellcolor{green} & 3 & \verb~43~ & & \verb~                    EventType = GameEventType.PlayerEvent,~\\
\cellcolor{green} & 3 & \verb~44~ & & \verb~                    Message = "IncSpeed"~\\
\cellcolor{green} & 3 & \verb~45~ & & \verb~            });~\\
\cellcolor{green} & 3 & \verb~46~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~47~ & & \verb~~\\
\cellcolor{gray} &  & \verb~48~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~49~ & & \verb~        /// Creates an event that is caught by ball to increase speed~\\
\cellcolor{gray} &  & \verb~50~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 4 & \verb~51~ & & \verb~        public void DoubleSpeedPowerUp() {~\\
\cellcolor{green} & 4 & \verb~52~ & & \verb~            BreakoutBus.GetBus().RegisterEvent (~\\
\cellcolor{green} & 4 & \verb~53~ & & \verb~                new GameEvent {~\\
\cellcolor{green} & 4 & \verb~54~ & & \verb~                    EventType = GameEventType.InputEvent,~\\
\cellcolor{green} & 4 & \verb~55~ & & \verb~                    Message = "IncSpeed"~\\
\cellcolor{green} & 4 & \verb~56~ & & \verb~            });~\\
\cellcolor{green} & 4 & \verb~57~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~58~ & & \verb~~\\
\cellcolor{gray} &  & \verb~59~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~60~ & & \verb~        /// Creates an event that is caught by gamerunning to increase time by 10~\\
\cellcolor{gray} &  & \verb~61~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 3 & \verb~62~ & & \verb~        public void MoreTimePowerUp() {~\\
\cellcolor{green} & 3 & \verb~63~ & & \verb~            BreakoutBus.GetBus().RegisterEvent (~\\
\cellcolor{green} & 3 & \verb~64~ & & \verb~                new GameEvent {~\\
\cellcolor{green} & 3 & \verb~65~ & & \verb~                    EventType = GameEventType.StatusEvent,~\\
\cellcolor{green} & 3 & \verb~66~ & & \verb~                    Message = "IncTime"~\\
\cellcolor{green} & 3 & \verb~67~ & & \verb~            });~\\
\cellcolor{green} & 3 & \verb~68~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~69~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~70~ & & \verb~}~\\
\end{longtable}
\newpage
\section{Breakout.Program}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Breakout.Program\\
\textbf{Assembly:} & Breakout\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/magnus/Desktop/SU/DIKUGames/Breakout/Program.cs}\end{minipage} \\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 5\\
\textbf{Coverable lines:} & 5\\
\textbf{Total lines:} & 15\\
\textbf{Line coverage:} & 0\% (0 of 5)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 0\\
\textbf{Covered methods:} & 0\\
\textbf{Total methods:} & 1\\
\textbf{Method coverage:} & 0\% (0 of 1)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{Main(...)} & 100\% & 1 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/magnus/Desktop/SU/DIKUGames/Breakout/Program.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using System;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.GUI;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~namespace Breakout~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~{~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~    class Program~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~    {~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~        static void Main(string[] args)~\\
\cellcolor{red} & 0 & \verb~9~ & & \verb~        {~\\
\cellcolor{red} & 0 & \verb~10~ & & \verb~            var windowArgs = new WindowArgs() { Title = "Breakout v0.1" };~\\
\cellcolor{red} & 0 & \verb~11~ & & \verb~            var game = new Game(windowArgs);~\\
\cellcolor{red} & 0 & \verb~12~ & & \verb~            game.Run();~\\
\cellcolor{red} & 0 & \verb~13~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~15~ & & \verb~}~\\
\end{longtable}
\newpage
\section{Breakout.UnbreakableBlock}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Breakout.UnbreakableBlock\\
\textbf{Assembly:} & Breakout\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/magnus/Desktop/SU/DIKUGames/Breakout/Blocks/UnbreakableBlock.cs}\end{minipage} \\
\textbf{Covered lines:} & 18\\
\textbf{Uncovered lines:} & 9\\
\textbf{Coverable lines:} & 27\\
\textbf{Total lines:} & 76\\
\textbf{Line coverage:} & 66.6\% (18 of 27)\\
\textbf{Covered branches:} & 3\\
\textbf{Total branches:} & 4\\
\textbf{Branch coverage:} & 75\% (3 of 4)\\
\textbf{Covered methods:} & 5\\
\textbf{Total methods:} & 8\\
\textbf{Method coverage:} & 62.5\% (5 of 8)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 100\%\\
\hline
\textbf{GetHealth()} & 100\% & 1 & 100\%\\
\hline
\textbf{DecHealth()} & 100\% & 1 & 100\%\\
\hline
\textbf{GetValue()} & 100\% & 1 & 0\%\\
\hline
\textbf{SetValue(...)} & 100\% & 1 & 100\%\\
\hline
\textbf{GetPosition()} & 100\% & 1 & 0\%\\
\hline
\textbf{IsPowerUp()} & 100\% & 1 & 0\%\\
\hline
\textbf{ProcessEvent(...)} & 75.00\% & 4 & 100\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/magnus/Desktop/SU/DIKUGames/Breakout/Blocks/UnbreakableBlock.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.Graphics;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using DIKUArcade.Events;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~using DIKUArcade.Math;~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~namespace Breakout {~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~    ///  This class represents Unbreakable Blocks. The DecHealth method does nothing, as such~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~    ///  it cannot be destroyed.~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~    public class UnbreakableBlock : Block {~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~~\\
\cellcolor{gray} &  & \verb~15~ & & \verb~        private int health;~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~        private int value;~\\
\cellcolor{gray} &  & \verb~17~ & & \verb~~\\
\cellcolor{green} & 14 & \verb~18~ & & \verb~        public UnbreakableBlock(Shape shape, IBaseImage image) : base(shape, image) {~\\
\cellcolor{green} & 7 & \verb~19~ & & \verb~            this.shape = shape;~\\
\cellcolor{green} & 7 & \verb~20~ & & \verb~            health = 100;~\\
\cellcolor{green} & 7 & \verb~21~ & & \verb~            value = 1;~\\
\cellcolor{green} & 7 & \verb~22~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~~\\
\cellcolor{gray} &  & \verb~24~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~25~ & & \verb~        /// Returns the health of the block.~\\
\cellcolor{gray} &  & \verb~26~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~        /// <returns> int health field</returns>~\\
\cellcolor{green} & 1 & \verb~28~ & & \verb~        public override int GetHealth() {~\\
\cellcolor{green} & 1 & \verb~29~ & & \verb~            return health;~\\
\cellcolor{green} & 1 & \verb~30~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~31~ & & \verb~~\\
\cellcolor{gray} &  & \verb~32~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~33~ & & \verb~        /// Does nothing, because unbreakable blocks cannot loose health.~\\
\cellcolor{gray} &  & \verb~34~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 1 & \verb~35~ & & \verb~        public override void DecHealth () {~\\
\cellcolor{green} & 1 & \verb~36~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~37~ & & \verb~~\\
\cellcolor{gray} &  & \verb~38~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~39~ & & \verb~        /// Returns the value field.~\\
\cellcolor{gray} &  & \verb~40~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~41~ & & \verb~        /// <returns></returns>~\\
\cellcolor{red} & 0 & \verb~42~ & & \verb~        public override int GetValue() {~\\
\cellcolor{red} & 0 & \verb~43~ & & \verb~            return value;~\\
\cellcolor{red} & 0 & \verb~44~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~45~ & & \verb~~\\
\cellcolor{gray} &  & \verb~46~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~47~ & & \verb~        /// sets the value field to amount.~\\
\cellcolor{gray} &  & \verb~48~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~49~ & & \verb~        /// <param name="amount">what to set value field to</param>~\\
\cellcolor{green} & 2 & \verb~50~ & & \verb~        public override void SetValue(int amount) {~\\
\cellcolor{green} & 2 & \verb~51~ & & \verb~            value = amount;~\\
\cellcolor{green} & 2 & \verb~52~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~53~ & & \verb~~\\
\cellcolor{gray} &  & \verb~54~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~55~ & & \verb~        /// gets the position of the shape of the Block~\\
\cellcolor{gray} &  & \verb~56~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~57~ & & \verb~        /// <returns></returns>~\\
\cellcolor{red} & 0 & \verb~58~ & & \verb~        public override Vec2F GetPosition() {~\\
\cellcolor{red} & 0 & \verb~59~ & & \verb~            return shape.Position;~\\
\cellcolor{red} & 0 & \verb~60~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~61~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~62~ & & \verb~        public override bool IsPowerUp() {~\\
\cellcolor{red} & 0 & \verb~63~ & & \verb~            return false;~\\
\cellcolor{red} & 0 & \verb~64~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~65~ & & \verb~~\\
\cellcolor{gray} &  & \verb~66~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~67~ & & \verb~        /// processes a gameEvent~\\
\cellcolor{gray} &  & \verb~68~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~69~ & & \verb~        /// <param name="gameEvent">the gameEvent to process</param>~\\
\cellcolor{green} & 1 & \verb~70~ & & \verb~        public override void ProcessEvent(GameEvent gameEvent){~\\
\cellcolor{orange} & 2 & \verb~71~ & & \verb~            if (gameEvent.EventType == GameEventType.InputEvent && gameEvent.IntArg1 == value) { //Checks if it a InputE~\\
\cellcolor{green} & 1 & \verb~72~ & & \verb~                DecHealth();~\\
\cellcolor{green} & 1 & \verb~73~ & & \verb~            }~\\
\cellcolor{green} & 1 & \verb~74~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~75~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~76~ & & \verb~}~\\
\end{longtable}
\newpage
\section{Points}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & Points\\
\textbf{Assembly:} & Breakout\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/magnus/Desktop/SU/DIKUGames/Breakout/GameElements/Points.cs}\end{minipage} \\
\textbf{Covered lines:} & 14\\
\textbf{Uncovered lines:} & 9\\
\textbf{Coverable lines:} & 23\\
\textbf{Total lines:} & 61\\
\textbf{Line coverage:} & 60.8\% (14 of 23)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 2\\
\textbf{Branch coverage:} & 0\% (0 of 2)\\
\textbf{Covered methods:} & 4\\
\textbf{Total methods:} & 6\\
\textbf{Method coverage:} & 66.6\% (4 of 6)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 100\%\\
\hline
\textbf{AddPoints(...)} & 100\% & 1 & 100\%\\
\hline
\textbf{RenderPoints()} & 100\% & 1 & 0\%\\
\hline
\textbf{ResetPoints()} & 100\% & 1 & 100\%\\
\hline
\textbf{GetPoints()} & 100\% & 1 & 100\%\\
\hline
\textbf{ProcessEvent(...)} & 0\% & 2 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/magnus/Desktop/SU/DIKUGames/Breakout/GameElements/Points.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.Graphics;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using DIKUArcade.Events;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~using DIKUArcade.Math;~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~public class Points : IGameEventProcessor {~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~    ///  This class represents the points. Increasing points and rendering them.~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~    private int points;~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~    private Text display;~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~~\\
\cellcolor{green} & 14 & \verb~15~ & & \verb~    public Points (Vec2F position, Vec2F extent) {~\\
\cellcolor{green} & 7 & \verb~16~ & & \verb~        points = 0;~\\
\cellcolor{green} & 7 & \verb~17~ & & \verb~        display = new Text ("Points: " + points.ToString(), position, extent);~\\
\cellcolor{green} & 7 & \verb~18~ & & \verb~        display.SetColor(new Vec3I(255, 0, 0));~\\
\cellcolor{green} & 7 & \verb~19~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~        /// increments the point field.~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 4 & \verb~24~ & & \verb~        public void AddPoints(int s) {~\\
\cellcolor{green} & 4 & \verb~25~ & & \verb~            points = points + s;~\\
\cellcolor{green} & 4 & \verb~26~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~~\\
\cellcolor{gray} &  & \verb~28~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~29~ & & \verb~        /// renders the score on the board.~\\
\cellcolor{gray} &  & \verb~30~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~31~ & & \verb~        public void RenderPoints () {~\\
\cellcolor{red} & 0 & \verb~32~ & & \verb~            display.SetText("Points: " + points.ToString());~\\
\cellcolor{red} & 0 & \verb~33~ & & \verb~            display.RenderText();~\\
\cellcolor{red} & 0 & \verb~34~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~35~ & & \verb~~\\
\cellcolor{gray} &  & \verb~36~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~37~ & & \verb~        /// Resets score to 0~\\
\cellcolor{gray} &  & \verb~38~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 16 & \verb~39~ & & \verb~        public void ResetPoints() {~\\
\cellcolor{green} & 16 & \verb~40~ & & \verb~            points = 0;~\\
\cellcolor{green} & 16 & \verb~41~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~42~ & & \verb~~\\
\cellcolor{gray} &  & \verb~43~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~44~ & & \verb~        /// Returns the score field~\\
\cellcolor{gray} &  & \verb~45~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~46~ & & \verb~        /// <returns>the score field</returns>~\\
\cellcolor{green} & 17 & \verb~47~ & & \verb~        public int GetPoints() {~\\
\cellcolor{green} & 17 & \verb~48~ & & \verb~            return points;~\\
\cellcolor{green} & 17 & \verb~49~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~50~ & & \verb~~\\
\cellcolor{gray} &  & \verb~51~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~52~ & & \verb~        /// processes a gameEvent~\\
\cellcolor{gray} &  & \verb~53~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~54~ & & \verb~        /// <param name="gameEvent">the gameEvent to process</param>~\\
\cellcolor{red} & 0 & \verb~55~ & & \verb~        public void ProcessEvent(GameEvent gameEvent){~\\
\cellcolor{red} & 0 & \verb~56~ & & \verb~            if (gameEvent.EventType == GameEventType.GraphicsEvent) {~\\
\cellcolor{red} & 0 & \verb~57~ & & \verb~                AddPoints(gameEvent.IntArg1);~\\
\cellcolor{red} & 0 & \verb~58~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~59~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~60~ & & \verb~~\\
\cellcolor{gray} &  & \verb~61~ & & \verb~}~\\
\end{longtable}
\newpage
\section{StateTransformer}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & StateTransformer\\
\textbf{Assembly:} & Breakout\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{me/magnus/Desktop/SU/DIKUGames/Breakout/GameStateMachinery/StateTransformer.cs}\end{minipage} \\
\textbf{Covered lines:} & 24\\
\textbf{Uncovered lines:} & 0\\
\textbf{Coverable lines:} & 24\\
\textbf{Total lines:} & 52\\
\textbf{Line coverage:} & 100\% (24 of 24)\\
\textbf{Covered branches:} & 16\\
\textbf{Total branches:} & 16\\
\textbf{Branch coverage:} & 100\% (16 of 16)\\
\textbf{Covered methods:} & 2\\
\textbf{Total methods:} & 2\\
\textbf{Method coverage:} & 100\% (2 of 2)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{TransformStringToSta} & 100\% & 10 & 100\%\\
\hline
\textbf{TransformStateToStri} & 100\% & 6 & 100\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{me/magnus/Desktop/SU/DIKUGames/Breakout/GameStateMachinery/StateTransformer.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using System;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~/// <summary>~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~    ///  This class transforms strings to states and states to strings.~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~public class StateTransformer {~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~    /// Transform a string to a state~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~    /// <param name="state">The string to transform</param>~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~    /// <returns></returns>~\\
\cellcolor{green} & 7 & \verb~12~ & & \verb~    public static GameStateType TransformStringToState(string state) {~\\
\cellcolor{green} & 9 & \verb~13~ & & \verb~        if (state == "GAME_RUNNING") {~\\
\cellcolor{green} & 2 & \verb~14~ & & \verb~            return GameStateType.GameRunning;~\\
\cellcolor{gray} &  & \verb~15~ & & \verb~        }~\\
\cellcolor{green} & 6 & \verb~16~ & & \verb~        else if (state == "GAME_PAUSED") {~\\
\cellcolor{green} & 1 & \verb~17~ & & \verb~            return GameStateType.GamePaused;~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~        }~\\
\cellcolor{green} & 5 & \verb~19~ & & \verb~        else if (state == "MAIN_MENU") {~\\
\cellcolor{green} & 1 & \verb~20~ & & \verb~            return GameStateType.MainMenu;~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~        }~\\
\cellcolor{green} & 4 & \verb~22~ & & \verb~        else if (state == "GAME_LOST") {~\\
\cellcolor{green} & 1 & \verb~23~ & & \verb~            return GameStateType.GameLost;~\\
\cellcolor{gray} &  & \verb~24~ & & \verb~        }~\\
\cellcolor{green} & 3 & \verb~25~ & & \verb~        else if (state == "GAME_WON") {~\\
\cellcolor{green} & 1 & \verb~26~ & & \verb~            return GameStateType.GameWon;~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~        }~\\
\cellcolor{green} & 1 & \verb~28~ & & \verb~        else {~\\
\cellcolor{green} & 1 & \verb~29~ & & \verb~            throw new ArgumentException("Invalid input");~\\
\cellcolor{gray} &  & \verb~30~ & & \verb~        }~\\
\cellcolor{green} & 6 & \verb~31~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~32~ & & \verb~~\\
\cellcolor{gray} &  & \verb~33~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~34~ & & \verb~    /// Transforms a state to a string~\\
\cellcolor{gray} &  & \verb~35~ & & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~36~ & & \verb~    /// <param name="state">the state to transform</param>~\\
\cellcolor{gray} &  & \verb~37~ & & \verb~    /// <returns></returns>~\\
\cellcolor{green} & 4 & \verb~38~ & & \verb~    public static string TransformStateToString (GameStateType state) {~\\
\cellcolor{green} & 5 & \verb~39~ & & \verb~        if (state == GameStateType.GameRunning) {~\\
\cellcolor{green} & 1 & \verb~40~ & & \verb~            return "GAME_RUNNING";~\\
\cellcolor{gray} &  & \verb~41~ & & \verb~        }~\\
\cellcolor{green} & 4 & \verb~42~ & & \verb~        else if (state == GameStateType.GamePaused) {~\\
\cellcolor{green} & 1 & \verb~43~ & & \verb~            return "GAME_PAUSED";~\\
\cellcolor{gray} &  & \verb~44~ & & \verb~        }~\\
\cellcolor{green} & 3 & \verb~45~ & & \verb~        else if (state == GameStateType.MainMenu) {~\\
\cellcolor{green} & 1 & \verb~46~ & & \verb~            return "MAIN_MENU";~\\
\cellcolor{gray} &  & \verb~47~ & & \verb~        }~\\
\cellcolor{green} & 1 & \verb~48~ & & \verb~        else {~\\
\cellcolor{green} & 1 & \verb~49~ & & \verb~            throw new ArgumentException("Invalid state");~\\
\cellcolor{gray} &  & \verb~50~ & & \verb~        }~\\
\cellcolor{green} & 3 & \verb~51~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~52~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.DIKUGame}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.DIKUGame\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/DIKUGame.cs}\end{minipage} \\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 30\\
\textbf{Coverable lines:} & 30\\
\textbf{Total lines:} & 68\\
\textbf{Line coverage:} & 0\% (0 of 30)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 8\\
\textbf{Branch coverage:} & 0\% (0 of 8)\\
\textbf{Covered methods:} & 0\\
\textbf{Total methods:} & 2\\
\textbf{Method coverage:} & 0\% (0 of 2)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{Run()} & 0\% & 8 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/DIKUGame.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using System;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.GUI;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using DIKUArcade.Input;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~using DIKUArcade.Timers;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~namespace DIKUArcade {~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~    /// Abstract base class for any DIKUArcade game.~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~    public abstract class DIKUGame {~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~        protected Window window;~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~        private GameTimer gameTimer;~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~14~ & & \verb~        public DIKUGame(WindowArgs windowArgs) {~\\
\cellcolor{red} & 0 & \verb~15~ & & \verb~            window = new Window(windowArgs);~\\
\cellcolor{red} & 0 & \verb~16~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~17~ & & \verb~~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~19~ & & \verb~        /// Override this method to update game logic.~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~        public abstract void Update();~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~24~ & & \verb~        /// Override this method to render game entities.~\\
\cellcolor{gray} &  & \verb~25~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~26~ & & \verb~        public abstract void Render();~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~~\\
\cellcolor{gray} &  & \verb~28~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~29~ & & \verb~        /// Enter the game loop and run the game.~\\
\cellcolor{gray} &  & \verb~30~ & & \verb~        /// This method will never return.~\\
\cellcolor{gray} &  & \verb~31~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~32~ & & \verb~        public void Run() {~\\
\cellcolor{red} & 0 & \verb~33~ & & \verb~            System.Console.WriteLine("Game.Run()");~\\
\cellcolor{red} & 0 & \verb~34~ & & \verb~            gameTimer = new GameTimer(30, 30);~\\
\cellcolor{gray} &  & \verb~35~ & & \verb~~\\
\cellcolor{gray} &  & \verb~36~ & & \verb~            try~\\
\cellcolor{red} & 0 & \verb~37~ & & \verb~            {~\\
\cellcolor{red} & 0 & \verb~38~ & & \verb~                while (window.IsRunning()) {~\\
\cellcolor{red} & 0 & \verb~39~ & & \verb~                    gameTimer.MeasureTime();~\\
\cellcolor{red} & 0 & \verb~40~ & & \verb~                    window.PollEvents();~\\
\cellcolor{gray} &  & \verb~41~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~42~ & & \verb~                    while (gameTimer.ShouldUpdate()) {~\\
\cellcolor{red} & 0 & \verb~43~ & & \verb~                        Update();~\\
\cellcolor{red} & 0 & \verb~44~ & & \verb~                    }~\\
\cellcolor{gray} &  & \verb~45~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~46~ & & \verb~                    if (gameTimer.ShouldRender()) {~\\
\cellcolor{red} & 0 & \verb~47~ & & \verb~                        window.Clear();~\\
\cellcolor{red} & 0 & \verb~48~ & & \verb~                        Render();~\\
\cellcolor{red} & 0 & \verb~49~ & & \verb~                        window.SwapBuffers();~\\
\cellcolor{red} & 0 & \verb~50~ & & \verb~                    }~\\
\cellcolor{gray} &  & \verb~51~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~52~ & & \verb~                    if (gameTimer.ShouldReset()) {~\\
\cellcolor{gray} &  & \verb~53~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~54~ & & \verb~                    }~\\
\cellcolor{red} & 0 & \verb~55~ & & \verb~                }~\\
\cellcolor{gray} &  & \verb~56~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~57~ & & \verb~                window.DestroyWindow();~\\
\cellcolor{red} & 0 & \verb~58~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~59~ & & \verb~            catch(Exception ex) {~\\
\cellcolor{red} & 0 & \verb~60~ & & \verb~                Console.WriteLine("DIKUArcade.DIKUGame caught an exception. See message below:" + Environment.NewLine);~\\
\cellcolor{red} & 0 & \verb~61~ & & \verb~                Console.WriteLine(ex);~\\
\cellcolor{gray} &  & \verb~62~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~63~ & & \verb~                Console.WriteLine(Environment.NewLine + "Terminating program...");~\\
\cellcolor{red} & 0 & \verb~64~ & & \verb~                Environment.Exit(1);~\\
\cellcolor{red} & 0 & \verb~65~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~66~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~67~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~68~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Entities.DynamicShape}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Entities.DynamicShape\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{ome/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Entities/DynamicShape.cs}\end{minipage} \\
\textbf{Covered lines:} & 8\\
\textbf{Uncovered lines:} & 20\\
\textbf{Coverable lines:} & 28\\
\textbf{Total lines:} & 51\\
\textbf{Line coverage:} & 28.5\% (8 of 28)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 0\\
\textbf{Covered methods:} & 2\\
\textbf{Total methods:} & 7\\
\textbf{Method coverage:} & 28.5\% (2 of 7)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 100\%\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{ChangeDirection(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{Move()} & 100\% & 1 & 100\%\\
\hline
\textbf{op\_Explicit(...)} & 100\% & 1 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{ome/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Entities/DynamicShape.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Math;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~namespace DIKUArcade.Entities {~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~    public class DynamicShape : Shape {~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~        /// Only dynamic entities carry a direction vector.~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~        public Vec2F Direction;~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~10~ & & \verb~        public DynamicShape(float posX, float posY, float width, float height) {~\\
\cellcolor{red} & 0 & \verb~11~ & & \verb~            Position = new Vec2F(posX, posY);~\\
\cellcolor{red} & 0 & \verb~12~ & & \verb~            Direction = new Vec2F();~\\
\cellcolor{red} & 0 & \verb~13~ & & \verb~            Extent = new Vec2F(width, height);~\\
\cellcolor{red} & 0 & \verb~14~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~15~ & & \verb~~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~        public DynamicShape(float posX, float posY, float width, float height,~\\
\cellcolor{red} & 0 & \verb~17~ & & \verb~            float dirX, float dirY) : this(posX, posY, width, height) {~\\
\cellcolor{red} & 0 & \verb~18~ & & \verb~            Direction.X = dirX;~\\
\cellcolor{red} & 0 & \verb~19~ & & \verb~            Direction.Y = dirY;~\\
\cellcolor{red} & 0 & \verb~20~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~~\\
\cellcolor{green} & 610 & \verb~22~ & & \verb~        public DynamicShape(Vec2F pos, Vec2F extent) {~\\
\cellcolor{green} & 305 & \verb~23~ & & \verb~            Position = pos;~\\
\cellcolor{green} & 305 & \verb~24~ & & \verb~            Extent = extent;~\\
\cellcolor{green} & 305 & \verb~25~ & & \verb~            Direction = new Vec2F(0f, 0f); // init 0 to avoid problems~\\
\cellcolor{green} & 305 & \verb~26~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~28~ & & \verb~        public DynamicShape(Vec2F pos, Vec2F extent, Vec2F dir) {~\\
\cellcolor{red} & 0 & \verb~29~ & & \verb~            Position = pos;~\\
\cellcolor{red} & 0 & \verb~30~ & & \verb~            Extent = extent;~\\
\cellcolor{red} & 0 & \verb~31~ & & \verb~            Direction = dir;~\\
\cellcolor{red} & 0 & \verb~32~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~33~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~34~ & & \verb~        public void ChangeDirection(Vec2F dir) {~\\
\cellcolor{red} & 0 & \verb~35~ & & \verb~            Direction = dir;~\\
\cellcolor{red} & 0 & \verb~36~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~37~ & & \verb~~\\
\cellcolor{gray} &  & \verb~38~ & & \verb~~\\
\cellcolor{gray} &  & \verb~39~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~40~ & & \verb~        /// Overrides the default Shape.Move() method to add~\\
\cellcolor{gray} &  & \verb~41~ & & \verb~        /// this object's direction to its position.~\\
\cellcolor{gray} &  & \verb~42~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 763 & \verb~43~ & & \verb~        public override void Move() {~\\
\cellcolor{green} & 763 & \verb~44~ & & \verb~            Position += Direction;~\\
\cellcolor{green} & 763 & \verb~45~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~46~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~47~ & & \verb~        public static explicit operator StationaryShape(DynamicShape obj) {~\\
\cellcolor{red} & 0 & \verb~48~ & & \verb~            return new StationaryShape(obj.Position, obj.Extent);~\\
\cellcolor{red} & 0 & \verb~49~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~50~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~51~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Entities.Entity}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Entities.Entity\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Entities/Entity.cs}\end{minipage} \\
\textbf{Covered lines:} & 13\\
\textbf{Uncovered lines:} & 6\\
\textbf{Coverable lines:} & 19\\
\textbf{Total lines:} & 40\\
\textbf{Line coverage:} & 68.4\% (13 of 19)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 0\\
\textbf{Covered methods:} & 5\\
\textbf{Total methods:} & 7\\
\textbf{Method coverage:} & 71.4\% (5 of 7)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{get\_Shape()} & 100\% & 1 & 100\%\\
\hline
\textbf{get\_Image()} & 100\% & 1 & 100\%\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 100\%\\
\hline
\textbf{DeleteEntity()} & 100\% & 1 & 100\%\\
\hline
\textbf{IsDeleted()} & 100\% & 1 & 100\%\\
\hline
\textbf{RenderEntity()} & 100\% & 1 & 0\%\\
\hline
\textbf{RenderEntity(...)} & 100\% & 1 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Entities/Entity.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Graphics;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~namespace DIKUArcade.Entities {~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~    public class Entity {~\\
\cellcolor{green} & 1297 & \verb~5~ & & \verb~        public Shape Shape { get; set; }~\\
\cellcolor{green} & 453 & \verb~6~ & & \verb~        public IBaseImage Image { get; set; }~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~        private bool isDeleted;~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~~\\
\cellcolor{green} & 868 & \verb~10~ & & \verb~        public Entity(Shape shape, IBaseImage image) {~\\
\cellcolor{green} & 434 & \verb~11~ & & \verb~            isDeleted = false;~\\
\cellcolor{green} & 434 & \verb~12~ & & \verb~            Shape = shape;~\\
\cellcolor{green} & 434 & \verb~13~ & & \verb~            Image = image;~\\
\cellcolor{green} & 434 & \verb~14~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~15~ & & \verb~~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~17~ & & \verb~        /// Make an Entity as ready for being deleted.~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~        /// This functionality is needed for the EntityContainer class.~\\
\cellcolor{gray} &  & \verb~19~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 49 & \verb~20~ & & \verb~        public void DeleteEntity() {~\\
\cellcolor{green} & 49 & \verb~21~ & & \verb~            isDeleted = true;~\\
\cellcolor{green} & 49 & \verb~22~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~~\\
\cellcolor{gray} &  & \verb~24~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~25~ & & \verb~        /// Check if this Entity has been marked as ready for being deleted.~\\
\cellcolor{gray} &  & \verb~26~ & & \verb~        /// This functionality is needed for the EntityContainer class.~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 83 & \verb~28~ & & \verb~        public bool IsDeleted() {~\\
\cellcolor{green} & 83 & \verb~29~ & & \verb~            return isDeleted;~\\
\cellcolor{green} & 83 & \verb~30~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~31~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~32~ & & \verb~        public void RenderEntity() {~\\
\cellcolor{red} & 0 & \verb~33~ & & \verb~            Image.Render(Shape);~\\
\cellcolor{red} & 0 & \verb~34~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~35~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~36~ & & \verb~        public void RenderEntity(Camera camera) {~\\
\cellcolor{red} & 0 & \verb~37~ & & \verb~            Image.Render(Shape);~\\
\cellcolor{red} & 0 & \verb~38~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~39~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~40~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Entities.EntityContainer}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Entities.EntityContainer\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Entities/EntityContainer.cs}\end{minipage} \\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 63\\
\textbf{Coverable lines:} & 63\\
\textbf{Total lines:} & 132\\
\textbf{Line coverage:} & 0\% (0 of 63)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 10\\
\textbf{Branch coverage:} & 0\% (0 of 10)\\
\textbf{Covered methods:} & 0\\
\textbf{Total methods:} & 16\\
\textbf{Method coverage:} & 0\% (0 of 16)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{.ctor()} & 100\% & 1 & 0\%\\
\hline
\textbf{AddStationaryEntity(} & 100\% & 1 & 0\%\\
\hline
\textbf{AddDynamicEntity(...} & 100\% & 1 & 0\%\\
\hline
\textbf{Iterate(...)} & 0\% & 6 & 0\%\\
\hline
\textbf{RenderEntities()} & 0\% & 2 & 0\%\\
\hline
\textbf{RenderEntities(...)} & 0\% & 2 & 0\%\\
\hline
\textbf{ClearContainer()} & 100\% & 1 & 0\%\\
\hline
\textbf{CountEntities()} & 100\% & 1 & 0\%\\
\hline
\textbf{System.Collections.I} & 100\% & 1 & 0\%\\
\hline
\textbf{GetEnumerator()} & 100\% & 1 & 0\%\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{MoveNext()} & 100\% & 1 & 0\%\\
\hline
\textbf{Reset()} & 100\% & 1 & 0\%\\
\hline
\textbf{System.Collections.I} & 100\% & 1 & 0\%\\
\hline
\textbf{get\_Current()} & 100\% & 1 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Entities/EntityContainer.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using System;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using System.Collections;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~using System.Collections.ObjectModel;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~using DIKUArcade.Graphics;~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~namespace DIKUArcade.Entities {~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~    public class EntityContainer : IEnumerable {~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~        private List<Entity> entities;~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~11~ & & \verb~        public EntityContainer(int size) {~\\
\cellcolor{red} & 0 & \verb~12~ & & \verb~            entities = new List<Entity>(size);~\\
\cellcolor{red} & 0 & \verb~13~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~15~ & & \verb~        public EntityContainer() : this(50) { }~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~17~ & & \verb~        public void AddStationaryEntity(StationaryShape ent, IBaseImage img) {~\\
\cellcolor{red} & 0 & \verb~18~ & & \verb~            entities.Add(new Entity(ent, img));~\\
\cellcolor{red} & 0 & \verb~19~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~21~ & & \verb~        public void AddDynamicEntity(DynamicShape ent, IBaseImage img) {~\\
\cellcolor{red} & 0 & \verb~22~ & & \verb~            entities.Add(new Entity(ent, img));~\\
\cellcolor{red} & 0 & \verb~23~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~24~ & & \verb~~\\
\cellcolor{gray} &  & \verb~25~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~26~ & & \verb~        /// Delegate method for iterating through an EntityContainer.~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~        /// This function should return true if the Entity should be~\\
\cellcolor{gray} &  & \verb~28~ & & \verb~        /// removed from the EntityContainer.~\\
\cellcolor{gray} &  & \verb~29~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~30~ & & \verb~        /// <param name="entity"></param>~\\
\cellcolor{gray} &  & \verb~31~ & & \verb~        public delegate void IteratorMethod(Entity entity);~\\
\cellcolor{gray} &  & \verb~32~ & & \verb~~\\
\cellcolor{gray} &  & \verb~33~ & & \verb~        /// <summary>Iterate through all Entities in this EntityContainer.</summary>~\\
\cellcolor{gray} &  & \verb~34~ & & \verb~        /// <remarks>This method can modify objects during iteration!~\\
\cellcolor{gray} &  & \verb~35~ & & \verb~        /// If this functionality is undesired, iterate then through this~\\
\cellcolor{gray} &  & \verb~36~ & & \verb~        /// EntityContainer using a 'foreach'-loop (from IEnumerable).</remarks>~\\
\cellcolor{red} & 0 & \verb~37~ & & \verb~        public void Iterate(IteratorMethod iterator) {~\\
\cellcolor{red} & 0 & \verb~38~ & & \verb~            var count = entities.Count;~\\
\cellcolor{red} & 0 & \verb~39~ & & \verb~            var newList = new List<Entity>(count);~\\
\cellcolor{gray} &  & \verb~40~ & & \verb~~\\
\cellcolor{gray} &  & \verb~41~ & & \verb~            // iterate through entities~\\
\cellcolor{red} & 0 & \verb~42~ & & \verb~            for (int i = 0; i < count; i++) {~\\
\cellcolor{red} & 0 & \verb~43~ & & \verb~                iterator(entities[i]);~\\
\cellcolor{red} & 0 & \verb~44~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~45~ & & \verb~~\\
\cellcolor{gray} &  & \verb~46~ & & \verb~            // keep Entities that have not been marked for deletion during iteration~\\
\cellcolor{red} & 0 & \verb~47~ & & \verb~            foreach (var entity in entities) {~\\
\cellcolor{red} & 0 & \verb~48~ & & \verb~                if (!entity.IsDeleted()) {~\\
\cellcolor{red} & 0 & \verb~49~ & & \verb~                    newList.Add(entity);~\\
\cellcolor{red} & 0 & \verb~50~ & & \verb~                }~\\
\cellcolor{red} & 0 & \verb~51~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~52~ & & \verb~            entities = newList;~\\
\cellcolor{red} & 0 & \verb~53~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~54~ & & \verb~~\\
\cellcolor{gray} &  & \verb~55~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~56~ & & \verb~        /// Render all entities in this EntityContainer~\\
\cellcolor{gray} &  & \verb~57~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~58~ & & \verb~        public void RenderEntities() {~\\
\cellcolor{red} & 0 & \verb~59~ & & \verb~            foreach (Entity entity in entities) {~\\
\cellcolor{red} & 0 & \verb~60~ & & \verb~                entity.Image.Render(entity.Shape);~\\
\cellcolor{red} & 0 & \verb~61~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~62~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~63~ & & \verb~~\\
\cellcolor{gray} &  & \verb~64~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~65~ & & \verb~        /// Render all entities in this EntityContainer~\\
\cellcolor{gray} &  & \verb~66~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~67~ & & \verb~        public void RenderEntities(Camera camera) {~\\
\cellcolor{red} & 0 & \verb~68~ & & \verb~            foreach (Entity entity in entities) {~\\
\cellcolor{red} & 0 & \verb~69~ & & \verb~                entity.Image.Render(entity.Shape, camera);~\\
\cellcolor{red} & 0 & \verb~70~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~71~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~72~ & & \verb~~\\
\cellcolor{gray} &  & \verb~73~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~74~ & & \verb~        /// Remove all entities from this container~\\
\cellcolor{gray} &  & \verb~75~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~76~ & & \verb~        public void ClearContainer() {~\\
\cellcolor{red} & 0 & \verb~77~ & & \verb~            entities.Clear();~\\
\cellcolor{red} & 0 & \verb~78~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~79~ & & \verb~~\\
\cellcolor{gray} &  & \verb~80~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~81~ & & \verb~        /// Count the number of entities in the EntityContainer~\\
\cellcolor{gray} &  & \verb~82~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~83~ & & \verb~        public int CountEntities() {~\\
\cellcolor{red} & 0 & \verb~84~ & & \verb~            return entities.Count;~\\
\cellcolor{red} & 0 & \verb~85~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~86~ & & \verb~~\\
\cellcolor{gray} &  & \verb~87~ & & \verb~        // IEnumerable interface:~\\
\cellcolor{gray} &  & \verb~88~ & & \verb~        #region IEnumerable~\\
\cellcolor{gray} &  & \verb~89~ & & \verb~~\\
\cellcolor{gray} &  & \verb~90~ & & \verb~        IEnumerator IEnumerable.GetEnumerator()~\\
\cellcolor{red} & 0 & \verb~91~ & & \verb~        {~\\
\cellcolor{red} & 0 & \verb~92~ & & \verb~            return GetEnumerator();~\\
\cellcolor{red} & 0 & \verb~93~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~94~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~95~ & & \verb~        public IEnumerator GetEnumerator() {~\\
\cellcolor{red} & 0 & \verb~96~ & & \verb~            return new EntityContainerEnum(entities);~\\
\cellcolor{red} & 0 & \verb~97~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~98~ & & \verb~~\\
\cellcolor{gray} &  & \verb~99~ & & \verb~        private class EntityContainerEnum : IEnumerator {~\\
\cellcolor{gray} &  & \verb~100~ & & \verb~            private ReadOnlyCollection<Entity> entities;~\\
\cellcolor{red} & 0 & \verb~101~ & & \verb~            private int position = -1;~\\
\cellcolor{gray} &  & \verb~102~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~103~ & & \verb~            public EntityContainerEnum(List<Entity> entities) {~\\
\cellcolor{red} & 0 & \verb~104~ & & \verb~                this.entities = entities.AsReadOnly();~\\
\cellcolor{red} & 0 & \verb~105~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~106~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~107~ & & \verb~            public bool MoveNext() {~\\
\cellcolor{red} & 0 & \verb~108~ & & \verb~                position++;~\\
\cellcolor{red} & 0 & \verb~109~ & & \verb~                return position < entities.Count;~\\
\cellcolor{red} & 0 & \verb~110~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~111~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~112~ & & \verb~            public void Reset() {~\\
\cellcolor{red} & 0 & \verb~113~ & & \verb~                position = -1;~\\
\cellcolor{red} & 0 & \verb~114~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~115~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~116~ & & \verb~            object IEnumerator.Current => Current;~\\
\cellcolor{gray} &  & \verb~117~ & & \verb~~\\
\cellcolor{gray} &  & \verb~118~ & & \verb~            public Entity Current {~\\
\cellcolor{red} & 0 & \verb~119~ & & \verb~                get {~\\
\cellcolor{red} & 0 & \verb~120~ & & \verb~                    try {~\\
\cellcolor{red} & 0 & \verb~121~ & & \verb~                        return entities[position];~\\
\cellcolor{red} & 0 & \verb~122~ & & \verb~                    } catch (IndexOutOfRangeException) {~\\
\cellcolor{red} & 0 & \verb~123~ & & \verb~                        throw new InvalidOperationException();~\\
\cellcolor{gray} &  & \verb~124~ & & \verb~                    }~\\
\cellcolor{red} & 0 & \verb~125~ & & \verb~                }~\\
\cellcolor{gray} &  & \verb~126~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~127~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~128~ & & \verb~~\\
\cellcolor{gray} &  & \verb~129~ & & \verb~        #endregion~\\
\cellcolor{gray} &  & \verb~130~ & & \verb~~\\
\cellcolor{gray} &  & \verb~131~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~132~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Entities.EntityContainer$<$T$>$}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Entities.EntityContainer$<$T$>$\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Entities/EntityContainerT.cs}\end{minipage} \\
\textbf{Covered lines:} & 40\\
\textbf{Uncovered lines:} & 11\\
\textbf{Coverable lines:} & 51\\
\textbf{Total lines:} & 113\\
\textbf{Line coverage:} & 78.4\% (40 of 51)\\
\textbf{Covered branches:} & 6\\
\textbf{Total branches:} & 8\\
\textbf{Branch coverage:} & 75\% (6 of 8)\\
\textbf{Covered methods:} & 12\\
\textbf{Total methods:} & 15\\
\textbf{Method coverage:} & 80\% (12 of 15)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 100\%\\
\hline
\textbf{.ctor()} & 100\% & 1 & 100\%\\
\hline
\textbf{AddEntity(...)} & 100\% & 1 & 100\%\\
\hline
\textbf{Iterate(...)} & 100\% & 6 & 100\%\\
\hline
\textbf{RenderEntities()} & 0\% & 2 & 0\%\\
\hline
\textbf{ClearContainer()} & 100\% & 1 & 100\%\\
\hline
\textbf{CountEntities()} & 100\% & 1 & 100\%\\
\hline
\textbf{System.Collections.I} & 100\% & 1 & 0\%\\
\hline
\textbf{GetEnumerator()} & 100\% & 1 & 100\%\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 100\%\\
\hline
\textbf{MoveNext()} & 100\% & 1 & 100\%\\
\hline
\textbf{Reset()} & 100\% & 1 & 0\%\\
\hline
\textbf{System.IDisposable.D} & 100\% & 1 & 100\%\\
\hline
\textbf{System.Collections.I} & 100\% & 1 & 100\%\\
\hline
\textbf{get\_Current()} & 100\% & 1 & 100\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Entities/EntityContainerT.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using System;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using System.Collections;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~using System.Collections.ObjectModel;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~using DIKUArcade.Graphics;~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~namespace DIKUArcade.Entities {~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~    public sealed class EntityContainer<T> : IEnumerable where T: Entity {~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~        private List<T> entities;~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~~\\
\cellcolor{green} & 196 & \verb~11~ & & \verb~        public EntityContainer(int size) {~\\
\cellcolor{green} & 98 & \verb~12~ & & \verb~            entities = new List<T>(size);~\\
\cellcolor{green} & 98 & \verb~13~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~~\\
\cellcolor{green} & 3 & \verb~15~ & & \verb~        public EntityContainer() : this(50) { }~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~~\\
\cellcolor{green} & 163 & \verb~17~ & & \verb~        public void AddEntity(T obj) {~\\
\cellcolor{green} & 163 & \verb~18~ & & \verb~            entities.Add(obj);~\\
\cellcolor{green} & 163 & \verb~19~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~        /// Delegate method for iterating through an EntityContainer.~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~        /// This function should return true if the object should be~\\
\cellcolor{gray} &  & \verb~24~ & & \verb~        /// removed from the EntityContainer.~\\
\cellcolor{gray} &  & \verb~25~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~26~ & & \verb~        /// <param name="obj">Generic object of type T</param>~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~        public delegate void IteratorMethod(T obj);~\\
\cellcolor{gray} &  & \verb~28~ & & \verb~~\\
\cellcolor{gray} &  & \verb~29~ & & \verb~        /// <summary>Iterate through all objects in this EntityContainer.</summary>~\\
\cellcolor{gray} &  & \verb~30~ & & \verb~        /// <remarks>This method can modify objects during iteration!~\\
\cellcolor{gray} &  & \verb~31~ & & \verb~        /// If this functionality is undesired, iterate then through this~\\
\cellcolor{gray} &  & \verb~32~ & & \verb~        /// EntityContainer using a 'foreach'-loop (from IEnumerable).</remarks>~\\
\cellcolor{green} & 62 & \verb~33~ & & \verb~        public void Iterate(IteratorMethod iterator) {~\\
\cellcolor{green} & 62 & \verb~34~ & & \verb~            var count = entities.Count;~\\
\cellcolor{green} & 62 & \verb~35~ & & \verb~            var newList = new List<T>(count);~\\
\cellcolor{gray} &  & \verb~36~ & & \verb~~\\
\cellcolor{gray} &  & \verb~37~ & & \verb~            // iterate through entities~\\
\cellcolor{green} & 256 & \verb~38~ & & \verb~            for (int i = 0; i < count; i++) {~\\
\cellcolor{green} & 44 & \verb~39~ & & \verb~                iterator(entities[i]);~\\
\cellcolor{green} & 44 & \verb~40~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~41~ & & \verb~~\\
\cellcolor{gray} &  & \verb~42~ & & \verb~            // keep Entities that have not been marked for deletion during iteration~\\
\cellcolor{green} & 318 & \verb~43~ & & \verb~            foreach (var obj in entities) {~\\
\cellcolor{green} & 60 & \verb~44~ & & \verb~                if (!obj.IsDeleted()) {~\\
\cellcolor{green} & 16 & \verb~45~ & & \verb~                    newList.Add(obj);~\\
\cellcolor{green} & 16 & \verb~46~ & & \verb~                }~\\
\cellcolor{green} & 44 & \verb~47~ & & \verb~            }~\\
\cellcolor{green} & 62 & \verb~48~ & & \verb~            entities = newList;~\\
\cellcolor{green} & 62 & \verb~49~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~50~ & & \verb~~\\
\cellcolor{gray} &  & \verb~51~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~52~ & & \verb~        /// Render all entities in this EntityContainer~\\
\cellcolor{gray} &  & \verb~53~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~54~ & & \verb~        public void RenderEntities() {~\\
\cellcolor{red} & 0 & \verb~55~ & & \verb~            foreach (var obj in entities) {~\\
\cellcolor{red} & 0 & \verb~56~ & & \verb~                obj.Image.Render(obj.Shape);~\\
\cellcolor{red} & 0 & \verb~57~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~58~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~59~ & & \verb~~\\
\cellcolor{gray} &  & \verb~60~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~61~ & & \verb~        /// Remove all entities from this container~\\
\cellcolor{gray} &  & \verb~62~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 51 & \verb~63~ & & \verb~        public void ClearContainer() {~\\
\cellcolor{green} & 51 & \verb~64~ & & \verb~            entities.Clear();~\\
\cellcolor{green} & 51 & \verb~65~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~66~ & & \verb~~\\
\cellcolor{gray} &  & \verb~67~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~68~ & & \verb~        /// Count the number of entities in the EntityContainer~\\
\cellcolor{gray} &  & \verb~69~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 47 & \verb~70~ & & \verb~        public int CountEntities() {~\\
\cellcolor{green} & 47 & \verb~71~ & & \verb~            return entities.Count;~\\
\cellcolor{green} & 47 & \verb~72~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~73~ & & \verb~~\\
\cellcolor{gray} &  & \verb~74~ & & \verb~        // IEnumerable interface:~\\
\cellcolor{gray} &  & \verb~75~ & & \verb~        #region IEnumerable~\\
\cellcolor{gray} &  & \verb~76~ & & \verb~~\\
\cellcolor{gray} &  & \verb~77~ & & \verb~        IEnumerator IEnumerable.GetEnumerator()~\\
\cellcolor{red} & 0 & \verb~78~ & & \verb~        {~\\
\cellcolor{red} & 0 & \verb~79~ & & \verb~            return GetEnumerator();~\\
\cellcolor{red} & 0 & \verb~80~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~81~ & & \verb~~\\
\cellcolor{green} & 70 & \verb~82~ & & \verb~        public IEnumerator GetEnumerator() {~\\
\cellcolor{green} & 70 & \verb~83~ & & \verb~            return new EntityContainerEnum(entities);~\\
\cellcolor{green} & 70 & \verb~84~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~85~ & & \verb~~\\
\cellcolor{gray} &  & \verb~86~ & & \verb~        private class EntityContainerEnum : IEnumerator<T> {~\\
\cellcolor{gray} &  & \verb~87~ & & \verb~            private ReadOnlyCollection<T> entities;~\\
\cellcolor{green} & 70 & \verb~88~ & & \verb~            private int position = -1;~\\
\cellcolor{gray} &  & \verb~89~ & & \verb~~\\
\cellcolor{green} & 140 & \verb~90~ & & \verb~            public EntityContainerEnum(List<T> entities) {~\\
\cellcolor{green} & 70 & \verb~91~ & & \verb~                this.entities = entities.AsReadOnly();~\\
\cellcolor{green} & 70 & \verb~92~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~93~ & & \verb~~\\
\cellcolor{green} & 212 & \verb~94~ & & \verb~            public bool MoveNext() {~\\
\cellcolor{green} & 212 & \verb~95~ & & \verb~                position++;~\\
\cellcolor{green} & 212 & \verb~96~ & & \verb~                return position < entities.Count;~\\
\cellcolor{green} & 212 & \verb~97~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~98~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~99~ & & \verb~            public void Reset() {~\\
\cellcolor{red} & 0 & \verb~100~ & & \verb~                position = -1;~\\
\cellcolor{red} & 0 & \verb~101~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~102~ & & \verb~~\\
\cellcolor{green} & 140 & \verb~103~ & & \verb~            void IDisposable.Dispose() { }~\\
\cellcolor{gray} &  & \verb~104~ & & \verb~~\\
\cellcolor{green} & 142 & \verb~105~ & & \verb~            object IEnumerator.Current => Current;~\\
\cellcolor{gray} &  & \verb~106~ & & \verb~~\\
\cellcolor{green} & 142 & \verb~107~ & & \verb~            public T Current => entities[position];~\\
\cellcolor{gray} &  & \verb~108~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~109~ & & \verb~~\\
\cellcolor{gray} &  & \verb~110~ & & \verb~        #endregion~\\
\cellcolor{gray} &  & \verb~111~ & & \verb~~\\
\cellcolor{gray} &  & \verb~112~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~113~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Entities.Shape}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Entities.Shape\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Entities/Shape.cs}\end{minipage} \\
\textbf{Covered lines:} & 11\\
\textbf{Uncovered lines:} & 50\\
\textbf{Coverable lines:} & 61\\
\textbf{Total lines:} & 114\\
\textbf{Line coverage:} & 18\% (11 of 61)\\
\textbf{Covered branches:} & 1\\
\textbf{Total branches:} & 4\\
\textbf{Branch coverage:} & 25\% (1 of 4)\\
\textbf{Covered methods:} & 4\\
\textbf{Total methods:} & 20\\
\textbf{Method coverage:} & 20\% (4 of 20)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{get\_Rotation()} & 100\% & 1 & 0\%\\
\hline
\textbf{get\_Extent()} & 100\% & 1 & 100\%\\
\hline
\textbf{AsDynamicShape()} & 50.0\% & 2 & 100\%\\
\hline
\textbf{AsStationaryShape()} & 0\% & 2 & 0\%\\
\hline
\textbf{Scale(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{Scale(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{ScaleX(...)} & 100\% & 1 & 100\%\\
\hline
\textbf{ScaleY(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{ScaleXFromCenter(...} & 100\% & 1 & 0\%\\
\hline
\textbf{ScaleYFromCenter(...} & 100\% & 1 & 0\%\\
\hline
\textbf{ScaleFromCenter(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{ScaleFromCenter(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{Move()} & 100\% & 1 & 0\%\\
\hline
\textbf{Move(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{MoveX(...)} & 100\% & 1 & 100\%\\
\hline
\textbf{MoveY(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{Move(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{Rotate(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{SetRotation(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{SetPosition(...)} & 100\% & 1 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Entities/Shape.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Math;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~namespace DIKUArcade.Entities {~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~    public class Shape {~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~        /// Shape's rotational angle measured in radians.~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~8~ & & \verb~        public float Rotation { get; set; }~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~        /// Basic Shape properties~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~        public Vec2F Position;~\\
\cellcolor{green} & 3613 & \verb~14~ & & \verb~        public Vec2F Extent { get; set; }~\\
\cellcolor{gray} &  & \verb~15~ & & \verb~~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~17~ & & \verb~        /// Performs a downcast on this Shape instance to a~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~        /// DynamicShape. If the downcast fails, a new~\\
\cellcolor{gray} &  & \verb~19~ & & \verb~        /// DynamicShape is returned instead with this Shape's~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~        /// Position and Extent properties, and a default (0,0)~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~        /// Direction vector.~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~        /// <returns></returns>~\\
\cellcolor{green} & 258 & \verb~24~ & & \verb~        public DynamicShape AsDynamicShape() {~\\
\cellcolor{green} & 258 & \verb~25~ & & \verb~            var shape = this as DynamicShape;~\\
\cellcolor{orange} & 258 & \verb~26~ & & \verb~            return shape ?? new DynamicShape(Position, Extent);~\\
\cellcolor{green} & 258 & \verb~27~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~28~ & & \verb~~\\
\cellcolor{gray} &  & \verb~29~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~30~ & & \verb~        /// Performs a downcast on this Shape instance to a~\\
\cellcolor{gray} &  & \verb~31~ & & \verb~        /// StationaryShape. If the downcast fails, a new~\\
\cellcolor{gray} &  & \verb~32~ & & \verb~        /// StationaryShape is returned instead with this Shape's~\\
\cellcolor{gray} &  & \verb~33~ & & \verb~        /// Position and Extent properties.~\\
\cellcolor{gray} &  & \verb~34~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~35~ & & \verb~        /// <returns></returns>~\\
\cellcolor{red} & 0 & \verb~36~ & & \verb~        public StationaryShape AsStationaryShape() {~\\
\cellcolor{red} & 0 & \verb~37~ & & \verb~            var sta = this as StationaryShape;~\\
\cellcolor{red} & 0 & \verb~38~ & & \verb~            return sta ?? new StationaryShape(Position, Extent);~\\
\cellcolor{red} & 0 & \verb~39~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~40~ & & \verb~~\\
\cellcolor{gray} &  & \verb~41~ & & \verb~        // Do not reference other shapes if you intend to scale.~\\
\cellcolor{gray} &  & \verb~42~ & & \verb~        // Use .Copy() or you might scale everything.~\\
\cellcolor{red} & 0 & \verb~43~ & & \verb~        public void Scale(float scale) {~\\
\cellcolor{red} & 0 & \verb~44~ & & \verb~            Extent *= scale;~\\
\cellcolor{red} & 0 & \verb~45~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~46~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~47~ & & \verb~        public void Scale(Vec2F scalar) {~\\
\cellcolor{gray} &  & \verb~48~ & & \verb~            // This is doing pairwise vector multiplication!~\\
\cellcolor{red} & 0 & \verb~49~ & & \verb~            Extent *= scalar;~\\
\cellcolor{red} & 0 & \verb~50~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~51~ & & \verb~~\\
\cellcolor{green} & 2 & \verb~52~ & & \verb~        public void ScaleX(float scale) {~\\
\cellcolor{green} & 2 & \verb~53~ & & \verb~            Extent.X *= scale;~\\
\cellcolor{green} & 2 & \verb~54~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~55~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~56~ & & \verb~        public void ScaleY(float scale) {~\\
\cellcolor{red} & 0 & \verb~57~ & & \verb~            Extent.Y *= scale;~\\
\cellcolor{red} & 0 & \verb~58~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~59~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~60~ & & \verb~        public void ScaleXFromCenter(float scale) {~\\
\cellcolor{red} & 0 & \verb~61~ & & \verb~            Position.X = (Position.X + Extent.X / 2.0f) - ((Extent.X / 2.0f) * scale);~\\
\cellcolor{red} & 0 & \verb~62~ & & \verb~            Extent.X *= scale;~\\
\cellcolor{red} & 0 & \verb~63~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~64~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~65~ & & \verb~        public void ScaleYFromCenter(float scale) {~\\
\cellcolor{red} & 0 & \verb~66~ & & \verb~            Position.Y = (Position.Y + Extent.Y / 2.0f) - (Extent.Y / 2.0f * scale);~\\
\cellcolor{red} & 0 & \verb~67~ & & \verb~            Extent.Y *= scale;~\\
\cellcolor{red} & 0 & \verb~68~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~69~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~70~ & & \verb~        public void ScaleFromCenter(float scale) {~\\
\cellcolor{red} & 0 & \verb~71~ & & \verb~            ScaleXFromCenter(scale);~\\
\cellcolor{red} & 0 & \verb~72~ & & \verb~            ScaleYFromCenter(scale);~\\
\cellcolor{red} & 0 & \verb~73~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~74~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~75~ & & \verb~        public void ScaleFromCenter(Vec2F scalar) {~\\
\cellcolor{red} & 0 & \verb~76~ & & \verb~            ScaleXFromCenter(scalar.X);~\\
\cellcolor{red} & 0 & \verb~77~ & & \verb~            ScaleYFromCenter(scalar.Y);~\\
\cellcolor{red} & 0 & \verb~78~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~79~ & & \verb~~\\
\cellcolor{gray} &  & \verb~80~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~81~ & & \verb~        /// Default Move method which does nothing.~\\
\cellcolor{gray} &  & \verb~82~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~83~ & & \verb~        public virtual void Move() {}~\\
\cellcolor{gray} &  & \verb~84~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~85~ & & \verb~        public void Move(Vec2F mover) {~\\
\cellcolor{red} & 0 & \verb~86~ & & \verb~            Position += mover;~\\
\cellcolor{red} & 0 & \verb~87~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~88~ & & \verb~~\\
\cellcolor{green} & 2 & \verb~89~ & & \verb~        public void MoveX(float move) {~\\
\cellcolor{green} & 2 & \verb~90~ & & \verb~            Position.X += move;~\\
\cellcolor{green} & 2 & \verb~91~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~92~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~93~ & & \verb~        public void MoveY(float move) {~\\
\cellcolor{red} & 0 & \verb~94~ & & \verb~            Position.Y += move;~\\
\cellcolor{red} & 0 & \verb~95~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~96~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~97~ & & \verb~        public void Move(float x, float y) {~\\
\cellcolor{red} & 0 & \verb~98~ & & \verb~            MoveX(x);~\\
\cellcolor{red} & 0 & \verb~99~ & & \verb~            MoveY(y);~\\
\cellcolor{red} & 0 & \verb~100~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~101~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~102~ & & \verb~        public void Rotate(float angleRadians) {~\\
\cellcolor{red} & 0 & \verb~103~ & & \verb~            Rotation += angleRadians;~\\
\cellcolor{red} & 0 & \verb~104~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~105~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~106~ & & \verb~        public void SetRotation(float angleRadians) {~\\
\cellcolor{red} & 0 & \verb~107~ & & \verb~            Rotation = angleRadians;~\\
\cellcolor{red} & 0 & \verb~108~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~109~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~110~ & & \verb~        public void SetPosition(Vec2F newPosition) {~\\
\cellcolor{red} & 0 & \verb~111~ & & \verb~            Position = newPosition;~\\
\cellcolor{red} & 0 & \verb~112~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~113~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~114~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Entities.StationaryShape}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Entities.StationaryShape\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Entities/StationaryShape.cs}\end{minipage} \\
\textbf{Covered lines:} & 4\\
\textbf{Uncovered lines:} & 7\\
\textbf{Coverable lines:} & 11\\
\textbf{Total lines:} & 23\\
\textbf{Line coverage:} & 36.3\% (4 of 11)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 0\\
\textbf{Covered methods:} & 1\\
\textbf{Total methods:} & 3\\
\textbf{Method coverage:} & 33.3\% (1 of 3)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 100\%\\
\hline
\textbf{op\_Explicit(...)} & 100\% & 1 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Entities/StationaryShape.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Math;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~namespace DIKUArcade.Entities {~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~    /// Similar to DynamicShape, but does not contain direction information,~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~    /// since a static object os not meant to be affected by game physics.~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~    public class StationaryShape : Shape {~\\
\cellcolor{red} & 0 & \verb~9~ & & \verb~        public StationaryShape(float posX, float posY, float width, float height) {~\\
\cellcolor{red} & 0 & \verb~10~ & & \verb~            Position = new Vec2F(posX, posY);~\\
\cellcolor{red} & 0 & \verb~11~ & & \verb~            Extent = new Vec2F(width, height);~\\
\cellcolor{red} & 0 & \verb~12~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~~\\
\cellcolor{green} & 274 & \verb~14~ & & \verb~        public StationaryShape(Vec2F pos, Vec2F extent) {~\\
\cellcolor{green} & 137 & \verb~15~ & & \verb~            Position = pos;~\\
\cellcolor{green} & 137 & \verb~16~ & & \verb~            Extent = extent;~\\
\cellcolor{green} & 137 & \verb~17~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~19~ & & \verb~        public static explicit operator DynamicShape(StationaryShape sta) {~\\
\cellcolor{red} & 0 & \verb~20~ & & \verb~            return new DynamicShape(sta.Position, sta.Extent);~\\
\cellcolor{red} & 0 & \verb~21~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Events.GameEventBus}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Events.GameEventBus\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Events/GameEventBus.cs}\end{minipage} \\
\textbf{Covered lines:} & 18\\
\textbf{Uncovered lines:} & 156\\
\textbf{Coverable lines:} & 174\\
\textbf{Total lines:} & 285\\
\textbf{Line coverage:} & 10.3\% (18 of 174)\\
\textbf{Covered branches:} & 4\\
\textbf{Total branches:} & 60\\
\textbf{Branch coverage:} & 6.6\% (4 of 60)\\
\textbf{Covered methods:} & 4\\
\textbf{Total methods:} & 19\\
\textbf{Method coverage:} & 21\% (4 of 19)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor()} & 100\% & 1 & 100\%\\
\hline
\textbf{SwapTimedEventLists(} & 100\% & 1 & 0\%\\
\hline
\textbf{InitializeEventBus(.} & 0\% & 6 & 0\%\\
\hline
\textbf{Subscribe(...)} & 50.0\% & 4 & 60.0\%\\
\hline
\textbf{Unsubscribe(...)} & 0\% & 4 & 0\%\\
\hline
\textbf{RegisterTimedEvent(.} & 0\% & 4 & 0\%\\
\hline
\textbf{AddOrResetTimedEvent} & 0\% & 4 & 0\%\\
\hline
\textbf{CancelTimedEvent(...} & 0\% & 4 & 0\%\\
\hline
\textbf{ResetTimedEvent(...)} & 0\% & 2 & 0\%\\
\hline
\textbf{HasTimedEvent(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{RegisterEvent(...)} & 50.0\% & 2 & 62.50\%\\
\hline
\textbf{ProcessTimedEvents()} & 0\% & 4 & 0\%\\
\hline
\textbf{ProcessEvents(...)} & 0\% & 2 & 0\%\\
\hline
\textbf{ProcessEventsSequent} & 0\% & 16 & 0\%\\
\hline
\textbf{ProcessEvents()} & 0\% & 2 & 0\%\\
\hline
\textbf{ProcessEventsSequent} & 50.0\% & 2 & 100\%\\
\hline
\textbf{BreakProcessing()} & 100\% & 1 & 0\%\\
\hline
\textbf{ResetBreakProcessing} & 100\% & 1 & 0\%\\
\hline
\textbf{Flush()} & 0\% & 4 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Events/GameEventBus.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using System;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using System.Threading.Tasks;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~using DIKUArcade.Timers;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~namespace DIKUArcade.Events~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~{~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~    /// Default implementation of GameEventBus (see below) which uses GameEventType~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~    /// instead of a generic enum event type.~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~    /// GameEventBus is the core module for processing events in the DIKUArcade game engine. Modules can register events~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~    /// add them to the queues. Events are distinguished by event types to improve processing performance. Event process~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~    /// can register/subscribe themself to receive events of a certain event type. For a single event, all processors ar~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~    /// called with this event (broadcast semantic).~\\
\cellcolor{gray} &  & \verb~15~ & & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~    public class GameEventBus : IGameEventBus, ITimedGameEventBus, IGameEventBusController~\\
\cellcolor{gray} &  & \verb~17~ & & \verb~    {~\\
\cellcolor{green} & 1 & \verb~18~ & & \verb~        private bool _initialized = false;~\\
\cellcolor{gray} &  & \verb~19~ & & \verb~~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~        /// Dictionary of registered event processors for a given game event type.~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~        private Dictionary<GameEventType, ICollection<IGameEventProcessor>> _eventProcessors;~\\
\cellcolor{gray} &  & \verb~24~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~25~ & & \verb~        /// Dictionary of game event queues for different game event types.~\\
\cellcolor{gray} &  & \verb~26~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~        private Dictionary<GameEventType, GameEventQueue<GameEvent>> _eventQueues;~\\
\cellcolor{gray} &  & \verb~28~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~29~ & & \verb~        /// Stops processing the pipeline, e.g. needed due real-time constraints.~\\
\cellcolor{gray} &  & \verb~30~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 1 & \verb~31~ & & \verb~        private bool _breakExecution = false;~\\
\cellcolor{gray} &  & \verb~32~ & & \verb~~\\
\cellcolor{gray} &  & \verb~33~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~34~ & & \verb~        /// List of events which must be processed after a specified time interval has passed.~\\
\cellcolor{gray} &  & \verb~35~ & & \verb~        /// We use a double-buffered system.~\\
\cellcolor{gray} &  & \verb~36~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 1 & \verb~37~ & & \verb~        private int _activeTimedEventList = 0;~\\
\cellcolor{green} & 1 & \verb~38~ & & \verb~        private int _inactiveTimedEventList = 1;~\\
\cellcolor{gray} &  & \verb~39~ & & \verb~        private List<TimedGameEvent>[] _timedEventLists;~\\
\cellcolor{gray} &  & \verb~40~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~41~ & & \verb~        private void SwapTimedEventLists() {~\\
\cellcolor{red} & 0 & \verb~42~ & & \verb~            _activeTimedEventList = (_activeTimedEventList + 1) % 2;~\\
\cellcolor{red} & 0 & \verb~43~ & & \verb~            _inactiveTimedEventList = (_inactiveTimedEventList + 1) % 2;~\\
\cellcolor{red} & 0 & \verb~44~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~45~ & & \verb~~\\
\cellcolor{gray} &  & \verb~46~ & & \verb~~\\
\cellcolor{gray} &  & \verb~47~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~48~ & & \verb~        /// Initialized the event bus to handle the specified event types.~\\
\cellcolor{gray} &  & \verb~49~ & & \verb~        /// An exception is thrown if called on an already initialized GameEventBus.~\\
\cellcolor{gray} &  & \verb~50~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~51~ & & \verb~        /// <exception cref="InvalidOperationException"></exception>~\\
\cellcolor{gray} &  & \verb~52~ & & \verb~        public void InitializeEventBus(ICollection<GameEventType> eventTypeList)~\\
\cellcolor{red} & 0 & \verb~53~ & & \verb~        {~\\
\cellcolor{red} & 0 & \verb~54~ & & \verb~            if (_initialized) {~\\
\cellcolor{red} & 0 & \verb~55~ & & \verb~                throw new InvalidOperationException("GameEventBus is already initialized!");~\\
\cellcolor{gray} &  & \verb~56~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~57~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~58~ & & \verb~            _eventProcessors= new Dictionary<GameEventType, ICollection<IGameEventProcessor>>();~\\
\cellcolor{red} & 0 & \verb~59~ & & \verb~            _eventQueues= new Dictionary<GameEventType, GameEventQueue<GameEvent>>();~\\
\cellcolor{gray} &  & \verb~60~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~61~ & & \verb~            if (eventTypeList != null) {~\\
\cellcolor{red} & 0 & \verb~62~ & & \verb~                foreach (var eventType in eventTypeList)~\\
\cellcolor{red} & 0 & \verb~63~ & & \verb~                {~\\
\cellcolor{red} & 0 & \verb~64~ & & \verb~                    _eventProcessors.Add(eventType, new List<IGameEventProcessor>());~\\
\cellcolor{red} & 0 & \verb~65~ & & \verb~                    _eventQueues.Add(eventType, new GameEventQueue<GameEvent>());~\\
\cellcolor{red} & 0 & \verb~66~ & & \verb~                }~\\
\cellcolor{red} & 0 & \verb~67~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~68~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~69~ & & \verb~            _timedEventLists = new List<TimedGameEvent>[2] {~\\
\cellcolor{red} & 0 & \verb~70~ & & \verb~                new List<TimedGameEvent>(),~\\
\cellcolor{red} & 0 & \verb~71~ & & \verb~                new List<TimedGameEvent>()~\\
\cellcolor{red} & 0 & \verb~72~ & & \verb~            };~\\
\cellcolor{gray} &  & \verb~73~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~74~ & & \verb~            _initialized = true;~\\
\cellcolor{red} & 0 & \verb~75~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~76~ & & \verb~~\\
\cellcolor{gray} &  & \verb~77~ & & \verb~        public void Subscribe(GameEventType eventType, IGameEventProcessor gameEventProcessor)~\\
\cellcolor{green} & 260 & \verb~78~ & & \verb~        {~\\
\cellcolor{orange} & 260 & \verb~79~ & & \verb~            if (gameEventProcessor == default(IGameEventProcessor))~\\
\cellcolor{red} & 0 & \verb~80~ & & \verb~                throw new ArgumentNullException("Parameter gameEventProcessor must not be null.");~\\
\cellcolor{gray} &  & \verb~81~ & & \verb~~\\
\cellcolor{gray} &  & \verb~82~ & & \verb~            try~\\
\cellcolor{green} & 260 & \verb~83~ & & \verb~            {~\\
\cellcolor{orange} & 260 & \verb~84~ & & \verb~                _eventProcessors?[eventType].Add(gameEventProcessor);~\\
\cellcolor{green} & 260 & \verb~85~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~86~ & & \verb~            catch (Exception e)~\\
\cellcolor{red} & 0 & \verb~87~ & & \verb~            {~\\
\cellcolor{red} & 0 & \verb~88~ & & \verb~                throw new Exception($"Could not subscribe event processor. Check eventType! {e}");~\\
\cellcolor{gray} &  & \verb~89~ & & \verb~            }~\\
\cellcolor{green} & 260 & \verb~90~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~91~ & & \verb~~\\
\cellcolor{gray} &  & \verb~92~ & & \verb~        public void Unsubscribe(GameEventType eventType, IGameEventProcessor gameEventProcessor)~\\
\cellcolor{red} & 0 & \verb~93~ & & \verb~        {~\\
\cellcolor{red} & 0 & \verb~94~ & & \verb~            if (gameEventProcessor == default(IGameEventProcessor))~\\
\cellcolor{red} & 0 & \verb~95~ & & \verb~                throw new ArgumentNullException("Parameter gameEventProcessor must not be null.");~\\
\cellcolor{gray} &  & \verb~96~ & & \verb~~\\
\cellcolor{gray} &  & \verb~97~ & & \verb~            try~\\
\cellcolor{red} & 0 & \verb~98~ & & \verb~            {~\\
\cellcolor{red} & 0 & \verb~99~ & & \verb~                _eventProcessors?[eventType].Remove(gameEventProcessor);~\\
\cellcolor{red} & 0 & \verb~100~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~101~ & & \verb~            catch (Exception e)~\\
\cellcolor{red} & 0 & \verb~102~ & & \verb~            {~\\
\cellcolor{red} & 0 & \verb~103~ & & \verb~                throw new Exception($"Could not unsubsribe event processor. Check eventType or processor is unregistered~\\
\cellcolor{gray} &  & \verb~104~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~105~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~106~ & & \verb~~\\
\cellcolor{gray} &  & \verb~107~ & & \verb~~\\
\cellcolor{gray} &  & \verb~108~ & & \verb~        #region TIMED_EVENTS~\\
\cellcolor{gray} &  & \verb~109~ & & \verb~~\\
\cellcolor{gray} &  & \verb~110~ & & \verb~        public void RegisterTimedEvent(GameEvent gameEvent, TimePeriod timePeriod)~\\
\cellcolor{red} & 0 & \verb~111~ & & \verb~        {~\\
\cellcolor{gray} &  & \verb~112~ & & \verb~            // do not insert already registered events:~\\
\cellcolor{red} & 0 & \verb~113~ & & \verb~            if (gameEvent.Id != default(uint)) {~\\
\cellcolor{red} & 0 & \verb~114~ & & \verb~                if (_timedEventLists[_activeTimedEventList].Exists(e => e.GameEvent.Id == gameEvent.Id)) {~\\
\cellcolor{red} & 0 & \verb~115~ & & \verb~                    return;~\\
\cellcolor{gray} &  & \verb~116~ & & \verb~                }~\\
\cellcolor{red} & 0 & \verb~117~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~118~ & & \verb~            _timedEventLists[_activeTimedEventList].Add(new TimedGameEvent(timePeriod, gameEvent));~\\
\cellcolor{red} & 0 & \verb~119~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~120~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~121~ & & \verb~        public void AddOrResetTimedEvent(GameEvent gameEvent, TimePeriod timePeriod) {~\\
\cellcolor{red} & 0 & \verb~122~ & & \verb~            if (gameEvent.Id != default(uint)) {~\\
\cellcolor{gray} &  & \verb~123~ & & \verb~                // search for an item which matches the Id of the specified event~\\
\cellcolor{red} & 0 & \verb~124~ & & \verb~                var search = _timedEventLists[_activeTimedEventList].FindIndex(e => e.GameEvent.Id == gameEvent.Id);~\\
\cellcolor{gray} &  & \verb~125~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~126~ & & \verb~                if (search >= 0) {~\\
\cellcolor{gray} &  & \verb~127~ & & \verb~                    // event with Id already exists, so we reset its time period~\\
\cellcolor{red} & 0 & \verb~128~ & & \verb~                    _timedEventLists[_activeTimedEventList][search] =~\\
\cellcolor{red} & 0 & \verb~129~ & & \verb~                        new TimedGameEvent(timePeriod, _timedEventLists[_activeTimedEventList][search].GameEvent);~\\
\cellcolor{red} & 0 & \verb~130~ & & \verb~                    return;~\\
\cellcolor{gray} &  & \verb~131~ & & \verb~                }~\\
\cellcolor{red} & 0 & \verb~132~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~133~ & & \verb~            // input event does not have an Id, or it has an Id but does not exist in list.~\\
\cellcolor{gray} &  & \verb~134~ & & \verb~            // In either case, we add it.~\\
\cellcolor{red} & 0 & \verb~135~ & & \verb~            _timedEventLists[_activeTimedEventList].Add(new TimedGameEvent(timePeriod, gameEvent));~\\
\cellcolor{red} & 0 & \verb~136~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~137~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~138~ & & \verb~        public bool CancelTimedEvent(uint eventId) {~\\
\cellcolor{red} & 0 & \verb~139~ & & \verb~            bool cancelled = false;~\\
\cellcolor{red} & 0 & \verb~140~ & & \verb~            _timedEventLists[_inactiveTimedEventList].Clear();~\\
\cellcolor{red} & 0 & \verb~141~ & & \verb~            foreach (var e in _timedEventLists[_activeTimedEventList]) {~\\
\cellcolor{red} & 0 & \verb~142~ & & \verb~                if (e.GameEvent.Id != eventId) {~\\
\cellcolor{red} & 0 & \verb~143~ & & \verb~                    _timedEventLists[_inactiveTimedEventList].Add(e);~\\
\cellcolor{red} & 0 & \verb~144~ & & \verb~                } else {~\\
\cellcolor{red} & 0 & \verb~145~ & & \verb~                    cancelled = true;~\\
\cellcolor{red} & 0 & \verb~146~ & & \verb~                }~\\
\cellcolor{red} & 0 & \verb~147~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~148~ & & \verb~~\\
\cellcolor{gray} &  & \verb~149~ & & \verb~            // swap the timed-event lists~\\
\cellcolor{red} & 0 & \verb~150~ & & \verb~            SwapTimedEventLists();~\\
\cellcolor{red} & 0 & \verb~151~ & & \verb~            return cancelled;~\\
\cellcolor{red} & 0 & \verb~152~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~153~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~154~ & & \verb~        public bool ResetTimedEvent(uint eventId, TimePeriod timePeriod) {~\\
\cellcolor{red} & 0 & \verb~155~ & & \verb~            var search = _timedEventLists[_activeTimedEventList].FindIndex(e => e.GameEvent.Id == eventId);~\\
\cellcolor{red} & 0 & \verb~156~ & & \verb~            if (search >= 0) {~\\
\cellcolor{red} & 0 & \verb~157~ & & \verb~                _timedEventLists[_activeTimedEventList][search] =~\\
\cellcolor{red} & 0 & \verb~158~ & & \verb~                    new TimedGameEvent(timePeriod, _timedEventLists[_activeTimedEventList][search].GameEvent);~\\
\cellcolor{red} & 0 & \verb~159~ & & \verb~                return true;~\\
\cellcolor{gray} &  & \verb~160~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~161~ & & \verb~            return false;~\\
\cellcolor{red} & 0 & \verb~162~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~163~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~164~ & & \verb~        public bool HasTimedEvent(uint eventId) {~\\
\cellcolor{red} & 0 & \verb~165~ & & \verb~            return _timedEventLists[_activeTimedEventList].FindIndex(e => e.GameEvent.Id == eventId) >= 0;~\\
\cellcolor{red} & 0 & \verb~166~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~167~ & & \verb~~\\
\cellcolor{gray} &  & \verb~168~ & & \verb~        #endregion // TIMED_EVENTS~\\
\cellcolor{gray} &  & \verb~169~ & & \verb~~\\
\cellcolor{gray} &  & \verb~170~ & & \verb~~\\
\cellcolor{gray} &  & \verb~171~ & & \verb~        public void RegisterEvent(GameEvent gameEvent)~\\
\cellcolor{green} & 74 & \verb~172~ & & \verb~        {~\\
\cellcolor{gray} &  & \verb~173~ & & \verb~            try~\\
\cellcolor{green} & 74 & \verb~174~ & & \verb~            {~\\
\cellcolor{orange} & 74 & \verb~175~ & & \verb~                _eventQueues?[gameEvent.EventType].Enqueue(gameEvent);~\\
\cellcolor{green} & 74 & \verb~176~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~177~ & & \verb~            catch (Exception e)~\\
\cellcolor{red} & 0 & \verb~178~ & & \verb~            {~\\
\cellcolor{red} & 0 & \verb~179~ & & \verb~                throw new Exception($"Could not register event. Did you Initialize the EventBus with {e.Message}");~\\
\cellcolor{gray} &  & \verb~180~ & & \verb~            }~\\
\cellcolor{green} & 74 & \verb~181~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~182~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~183~ & & \verb~        private void ProcessTimedEvents() {~\\
\cellcolor{red} & 0 & \verb~184~ & & \verb~            _timedEventLists[_inactiveTimedEventList].Clear();~\\
\cellcolor{gray} &  & \verb~185~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~186~ & & \verb~            var currentTime = Timers.StaticTimer.GetElapsedMilliseconds();~\\
\cellcolor{red} & 0 & \verb~187~ & & \verb~            foreach (var e in _timedEventLists[_activeTimedEventList]) {~\\
\cellcolor{red} & 0 & \verb~188~ & & \verb~                if (e.HasExpired(currentTime)) {~\\
\cellcolor{red} & 0 & \verb~189~ & & \verb~                    RegisterEvent(e.GameEvent);~\\
\cellcolor{red} & 0 & \verb~190~ & & \verb~                } else {~\\
\cellcolor{red} & 0 & \verb~191~ & & \verb~                    _timedEventLists[_inactiveTimedEventList].Add(e);~\\
\cellcolor{red} & 0 & \verb~192~ & & \verb~                }~\\
\cellcolor{red} & 0 & \verb~193~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~194~ & & \verb~            SwapTimedEventLists();~\\
\cellcolor{red} & 0 & \verb~195~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~196~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~197~ & & \verb~        public void ProcessEvents(IEnumerable<GameEventType> processOrder) {~\\
\cellcolor{red} & 0 & \verb~198~ & & \verb~            if(processOrder==default(IEnumerable<GameEventType>)) {~\\
\cellcolor{red} & 0 & \verb~199~ & & \verb~                throw new ArgumentNullException();~\\
\cellcolor{gray} &  & \verb~200~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~201~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~202~ & & \verb~            ProcessTimedEvents();~\\
\cellcolor{gray} &  & \verb~203~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~204~ & & \verb~            Parallel.ForEach<GameEventType>(processOrder, new Action<GameEventType, ParallelLoopState>(~\\
\cellcolor{red} & 0 & \verb~205~ & & \verb~                (eventType, loopState) => {~\\
\cellcolor{red} & 0 & \verb~206~ & & \verb~                    if (_eventQueues != null) {~\\
\cellcolor{red} & 0 & \verb~207~ & & \verb~                        while (!_eventQueues[eventType].IsEmpty()) {~\\
\cellcolor{red} & 0 & \verb~208~ & & \verb~                            var currentEvent = _eventQueues[eventType].Dequeue();~\\
\cellcolor{red} & 0 & \verb~209~ & & \verb~                            if (currentEvent.To != default(IGameEventProcessor))~\\
\cellcolor{red} & 0 & \verb~210~ & & \verb~                            {~\\
\cellcolor{red} & 0 & \verb~211~ & & \verb~                                currentEvent.To.ProcessEvent(currentEvent);~\\
\cellcolor{red} & 0 & \verb~212~ & & \verb~                            }~\\
\cellcolor{red} & 0 & \verb~213~ & & \verb~                            else if (_eventProcessors != null)~\\
\cellcolor{red} & 0 & \verb~214~ & & \verb~                            {~\\
\cellcolor{red} & 0 & \verb~215~ & & \verb~                                foreach (var eventProcessor in _eventProcessors[eventType]) {~\\
\cellcolor{red} & 0 & \verb~216~ & & \verb~                                    eventProcessor.ProcessEvent(currentEvent);~\\
\cellcolor{red} & 0 & \verb~217~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~218~ & & \verb~                                    if (_breakExecution) loopState.Break();~\\
\cellcolor{red} & 0 & \verb~219~ & & \verb~                                }~\\
\cellcolor{red} & 0 & \verb~220~ & & \verb~                            }~\\
\cellcolor{red} & 0 & \verb~221~ & & \verb~                        }~\\
\cellcolor{red} & 0 & \verb~222~ & & \verb~                    }~\\
\cellcolor{red} & 0 & \verb~223~ & & \verb~            }));~\\
\cellcolor{gray} &  & \verb~224~ & & \verb~~\\
\cellcolor{gray} &  & \verb~225~ & & \verb~            // semantic of Parallel.ForEach is it blocks until all parallel threads are finished~\\
\cellcolor{red} & 0 & \verb~226~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~227~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~228~ & & \verb~        public void ProcessEventsSequentially(IEnumerable<GameEventType> processOrder) {~\\
\cellcolor{red} & 0 & \verb~229~ & & \verb~            if(processOrder==default(IEnumerable<GameEventType>)) {~\\
\cellcolor{red} & 0 & \verb~230~ & & \verb~                throw new ArgumentNullException();~\\
\cellcolor{gray} &  & \verb~231~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~232~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~233~ & & \verb~            ProcessTimedEvents();~\\
\cellcolor{gray} &  & \verb~234~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~235~ & & \verb~            foreach(GameEventType eventType in processOrder) {~\\
\cellcolor{red} & 0 & \verb~236~ & & \verb~                if (_eventQueues != null) {~\\
\cellcolor{red} & 0 & \verb~237~ & & \verb~                    while (!_eventQueues[eventType].IsEmpty()) {~\\
\cellcolor{red} & 0 & \verb~238~ & & \verb~                        var currentEvent = _eventQueues[eventType].Dequeue();~\\
\cellcolor{red} & 0 & \verb~239~ & & \verb~                        if (currentEvent.To != default(IGameEventProcessor))~\\
\cellcolor{red} & 0 & \verb~240~ & & \verb~                        {~\\
\cellcolor{red} & 0 & \verb~241~ & & \verb~                            currentEvent.To.ProcessEvent(currentEvent);~\\
\cellcolor{red} & 0 & \verb~242~ & & \verb~                        }~\\
\cellcolor{red} & 0 & \verb~243~ & & \verb~                        else if (_eventProcessors != null) {~\\
\cellcolor{red} & 0 & \verb~244~ & & \verb~                            foreach (var eventProcessor in _eventProcessors[eventType]) {~\\
\cellcolor{red} & 0 & \verb~245~ & & \verb~                                eventProcessor.ProcessEvent(currentEvent);~\\
\cellcolor{red} & 0 & \verb~246~ & & \verb~                                if (_breakExecution) return;~\\
\cellcolor{red} & 0 & \verb~247~ & & \verb~                            }~\\
\cellcolor{red} & 0 & \verb~248~ & & \verb~                        }~\\
\cellcolor{red} & 0 & \verb~249~ & & \verb~                    }~\\
\cellcolor{red} & 0 & \verb~250~ & & \verb~                }~\\
\cellcolor{red} & 0 & \verb~251~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~252~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~253~ & & \verb~~\\
\cellcolor{gray} &  & \verb~254~ & & \verb~        public void ProcessEvents()~\\
\cellcolor{red} & 0 & \verb~255~ & & \verb~        {~\\
\cellcolor{red} & 0 & \verb~256~ & & \verb~            if (_eventQueues != null) ProcessEvents(_eventQueues.Keys);~\\
\cellcolor{red} & 0 & \verb~257~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~258~ & & \verb~~\\
\cellcolor{gray} &  & \verb~259~ & & \verb~        public void ProcessEventsSequentially()~\\
\cellcolor{green} & 3 & \verb~260~ & & \verb~        {~\\
\cellcolor{orange} & 3 & \verb~261~ & & \verb~            if (_eventQueues != null) ProcessEventsSequentially(_eventQueues.Keys);~\\
\cellcolor{green} & 3 & \verb~262~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~263~ & & \verb~~\\
\cellcolor{gray} &  & \verb~264~ & & \verb~        public void BreakProcessing()~\\
\cellcolor{red} & 0 & \verb~265~ & & \verb~        {~\\
\cellcolor{red} & 0 & \verb~266~ & & \verb~            _breakExecution = true;~\\
\cellcolor{red} & 0 & \verb~267~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~268~ & & \verb~~\\
\cellcolor{gray} &  & \verb~269~ & & \verb~        public void ResetBreakProcessing()~\\
\cellcolor{red} & 0 & \verb~270~ & & \verb~        {~\\
\cellcolor{red} & 0 & \verb~271~ & & \verb~            _breakExecution = false;~\\
\cellcolor{red} & 0 & \verb~272~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~273~ & & \verb~~\\
\cellcolor{gray} &  & \verb~274~ & & \verb~        public void Flush()~\\
\cellcolor{red} & 0 & \verb~275~ & & \verb~        {~\\
\cellcolor{red} & 0 & \verb~276~ & & \verb~            BreakProcessing();~\\
\cellcolor{gray} &  & \verb~277~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~278~ & & \verb~            if (_eventQueues == null) return;~\\
\cellcolor{red} & 0 & \verb~279~ & & \verb~            foreach (var eventType in _eventQueues.Keys)~\\
\cellcolor{red} & 0 & \verb~280~ & & \verb~            {~\\
\cellcolor{red} & 0 & \verb~281~ & & \verb~                _eventQueues[eventType].Flush();~\\
\cellcolor{red} & 0 & \verb~282~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~283~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~284~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~285~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Events.GameEventQueue$<$T$>$}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Events.GameEventQueue$<$T$>$\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{ome/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Events/GameEventQueue.cs}\end{minipage} \\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 30\\
\textbf{Coverable lines:} & 30\\
\textbf{Total lines:} & 97\\
\textbf{Line coverage:} & 0\% (0 of 30)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 2\\
\textbf{Branch coverage:} & 0\% (0 of 2)\\
\textbf{Covered methods:} & 0\\
\textbf{Total methods:} & 12\\
\textbf{Method coverage:} & 0\% (0 of 12)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor()} & 100\% & 1 & 0\%\\
\hline
\textbf{GetEnumerator()} & 100\% & 1 & 0\%\\
\hline
\textbf{System.Collections.I} & 100\% & 1 & 0\%\\
\hline
\textbf{CopyTo(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{System.Collections.I} & 100\% & 1 & 0\%\\
\hline
\textbf{get\_IsSynchronized()} & 100\% & 1 & 0\%\\
\hline
\textbf{get\_SyncRoot()} & 100\% & 1 & 0\%\\
\hline
\textbf{System.Collections.G} & 100\% & 1 & 0\%\\
\hline
\textbf{Enqueue(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{Dequeue()} & 100\% & 1 & 0\%\\
\hline
\textbf{IsEmpty()} & 100\% & 1 & 0\%\\
\hline
\textbf{Flush()} & 0\% & 2 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{ome/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Events/GameEventQueue.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using System;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using System.Collections;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using System.Collections.Concurrent;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~namespace DIKUArcade.Events~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~{~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~    /// Game event queue based on the concurrent queue implementation of the .NET framework~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~    /// offering a simplified facade for the game event bus system.~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~    /// <typeparam name="TP">EventType data type.</typeparam>~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~    public class GameEventQueue<TP> : ICollection, IReadOnlyCollection<TP>~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~    {~\\
\cellcolor{gray} &  & \verb~15~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~        /// Core component of the event queue.~\\
\cellcolor{gray} &  & \verb~17~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~18~ & & \verb~        private readonly ConcurrentQueue<TP> _queue= new ConcurrentQueue<TP>();~\\
\cellcolor{gray} &  & \verb~19~ & & \verb~~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~        /// Enumerator access for event queue.~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~        /// <returns>IEnumerator of concurrent queue.</returns>~\\
\cellcolor{gray} &  & \verb~24~ & & \verb~        public IEnumerator<TP> GetEnumerator()~\\
\cellcolor{red} & 0 & \verb~25~ & & \verb~        {~\\
\cellcolor{red} & 0 & \verb~26~ & & \verb~            return ((IEnumerable<TP>)_queue).GetEnumerator();~\\
\cellcolor{red} & 0 & \verb~27~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~28~ & & \verb~~\\
\cellcolor{gray} &  & \verb~29~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~30~ & & \verb~        /// Generic enumerator access for event queue.~\\
\cellcolor{gray} &  & \verb~31~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~32~ & & \verb~        /// <returns>Generic IEnumerator of concurrent queue.</returns>~\\
\cellcolor{gray} &  & \verb~33~ & & \verb~        IEnumerator IEnumerable.GetEnumerator()~\\
\cellcolor{red} & 0 & \verb~34~ & & \verb~        {~\\
\cellcolor{red} & 0 & \verb~35~ & & \verb~            return GetEnumerator();~\\
\cellcolor{red} & 0 & \verb~36~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~37~ & & \verb~~\\
\cellcolor{gray} &  & \verb~38~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~39~ & & \verb~        /// Copy semantics for fast array initialization and processing.~\\
\cellcolor{gray} &  & \verb~40~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~41~ & & \verb~        /// <param name="array">Copy queue elements to array.</param>~\\
\cellcolor{gray} &  & \verb~42~ & & \verb~        /// <param name="index">Copy queue elements to which index position.</param>~\\
\cellcolor{gray} &  & \verb~43~ & & \verb~        public void CopyTo(Array array, int index)~\\
\cellcolor{red} & 0 & \verb~44~ & & \verb~        {~\\
\cellcolor{red} & 0 & \verb~45~ & & \verb~            _queue.CopyTo((TP[])array, index);~\\
\cellcolor{red} & 0 & \verb~46~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~47~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~48~ & & \verb~        int ICollection.Count => _queue.Count;~\\
\cellcolor{gray} &  & \verb~49~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~50~ & & \verb~        public bool IsSynchronized { get; }~\\
\cellcolor{red} & 0 & \verb~51~ & & \verb~        public object SyncRoot { get; }~\\
\cellcolor{gray} &  & \verb~52~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~53~ & & \verb~        int IReadOnlyCollection<TP>.Count => _queue.Count;~\\
\cellcolor{gray} &  & \verb~54~ & & \verb~~\\
\cellcolor{gray} &  & \verb~55~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~56~ & & \verb~        /// Enqueue a game event in the event queue.~\\
\cellcolor{gray} &  & \verb~57~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~58~ & & \verb~        /// <param name="gameEvent">Event which is enqueued.</param>~\\
\cellcolor{gray} &  & \verb~59~ & & \verb~        public void Enqueue(TP gameEvent)~\\
\cellcolor{red} & 0 & \verb~60~ & & \verb~        {~\\
\cellcolor{red} & 0 & \verb~61~ & & \verb~            _queue.Enqueue(gameEvent);~\\
\cellcolor{red} & 0 & \verb~62~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~63~ & & \verb~~\\
\cellcolor{gray} &  & \verb~64~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~65~ & & \verb~        /// Dequeues a game event from the event queue.~\\
\cellcolor{gray} &  & \verb~66~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~67~ & & \verb~        /// <returns>A game event from event queue.</returns>~\\
\cellcolor{gray} &  & \verb~68~ & & \verb~        public TP Dequeue()~\\
\cellcolor{red} & 0 & \verb~69~ & & \verb~        {~\\
\cellcolor{gray} &  & \verb~70~ & & \verb~            TP gameEvent;~\\
\cellcolor{red} & 0 & \verb~71~ & & \verb~            _queue.TryDequeue(out gameEvent);~\\
\cellcolor{red} & 0 & \verb~72~ & & \verb~            return gameEvent;~\\
\cellcolor{red} & 0 & \verb~73~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~74~ & & \verb~~\\
\cellcolor{gray} &  & \verb~75~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~76~ & & \verb~        /// Checks if the element queue is empty.~\\
\cellcolor{gray} &  & \verb~77~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~78~ & & \verb~        /// <returns>true if game event queue is empty, otherwise false.</returns>~\\
\cellcolor{gray} &  & \verb~79~ & & \verb~        public bool IsEmpty()~\\
\cellcolor{red} & 0 & \verb~80~ & & \verb~        {~\\
\cellcolor{red} & 0 & \verb~81~ & & \verb~            return _queue.IsEmpty;~\\
\cellcolor{red} & 0 & \verb~82~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~83~ & & \verb~~\\
\cellcolor{gray} &  & \verb~84~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~85~ & & \verb~        /// Flushes all elements stored in the event queue.~\\
\cellcolor{gray} &  & \verb~86~ & & \verb~        /// TODO: Method is slow and needs a rewrite.~\\
\cellcolor{gray} &  & \verb~87~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~88~ & & \verb~        public void Flush()~\\
\cellcolor{red} & 0 & \verb~89~ & & \verb~        {~\\
\cellcolor{gray} &  & \verb~90~ & & \verb~            TP gameEventDummy;~\\
\cellcolor{red} & 0 & \verb~91~ & & \verb~            while(!_queue.IsEmpty)~\\
\cellcolor{red} & 0 & \verb~92~ & & \verb~            {~\\
\cellcolor{red} & 0 & \verb~93~ & & \verb~                _queue.TryDequeue(out gameEventDummy);~\\
\cellcolor{red} & 0 & \verb~94~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~95~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~96~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~97~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Events.Generic.GameEventBus$<$T$>$}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Events.Generic.GameEventBus$<$T$>$\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{nus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Events/Generic/GameEventBusT.cs}\end{minipage} \\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 174\\
\textbf{Coverable lines:} & 174\\
\textbf{Total lines:} & 287\\
\textbf{Line coverage:} & 0\% (0 of 174)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 60\\
\textbf{Branch coverage:} & 0\% (0 of 60)\\
\textbf{Covered methods:} & 0\\
\textbf{Total methods:} & 19\\
\textbf{Method coverage:} & 0\% (0 of 19)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor()} & 100\% & 1 & 0\%\\
\hline
\textbf{SwapTimedEventLists(} & 100\% & 1 & 0\%\\
\hline
\textbf{InitializeEventBus(.} & 0\% & 6 & 0\%\\
\hline
\textbf{Subscribe(...)} & 0\% & 4 & 0\%\\
\hline
\textbf{Unsubscribe(...)} & 0\% & 4 & 0\%\\
\hline
\textbf{RegisterTimedEvent(.} & 0\% & 4 & 0\%\\
\hline
\textbf{AddOrResetTimedEvent} & 0\% & 4 & 0\%\\
\hline
\textbf{CancelTimedEvent(...} & 0\% & 4 & 0\%\\
\hline
\textbf{ResetTimedEvent(...)} & 0\% & 2 & 0\%\\
\hline
\textbf{HasTimedEvent(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{RegisterEvent(...)} & 0\% & 2 & 0\%\\
\hline
\textbf{ProcessTimedEvents()} & 0\% & 4 & 0\%\\
\hline
\textbf{ProcessEvents(...)} & 0\% & 2 & 0\%\\
\hline
\textbf{ProcessEventsSequent} & 0\% & 16 & 0\%\\
\hline
\textbf{ProcessEvents()} & 0\% & 2 & 0\%\\
\hline
\textbf{ProcessEventsSequent} & 0\% & 2 & 0\%\\
\hline
\textbf{BreakProcessing()} & 100\% & 1 & 0\%\\
\hline
\textbf{ResetBreakProcessing} & 100\% & 1 & 0\%\\
\hline
\textbf{Flush()} & 0\% & 4 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{nus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Events/Generic/GameEventBusT.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using System;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using System.Threading.Tasks;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~using DIKUArcade.Timers;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~namespace DIKUArcade.Events.Generic~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~{~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~    /// Generic version of the DIKUArcade.Events.GameEventBus class, which uses the generic type EventT~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~    /// as the underlying event type enum.~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~    /// GameEventBus is the core module for processing events in the DIKUArcade game engine. Modules can register events~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~    /// add them to the queues. Events are distinguished by event types to improve processing performance. Event process~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~    /// can register/subscribe themself to receive events of a certain event type. For a single event, all processors ar~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~    /// called with this event (broadcast semantic).~\\
\cellcolor{gray} &  & \verb~15~ & & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~    /// <typeparam name="EventT">Enumeration type representing type of game events.</typeparam>~\\
\cellcolor{gray} &  & \verb~17~ & & \verb~    public class GameEventBus<EventT> : IGameEventBus<EventT>, ITimedGameEventBus<EventT>,~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~        IGameEventBusController<EventT> where EventT : System.Enum~\\
\cellcolor{gray} &  & \verb~19~ & & \verb~    {~\\
\cellcolor{red} & 0 & \verb~20~ & & \verb~        private bool _initialized = false;~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~        /// Dictionary of registered event processors for a given game event type.~\\
\cellcolor{gray} &  & \verb~24~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~25~ & & \verb~        private Dictionary<EventT, ICollection<IGameEventProcessor<EventT>>> _eventProcessors;~\\
\cellcolor{gray} &  & \verb~26~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~        /// Dictionary of game event queues for different game event types.~\\
\cellcolor{gray} &  & \verb~28~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~29~ & & \verb~        private Dictionary<EventT, GameEventQueue<GameEvent<EventT>>> _eventQueues;~\\
\cellcolor{gray} &  & \verb~30~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~31~ & & \verb~        /// Stops processing the pipeline, e.g. needed due real-time constraints.~\\
\cellcolor{gray} &  & \verb~32~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~33~ & & \verb~        private bool _breakExecution = false;~\\
\cellcolor{gray} &  & \verb~34~ & & \verb~~\\
\cellcolor{gray} &  & \verb~35~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~36~ & & \verb~        /// List of events which must be processed after a specified time interval has passed.~\\
\cellcolor{gray} &  & \verb~37~ & & \verb~        /// We use a double-buffered system.~\\
\cellcolor{gray} &  & \verb~38~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~39~ & & \verb~        private List<TimedGameEvent<EventT>>[] _timedEventLists;~\\
\cellcolor{red} & 0 & \verb~40~ & & \verb~        private int _activeTimedEventList = 0;~\\
\cellcolor{red} & 0 & \verb~41~ & & \verb~        private int _inactiveTimedEventList = 1;~\\
\cellcolor{gray} &  & \verb~42~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~43~ & & \verb~        private void SwapTimedEventLists() {~\\
\cellcolor{red} & 0 & \verb~44~ & & \verb~            _activeTimedEventList = (_activeTimedEventList + 1) % 2;~\\
\cellcolor{red} & 0 & \verb~45~ & & \verb~            _inactiveTimedEventList = (_inactiveTimedEventList + 1) % 2;~\\
\cellcolor{red} & 0 & \verb~46~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~47~ & & \verb~~\\
\cellcolor{gray} &  & \verb~48~ & & \verb~~\\
\cellcolor{gray} &  & \verb~49~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~50~ & & \verb~        /// Initialized the event bus to handle the specified event types.~\\
\cellcolor{gray} &  & \verb~51~ & & \verb~        /// An exception is thrown if called on an already initialized GameEventBus.~\\
\cellcolor{gray} &  & \verb~52~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~53~ & & \verb~        /// <exception cref="InvalidOperationException"></exception>~\\
\cellcolor{gray} &  & \verb~54~ & & \verb~        public void InitializeEventBus(ICollection<EventT> eventTypeList)~\\
\cellcolor{red} & 0 & \verb~55~ & & \verb~        {~\\
\cellcolor{red} & 0 & \verb~56~ & & \verb~            if (_initialized) {~\\
\cellcolor{red} & 0 & \verb~57~ & & \verb~                throw new InvalidOperationException("GameEventBus is already initialized!");~\\
\cellcolor{gray} &  & \verb~58~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~59~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~60~ & & \verb~            _eventProcessors= new Dictionary<EventT, ICollection<IGameEventProcessor<EventT>>>();~\\
\cellcolor{red} & 0 & \verb~61~ & & \verb~            _eventQueues= new Dictionary<EventT, GameEventQueue<GameEvent<EventT>>>();~\\
\cellcolor{gray} &  & \verb~62~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~63~ & & \verb~            if (eventTypeList != null) {~\\
\cellcolor{red} & 0 & \verb~64~ & & \verb~                foreach (var eventType in eventTypeList)~\\
\cellcolor{red} & 0 & \verb~65~ & & \verb~                {~\\
\cellcolor{red} & 0 & \verb~66~ & & \verb~                    _eventProcessors.Add(eventType, new List<IGameEventProcessor<EventT>>());~\\
\cellcolor{red} & 0 & \verb~67~ & & \verb~                    _eventQueues.Add(eventType, new GameEventQueue<GameEvent<EventT>>());~\\
\cellcolor{red} & 0 & \verb~68~ & & \verb~                }~\\
\cellcolor{red} & 0 & \verb~69~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~70~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~71~ & & \verb~            _timedEventLists = new List<TimedGameEvent<EventT>>[2] {~\\
\cellcolor{red} & 0 & \verb~72~ & & \verb~                new List<TimedGameEvent<EventT>>(),~\\
\cellcolor{red} & 0 & \verb~73~ & & \verb~                new List<TimedGameEvent<EventT>>()~\\
\cellcolor{red} & 0 & \verb~74~ & & \verb~            };~\\
\cellcolor{gray} &  & \verb~75~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~76~ & & \verb~            _initialized = true;~\\
\cellcolor{red} & 0 & \verb~77~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~78~ & & \verb~~\\
\cellcolor{gray} &  & \verb~79~ & & \verb~        public void Subscribe(EventT eventType, IGameEventProcessor<EventT> gameEventProcessor)~\\
\cellcolor{red} & 0 & \verb~80~ & & \verb~        {~\\
\cellcolor{red} & 0 & \verb~81~ & & \verb~            if (gameEventProcessor == default(IGameEventProcessor<EventT>))~\\
\cellcolor{red} & 0 & \verb~82~ & & \verb~                throw new ArgumentNullException("Parameter gameEventProcessor must not be null.");~\\
\cellcolor{gray} &  & \verb~83~ & & \verb~~\\
\cellcolor{gray} &  & \verb~84~ & & \verb~            try~\\
\cellcolor{red} & 0 & \verb~85~ & & \verb~            {~\\
\cellcolor{red} & 0 & \verb~86~ & & \verb~                _eventProcessors?[eventType].Add(gameEventProcessor);~\\
\cellcolor{red} & 0 & \verb~87~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~88~ & & \verb~            catch (Exception e)~\\
\cellcolor{red} & 0 & \verb~89~ & & \verb~            {~\\
\cellcolor{red} & 0 & \verb~90~ & & \verb~                throw new Exception($"Could not subscribe event processor. Check eventType! {e}");~\\
\cellcolor{gray} &  & \verb~91~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~92~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~93~ & & \verb~~\\
\cellcolor{gray} &  & \verb~94~ & & \verb~        public void Unsubscribe(EventT eventType, IGameEventProcessor<EventT> gameEventProcessor)~\\
\cellcolor{red} & 0 & \verb~95~ & & \verb~        {~\\
\cellcolor{red} & 0 & \verb~96~ & & \verb~            if (gameEventProcessor == default(IGameEventProcessor<EventT>))~\\
\cellcolor{red} & 0 & \verb~97~ & & \verb~                throw new ArgumentNullException("Parameter gameEventProcessor must not be null.");~\\
\cellcolor{gray} &  & \verb~98~ & & \verb~~\\
\cellcolor{gray} &  & \verb~99~ & & \verb~            try~\\
\cellcolor{red} & 0 & \verb~100~ & & \verb~            {~\\
\cellcolor{red} & 0 & \verb~101~ & & \verb~                _eventProcessors?[eventType].Remove(gameEventProcessor);~\\
\cellcolor{red} & 0 & \verb~102~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~103~ & & \verb~            catch (Exception e)~\\
\cellcolor{red} & 0 & \verb~104~ & & \verb~            {~\\
\cellcolor{red} & 0 & \verb~105~ & & \verb~                throw new Exception($"Could not unsubsribe event processor. Check eventType or processor is unregistered~\\
\cellcolor{gray} &  & \verb~106~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~107~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~108~ & & \verb~~\\
\cellcolor{gray} &  & \verb~109~ & & \verb~~\\
\cellcolor{gray} &  & \verb~110~ & & \verb~        #region TIMED_EVENTS~\\
\cellcolor{gray} &  & \verb~111~ & & \verb~~\\
\cellcolor{gray} &  & \verb~112~ & & \verb~        public void RegisterTimedEvent(GameEvent<EventT> gameEvent, TimePeriod timePeriod)~\\
\cellcolor{red} & 0 & \verb~113~ & & \verb~        {~\\
\cellcolor{gray} &  & \verb~114~ & & \verb~            // do not insert already registered events:~\\
\cellcolor{red} & 0 & \verb~115~ & & \verb~            if (gameEvent.Id != default(uint)) {~\\
\cellcolor{red} & 0 & \verb~116~ & & \verb~                if (_timedEventLists[_activeTimedEventList].Exists(e => e.GameEvent.Id == gameEvent.Id)) {~\\
\cellcolor{red} & 0 & \verb~117~ & & \verb~                    return;~\\
\cellcolor{gray} &  & \verb~118~ & & \verb~                }~\\
\cellcolor{red} & 0 & \verb~119~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~120~ & & \verb~            _timedEventLists[_activeTimedEventList].Add(new TimedGameEvent<EventT>(timePeriod, gameEvent));~\\
\cellcolor{red} & 0 & \verb~121~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~122~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~123~ & & \verb~        public void AddOrResetTimedEvent(GameEvent<EventT> gameEvent, TimePeriod timePeriod) {~\\
\cellcolor{red} & 0 & \verb~124~ & & \verb~            if (gameEvent.Id != default(uint)) {~\\
\cellcolor{gray} &  & \verb~125~ & & \verb~                // search for an item which matches the Id of the specified event~\\
\cellcolor{red} & 0 & \verb~126~ & & \verb~                var search = _timedEventLists[_activeTimedEventList].FindIndex(e => e.GameEvent.Id == gameEvent.Id);~\\
\cellcolor{gray} &  & \verb~127~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~128~ & & \verb~                if (search >= 0) {~\\
\cellcolor{gray} &  & \verb~129~ & & \verb~                    // event with Id already exists, so we reset its time period~\\
\cellcolor{red} & 0 & \verb~130~ & & \verb~                    _timedEventLists[_activeTimedEventList][search] =~\\
\cellcolor{red} & 0 & \verb~131~ & & \verb~                        new TimedGameEvent<EventT>(timePeriod, _timedEventLists[_activeTimedEventList][search].GameEvent~\\
\cellcolor{red} & 0 & \verb~132~ & & \verb~                    return;~\\
\cellcolor{gray} &  & \verb~133~ & & \verb~                }~\\
\cellcolor{red} & 0 & \verb~134~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~135~ & & \verb~            // input event does not have an Id, or it has an Id but does not exist in list.~\\
\cellcolor{gray} &  & \verb~136~ & & \verb~            // In either case, we add it.~\\
\cellcolor{red} & 0 & \verb~137~ & & \verb~            _timedEventLists[_activeTimedEventList].Add(new TimedGameEvent<EventT>(timePeriod, gameEvent));~\\
\cellcolor{red} & 0 & \verb~138~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~139~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~140~ & & \verb~        public bool CancelTimedEvent(uint eventId) {~\\
\cellcolor{red} & 0 & \verb~141~ & & \verb~            bool cancelled = false;~\\
\cellcolor{red} & 0 & \verb~142~ & & \verb~            _timedEventLists[_inactiveTimedEventList].Clear();~\\
\cellcolor{red} & 0 & \verb~143~ & & \verb~            foreach (var e in _timedEventLists[_activeTimedEventList]) {~\\
\cellcolor{red} & 0 & \verb~144~ & & \verb~                if (e.GameEvent.Id != eventId) {~\\
\cellcolor{red} & 0 & \verb~145~ & & \verb~                    _timedEventLists[_inactiveTimedEventList].Add(e);~\\
\cellcolor{red} & 0 & \verb~146~ & & \verb~                } else {~\\
\cellcolor{red} & 0 & \verb~147~ & & \verb~                    cancelled = true;~\\
\cellcolor{red} & 0 & \verb~148~ & & \verb~                }~\\
\cellcolor{red} & 0 & \verb~149~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~150~ & & \verb~~\\
\cellcolor{gray} &  & \verb~151~ & & \verb~            // swap the timed-event lists~\\
\cellcolor{red} & 0 & \verb~152~ & & \verb~            SwapTimedEventLists();~\\
\cellcolor{red} & 0 & \verb~153~ & & \verb~            return cancelled;~\\
\cellcolor{red} & 0 & \verb~154~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~155~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~156~ & & \verb~        public bool ResetTimedEvent(uint eventId, TimePeriod timePeriod) {~\\
\cellcolor{red} & 0 & \verb~157~ & & \verb~            var search = _timedEventLists[_activeTimedEventList].FindIndex(e => e.GameEvent.Id == eventId);~\\
\cellcolor{red} & 0 & \verb~158~ & & \verb~            if (search >= 0) {~\\
\cellcolor{red} & 0 & \verb~159~ & & \verb~                _timedEventLists[_activeTimedEventList][search] =~\\
\cellcolor{red} & 0 & \verb~160~ & & \verb~                    new TimedGameEvent<EventT>(timePeriod, _timedEventLists[_activeTimedEventList][search].GameEvent);~\\
\cellcolor{red} & 0 & \verb~161~ & & \verb~                return true;~\\
\cellcolor{gray} &  & \verb~162~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~163~ & & \verb~            return false;~\\
\cellcolor{red} & 0 & \verb~164~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~165~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~166~ & & \verb~        public bool HasTimedEvent(uint eventId) {~\\
\cellcolor{red} & 0 & \verb~167~ & & \verb~            return _timedEventLists[_activeTimedEventList].FindIndex(e => e.GameEvent.Id == eventId) >= 0;~\\
\cellcolor{red} & 0 & \verb~168~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~169~ & & \verb~~\\
\cellcolor{gray} &  & \verb~170~ & & \verb~        #endregion // TIMED_EVENTS~\\
\cellcolor{gray} &  & \verb~171~ & & \verb~~\\
\cellcolor{gray} &  & \verb~172~ & & \verb~~\\
\cellcolor{gray} &  & \verb~173~ & & \verb~        public void RegisterEvent(GameEvent<EventT> gameEvent)~\\
\cellcolor{red} & 0 & \verb~174~ & & \verb~        {~\\
\cellcolor{gray} &  & \verb~175~ & & \verb~            try~\\
\cellcolor{red} & 0 & \verb~176~ & & \verb~            {~\\
\cellcolor{red} & 0 & \verb~177~ & & \verb~                _eventQueues?[gameEvent.EventType].Enqueue(gameEvent);~\\
\cellcolor{red} & 0 & \verb~178~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~179~ & & \verb~            catch (Exception e)~\\
\cellcolor{red} & 0 & \verb~180~ & & \verb~            {~\\
\cellcolor{red} & 0 & \verb~181~ & & \verb~                throw new Exception($"Could not register event. Did you Initialize the EventBus with {e.Message}");~\\
\cellcolor{gray} &  & \verb~182~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~183~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~184~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~185~ & & \verb~        private void ProcessTimedEvents() {~\\
\cellcolor{red} & 0 & \verb~186~ & & \verb~            _timedEventLists[_inactiveTimedEventList].Clear();~\\
\cellcolor{gray} &  & \verb~187~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~188~ & & \verb~            var currentTime = Timers.StaticTimer.GetElapsedMilliseconds();~\\
\cellcolor{red} & 0 & \verb~189~ & & \verb~            foreach (var e in _timedEventLists[_activeTimedEventList]) {~\\
\cellcolor{red} & 0 & \verb~190~ & & \verb~                if (e.HasExpired(currentTime)) {~\\
\cellcolor{red} & 0 & \verb~191~ & & \verb~                    RegisterEvent(e.GameEvent);~\\
\cellcolor{red} & 0 & \verb~192~ & & \verb~                } else {~\\
\cellcolor{red} & 0 & \verb~193~ & & \verb~                    _timedEventLists[_inactiveTimedEventList].Add(e);~\\
\cellcolor{red} & 0 & \verb~194~ & & \verb~                }~\\
\cellcolor{red} & 0 & \verb~195~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~196~ & & \verb~            SwapTimedEventLists();~\\
\cellcolor{red} & 0 & \verb~197~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~198~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~199~ & & \verb~        public void ProcessEvents(IEnumerable<EventT> processOrder) {~\\
\cellcolor{red} & 0 & \verb~200~ & & \verb~            if(processOrder==default(IEnumerable<EventT>)) {~\\
\cellcolor{red} & 0 & \verb~201~ & & \verb~                throw new ArgumentNullException();~\\
\cellcolor{gray} &  & \verb~202~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~203~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~204~ & & \verb~            ProcessTimedEvents();~\\
\cellcolor{gray} &  & \verb~205~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~206~ & & \verb~            Parallel.ForEach<EventT>(processOrder, new Action<EventT, ParallelLoopState>(~\\
\cellcolor{red} & 0 & \verb~207~ & & \verb~                (eventType, loopState) => {~\\
\cellcolor{red} & 0 & \verb~208~ & & \verb~                    if (_eventQueues != null) {~\\
\cellcolor{red} & 0 & \verb~209~ & & \verb~                        while (!_eventQueues[eventType].IsEmpty()) {~\\
\cellcolor{red} & 0 & \verb~210~ & & \verb~                            var currentEvent = _eventQueues[eventType].Dequeue();~\\
\cellcolor{red} & 0 & \verb~211~ & & \verb~                            if (currentEvent.To != default(IGameEventProcessor<EventT>))~\\
\cellcolor{red} & 0 & \verb~212~ & & \verb~                            {~\\
\cellcolor{red} & 0 & \verb~213~ & & \verb~                                currentEvent.To.ProcessEvent(currentEvent);~\\
\cellcolor{red} & 0 & \verb~214~ & & \verb~                            }~\\
\cellcolor{red} & 0 & \verb~215~ & & \verb~                            else if (_eventProcessors != null)~\\
\cellcolor{red} & 0 & \verb~216~ & & \verb~                            {~\\
\cellcolor{red} & 0 & \verb~217~ & & \verb~                                foreach (var eventProcessor in _eventProcessors[eventType]) {~\\
\cellcolor{red} & 0 & \verb~218~ & & \verb~                                    eventProcessor.ProcessEvent(currentEvent);~\\
\cellcolor{red} & 0 & \verb~219~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~220~ & & \verb~                                    if (_breakExecution) loopState.Break();~\\
\cellcolor{red} & 0 & \verb~221~ & & \verb~                                }~\\
\cellcolor{red} & 0 & \verb~222~ & & \verb~                            }~\\
\cellcolor{red} & 0 & \verb~223~ & & \verb~                        }~\\
\cellcolor{red} & 0 & \verb~224~ & & \verb~                    }~\\
\cellcolor{red} & 0 & \verb~225~ & & \verb~            }));~\\
\cellcolor{gray} &  & \verb~226~ & & \verb~~\\
\cellcolor{gray} &  & \verb~227~ & & \verb~            // semantic of Parallel.ForEach is it blocks until all parallel threads are finished~\\
\cellcolor{red} & 0 & \verb~228~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~229~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~230~ & & \verb~        public void ProcessEventsSequentially(IEnumerable<EventT> processOrder) {~\\
\cellcolor{red} & 0 & \verb~231~ & & \verb~            if(processOrder==default(IEnumerable<EventT>)) {~\\
\cellcolor{red} & 0 & \verb~232~ & & \verb~                throw new ArgumentNullException();~\\
\cellcolor{gray} &  & \verb~233~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~234~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~235~ & & \verb~            ProcessTimedEvents();~\\
\cellcolor{gray} &  & \verb~236~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~237~ & & \verb~            foreach(EventT eventType in processOrder) {~\\
\cellcolor{red} & 0 & \verb~238~ & & \verb~                if (_eventQueues != null) {~\\
\cellcolor{red} & 0 & \verb~239~ & & \verb~                    while (!_eventQueues[eventType].IsEmpty()) {~\\
\cellcolor{red} & 0 & \verb~240~ & & \verb~                        var currentEvent = _eventQueues[eventType].Dequeue();~\\
\cellcolor{red} & 0 & \verb~241~ & & \verb~                        if (currentEvent.To != default(IGameEventProcessor<EventT>))~\\
\cellcolor{red} & 0 & \verb~242~ & & \verb~                        {~\\
\cellcolor{red} & 0 & \verb~243~ & & \verb~                            currentEvent.To.ProcessEvent(currentEvent);~\\
\cellcolor{red} & 0 & \verb~244~ & & \verb~                        }~\\
\cellcolor{red} & 0 & \verb~245~ & & \verb~                        else if (_eventProcessors != null) {~\\
\cellcolor{red} & 0 & \verb~246~ & & \verb~                            foreach (var eventProcessor in _eventProcessors[eventType]) {~\\
\cellcolor{red} & 0 & \verb~247~ & & \verb~                                eventProcessor.ProcessEvent(currentEvent);~\\
\cellcolor{red} & 0 & \verb~248~ & & \verb~                                if (_breakExecution) return;~\\
\cellcolor{red} & 0 & \verb~249~ & & \verb~                            }~\\
\cellcolor{red} & 0 & \verb~250~ & & \verb~                        }~\\
\cellcolor{red} & 0 & \verb~251~ & & \verb~                    }~\\
\cellcolor{red} & 0 & \verb~252~ & & \verb~                }~\\
\cellcolor{red} & 0 & \verb~253~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~254~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~255~ & & \verb~~\\
\cellcolor{gray} &  & \verb~256~ & & \verb~        public void ProcessEvents()~\\
\cellcolor{red} & 0 & \verb~257~ & & \verb~        {~\\
\cellcolor{red} & 0 & \verb~258~ & & \verb~            if (_eventQueues != null) ProcessEvents(_eventQueues.Keys);~\\
\cellcolor{red} & 0 & \verb~259~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~260~ & & \verb~~\\
\cellcolor{gray} &  & \verb~261~ & & \verb~        public void ProcessEventsSequentially()~\\
\cellcolor{red} & 0 & \verb~262~ & & \verb~        {~\\
\cellcolor{red} & 0 & \verb~263~ & & \verb~            if (_eventQueues != null) ProcessEventsSequentially(_eventQueues.Keys);~\\
\cellcolor{red} & 0 & \verb~264~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~265~ & & \verb~~\\
\cellcolor{gray} &  & \verb~266~ & & \verb~        public void BreakProcessing()~\\
\cellcolor{red} & 0 & \verb~267~ & & \verb~        {~\\
\cellcolor{red} & 0 & \verb~268~ & & \verb~            _breakExecution = true;~\\
\cellcolor{red} & 0 & \verb~269~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~270~ & & \verb~~\\
\cellcolor{gray} &  & \verb~271~ & & \verb~        public void ResetBreakProcessing()~\\
\cellcolor{red} & 0 & \verb~272~ & & \verb~        {~\\
\cellcolor{red} & 0 & \verb~273~ & & \verb~            _breakExecution = false;~\\
\cellcolor{red} & 0 & \verb~274~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~275~ & & \verb~~\\
\cellcolor{gray} &  & \verb~276~ & & \verb~        public void Flush()~\\
\cellcolor{red} & 0 & \verb~277~ & & \verb~        {~\\
\cellcolor{red} & 0 & \verb~278~ & & \verb~            BreakProcessing();~\\
\cellcolor{gray} &  & \verb~279~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~280~ & & \verb~            if (_eventQueues == null) return;~\\
\cellcolor{red} & 0 & \verb~281~ & & \verb~            foreach (var eventType in _eventQueues.Keys)~\\
\cellcolor{red} & 0 & \verb~282~ & & \verb~            {~\\
\cellcolor{red} & 0 & \verb~283~ & & \verb~                _eventQueues[eventType].Flush();~\\
\cellcolor{red} & 0 & \verb~284~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~285~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~286~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~287~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Events.Generic.TimedGameEvent$<$T$>$}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Events.Generic.TimedGameEvent$<$T$>$\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{s/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Events/Generic/TimedGameEventT.cs}\end{minipage} \\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 13\\
\textbf{Coverable lines:} & 13\\
\textbf{Total lines:} & 46\\
\textbf{Line coverage:} & 0\% (0 of 13)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 0\\
\textbf{Covered methods:} & 0\\
\textbf{Total methods:} & 4\\
\textbf{Method coverage:} & 0\% (0 of 4)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{get\_GameEvent()} & 100\% & 1 & 0\%\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{HasExpired()} & 100\% & 1 & 0\%\\
\hline
\textbf{HasExpired(...)} & 100\% & 1 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{s/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Events/Generic/TimedGameEventT.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Timers;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~namespace DIKUArcade.Events.Generic~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~{~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~    /// Generic version of the DIKUArcade.Events.TimedGameEvent struct.~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~    /// Represents a GameEvent together with an expiration time.~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~    /// When a TimedGameEvent has expired it is ready for processing by a GameEventBus.~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~    /// <typeparam name="EventT">Enumeration type representing type of game events.</typeparam>~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~    public struct TimedGameEvent<EventT> where EventT : System.Enum~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~    {~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~        /// The GameEvent<EventT> which this object wraps around.~\\
\cellcolor{gray} &  & \verb~15~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~16~ & & \verb~        public GameEvent<EventT> GameEvent { get; private set; }~\\
\cellcolor{gray} &  & \verb~17~ & & \verb~~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~        private readonly TimePeriod timeSpan;~\\
\cellcolor{gray} &  & \verb~19~ & & \verb~        private readonly long timeOfCreation;~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~21~ & & \verb~        public TimedGameEvent(TimePeriod timeSpan, GameEvent<EventT> gameEvent) {~\\
\cellcolor{red} & 0 & \verb~22~ & & \verb~            this.timeSpan = timeSpan;~\\
\cellcolor{red} & 0 & \verb~23~ & & \verb~            GameEvent = gameEvent;~\\
\cellcolor{gray} &  & \verb~24~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~25~ & & \verb~            timeOfCreation = StaticTimer.GetElapsedMilliseconds();~\\
\cellcolor{red} & 0 & \verb~26~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~~\\
\cellcolor{gray} &  & \verb~28~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~29~ & & \verb~        /// Measure time and check if the event is ready for processing.~\\
\cellcolor{gray} &  & \verb~30~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~31~ & & \verb~        public bool HasExpired() {~\\
\cellcolor{red} & 0 & \verb~32~ & & \verb~            var now = StaticTimer.GetElapsedMilliseconds();~\\
\cellcolor{red} & 0 & \verb~33~ & & \verb~            return (now - timeOfCreation) > timeSpan.ToMilliseconds();~\\
\cellcolor{red} & 0 & \verb~34~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~35~ & & \verb~~\\
\cellcolor{gray} &  & \verb~36~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~37~ & & \verb~        /// Measure time and check if the event is ready for processing,~\\
\cellcolor{gray} &  & \verb~38~ & & \verb~        /// but where current timestamp is provided in milliseconds.~\\
\cellcolor{gray} &  & \verb~39~ & & \verb~        /// This is useful if checking multiple TimedEvents in sequence without~\\
\cellcolor{gray} &  & \verb~40~ & & \verb~        /// having to get current timestamp for each one.~\\
\cellcolor{gray} &  & \verb~41~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~42~ & & \verb~        public bool HasExpired(long currentTime) {~\\
\cellcolor{red} & 0 & \verb~43~ & & \verb~            return (currentTime - timeOfCreation) > timeSpan.ToMilliseconds();~\\
\cellcolor{red} & 0 & \verb~44~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~45~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~46~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Events.TimedGameEvent}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Events.TimedGameEvent\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{ome/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Events/TimedGameEvent.cs}\end{minipage} \\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 13\\
\textbf{Coverable lines:} & 13\\
\textbf{Total lines:} & 43\\
\textbf{Line coverage:} & 0\% (0 of 13)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 0\\
\textbf{Covered methods:} & 0\\
\textbf{Total methods:} & 4\\
\textbf{Method coverage:} & 0\% (0 of 4)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{get\_GameEvent()} & 100\% & 1 & 0\%\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{HasExpired()} & 100\% & 1 & 0\%\\
\hline
\textbf{HasExpired(...)} & 100\% & 1 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{ome/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Events/TimedGameEvent.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Timers;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~namespace DIKUArcade.Events {~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~    /// Represents a GameEvent together with an expiration time.~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~    /// When a TimedGameEvent has expired it is ready for processing by a GameEventBus.~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~    public struct TimedGameEvent~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~    {~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~        /// The GameEvent which this object wraps around.~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~13~ & & \verb~        public GameEvent GameEvent { get; private set; }~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~~\\
\cellcolor{gray} &  & \verb~15~ & & \verb~        private readonly TimePeriod timeSpan;~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~        private readonly long timeOfCreation;~\\
\cellcolor{gray} &  & \verb~17~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~18~ & & \verb~        public TimedGameEvent(TimePeriod timeSpan, GameEvent gameEvent) {~\\
\cellcolor{red} & 0 & \verb~19~ & & \verb~            this.timeSpan = timeSpan;~\\
\cellcolor{red} & 0 & \verb~20~ & & \verb~            GameEvent = gameEvent;~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~22~ & & \verb~            timeOfCreation = StaticTimer.GetElapsedMilliseconds();~\\
\cellcolor{red} & 0 & \verb~23~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~24~ & & \verb~~\\
\cellcolor{gray} &  & \verb~25~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~26~ & & \verb~        /// Measure time and check if the event is ready for processing.~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~28~ & & \verb~        public bool HasExpired() {~\\
\cellcolor{red} & 0 & \verb~29~ & & \verb~            var now = StaticTimer.GetElapsedMilliseconds();~\\
\cellcolor{red} & 0 & \verb~30~ & & \verb~            return (now - timeOfCreation) > timeSpan.ToMilliseconds();~\\
\cellcolor{red} & 0 & \verb~31~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~32~ & & \verb~~\\
\cellcolor{gray} &  & \verb~33~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~34~ & & \verb~        /// Measure time and check if the event is ready for processing,~\\
\cellcolor{gray} &  & \verb~35~ & & \verb~        /// but where current timestamp is provided in milliseconds.~\\
\cellcolor{gray} &  & \verb~36~ & & \verb~        /// This is useful if checking multiple TimedEvents in sequence without~\\
\cellcolor{gray} &  & \verb~37~ & & \verb~        /// having to get current timestamp for each one.~\\
\cellcolor{gray} &  & \verb~38~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~39~ & & \verb~        public bool HasExpired(long currentTimeMs) {~\\
\cellcolor{red} & 0 & \verb~40~ & & \verb~            return (currentTimeMs - timeOfCreation) > timeSpan.ToMilliseconds();~\\
\cellcolor{red} & 0 & \verb~41~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~42~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~43~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Graphics.Animation}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Graphics.Animation\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Graphics/Animation.cs}\end{minipage} \\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 15\\
\textbf{Coverable lines:} & 15\\
\textbf{Total lines:} & 44\\
\textbf{Line coverage:} & 0\% (0 of 15)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 0\\
\textbf{Covered methods:} & 0\\
\textbf{Total methods:} & 7\\
\textbf{Method coverage:} & 0\% (0 of 7)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{get\_Duration()} & 100\% & 1 & 0\%\\
\hline
\textbf{get\_Shape()} & 100\% & 1 & 0\%\\
\hline
\textbf{get\_Stride()} & 100\% & 1 & 0\%\\
\hline
\textbf{.ctor()} & 100\% & 1 & 0\%\\
\hline
\textbf{IsActive()} & 100\% & 1 & 0\%\\
\hline
\textbf{RenderAnimation()} & 100\% & 1 & 0\%\\
\hline
\textbf{ResetAnimation()} & 100\% & 1 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Graphics/Animation.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using System;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using DIKUArcade.Timers;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~namespace DIKUArcade.Graphics {~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~    public class Animation {~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~        /// Duration of this animation, in milliseconds~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~10~ & & \verb~        public int Duration { get; set; }~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~        /// Position and Extent of this animation~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~15~ & & \verb~        public StationaryShape Shape { get; set; }~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~~\\
\cellcolor{gray} &  & \verb~17~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~        /// ImageStride used for animation~\\
\cellcolor{gray} &  & \verb~19~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~20~ & & \verb~        public ImageStride Stride { get; set; }~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~        private double timeOfCreation;~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~24~ & & \verb~        public Animation() {~\\
\cellcolor{red} & 0 & \verb~25~ & & \verb~            timeOfCreation = StaticTimer.GetElapsedMilliseconds();~\\
\cellcolor{red} & 0 & \verb~26~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~~\\
\cellcolor{gray} &  & \verb~28~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~29~ & & \verb~        /// The animation is still considered active if the specified duration~\\
\cellcolor{gray} &  & \verb~30~ & & \verb~        /// in milliseconds has not yet passed.~\\
\cellcolor{gray} &  & \verb~31~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~32~ & & \verb~        public bool IsActive() {~\\
\cellcolor{red} & 0 & \verb~33~ & & \verb~            return timeOfCreation + Duration > StaticTimer.GetElapsedMilliseconds();~\\
\cellcolor{red} & 0 & \verb~34~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~35~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~36~ & & \verb~        public void RenderAnimation() {~\\
\cellcolor{red} & 0 & \verb~37~ & & \verb~            Stride.Render(Shape);~\\
\cellcolor{red} & 0 & \verb~38~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~39~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~40~ & & \verb~        public void ResetAnimation() {~\\
\cellcolor{red} & 0 & \verb~41~ & & \verb~            timeOfCreation = StaticTimer.GetElapsedMilliseconds();~\\
\cellcolor{red} & 0 & \verb~42~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~43~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~44~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Graphics.AnimationContainer}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Graphics.AnimationContainer\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{gnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Graphics/AnimationContainer.cs}\end{minipage} \\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 40\\
\textbf{Coverable lines:} & 40\\
\textbf{Total lines:} & 72\\
\textbf{Line coverage:} & 0\% (0 of 40)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 14\\
\textbf{Branch coverage:} & 0\% (0 of 14)\\
\textbf{Covered methods:} & 0\\
\textbf{Total methods:} & 5\\
\textbf{Method coverage:} & 0\% (0 of 5)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{get\_Occupied()} & 100\% & 1 & 0\%\\
\hline
\textbf{.ctor(...)} & 0\% & 2 & 0\%\\
\hline
\textbf{ResetContainer()} & 0\% & 2 & 0\%\\
\hline
\textbf{AddAnimation(...)} & 0\% & 4 & 0\%\\
\hline
\textbf{RenderAnimations()} & 0\% & 6 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{gnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Graphics/AnimationContainer.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using System;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~namespace DIKUArcade.Graphics {~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~    public class AnimationContainer {~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~        internal class OccupyValue<T> {~\\
\cellcolor{red} & 0 & \verb~7~ & & \verb~            public bool Occupied { get; set; }~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~            public T Value;~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~        private OccupyValue<Animation>[] container;~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~        private int size;~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~14~ & & \verb~        public AnimationContainer(int size) {~\\
\cellcolor{red} & 0 & \verb~15~ & & \verb~            if (size < 0) {~\\
\cellcolor{red} & 0 & \verb~16~ & & \verb~                throw new ArgumentOutOfRangeException(~\\
\cellcolor{red} & 0 & \verb~17~ & & \verb~                    $"Cannot instantiate Animation container with negative size: {size}");~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~19~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~20~ & & \verb~            container = new OccupyValue<Animation>[size];~\\
\cellcolor{red} & 0 & \verb~21~ & & \verb~            this.size = size;~\\
\cellcolor{red} & 0 & \verb~22~ & & \verb~            ResetContainer();~\\
\cellcolor{red} & 0 & \verb~23~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~24~ & & \verb~~\\
\cellcolor{gray} &  & \verb~25~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~26~ & & \verb~        /// Clear this container of all bound animation objects~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~28~ & & \verb~        public void ResetContainer() {~\\
\cellcolor{red} & 0 & \verb~29~ & & \verb~            for (int i = 0; i < size; i++) {~\\
\cellcolor{red} & 0 & \verb~30~ & & \verb~                container[i] = new OccupyValue<Animation>()~\\
\cellcolor{red} & 0 & \verb~31~ & & \verb~                    {Occupied = false, Value = new Animation() {~\\
\cellcolor{red} & 0 & \verb~32~ & & \verb~                        Duration = 0, Shape = new StationaryShape(0.0f, 0.0f, 0.0f, 0.0f)~\\
\cellcolor{red} & 0 & \verb~33~ & & \verb~                    }};~\\
\cellcolor{red} & 0 & \verb~34~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~35~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~36~ & & \verb~~\\
\cellcolor{gray} &  & \verb~37~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~38~ & & \verb~        /// Add an animation to this container. Return true if successful, otherwise false.~\\
\cellcolor{gray} &  & \verb~39~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~40~ & & \verb~        /// <param name="shape"></param>~\\
\cellcolor{gray} &  & \verb~41~ & & \verb~        /// <param name="duration"></param>~\\
\cellcolor{gray} &  & \verb~42~ & & \verb~        /// <param name="stride"></param>~\\
\cellcolor{red} & 0 & \verb~43~ & & \verb~        public bool AddAnimation(Shape shape, int duration, ImageStride stride) {~\\
\cellcolor{red} & 0 & \verb~44~ & & \verb~            for (int i = 0; i < size; i++) {~\\
\cellcolor{red} & 0 & \verb~45~ & & \verb~                var anim = container[i];~\\
\cellcolor{red} & 0 & \verb~46~ & & \verb~                if (!anim.Occupied) {~\\
\cellcolor{red} & 0 & \verb~47~ & & \verb~                    anim.Occupied = true;~\\
\cellcolor{red} & 0 & \verb~48~ & & \verb~                    anim.Value.Shape.Position = shape.Position;~\\
\cellcolor{red} & 0 & \verb~49~ & & \verb~                    anim.Value.Shape.Extent = shape.Extent;~\\
\cellcolor{red} & 0 & \verb~50~ & & \verb~                    anim.Value.Duration = duration;~\\
\cellcolor{red} & 0 & \verb~51~ & & \verb~                    anim.Value.Stride = stride;~\\
\cellcolor{red} & 0 & \verb~52~ & & \verb~                    anim.Value.ResetAnimation();~\\
\cellcolor{red} & 0 & \verb~53~ & & \verb~                    return true;~\\
\cellcolor{gray} &  & \verb~54~ & & \verb~                }~\\
\cellcolor{red} & 0 & \verb~55~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~56~ & & \verb~            return false;~\\
\cellcolor{red} & 0 & \verb~57~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~58~ & & \verb~~\\
\cellcolor{gray} &  & \verb~59~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~60~ & & \verb~        /// Render all animation objects currently bound to this container~\\
\cellcolor{gray} &  & \verb~61~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~62~ & & \verb~        public void RenderAnimations() {~\\
\cellcolor{red} & 0 & \verb~63~ & & \verb~            foreach (var animation in container) {~\\
\cellcolor{red} & 0 & \verb~64~ & & \verb~                if (animation.Occupied && animation.Value.IsActive()) {~\\
\cellcolor{red} & 0 & \verb~65~ & & \verb~                    animation.Value.RenderAnimation();~\\
\cellcolor{red} & 0 & \verb~66~ & & \verb~                } else {~\\
\cellcolor{red} & 0 & \verb~67~ & & \verb~                    animation.Occupied = false;~\\
\cellcolor{red} & 0 & \verb~68~ & & \verb~                }~\\
\cellcolor{red} & 0 & \verb~69~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~70~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~71~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~72~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Graphics.Camera}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Graphics.Camera\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Graphics/Camera.cs}\end{minipage} \\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 12\\
\textbf{Coverable lines:} & 12\\
\textbf{Total lines:} & 26\\
\textbf{Line coverage:} & 0\% (0 of 12)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 0\\
\textbf{Covered methods:} & 0\\
\textbf{Total methods:} & 3\\
\textbf{Method coverage:} & 0\% (0 of 3)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{ScaleBy(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{OffsetBy(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{setZoom()} & 100\% & 1 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Graphics/Camera.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Math;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using OpenTK.Graphics.OpenGL;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~namespace DIKUArcade.Graphics {~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~    public abstract class Camera {~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~        public Vec2F Offset;~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~        public float Scale;~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~10~ & & \verb~        public void ScaleBy(float scalar) {~\\
\cellcolor{red} & 0 & \verb~11~ & & \verb~            Scale *= scalar;~\\
\cellcolor{red} & 0 & \verb~12~ & & \verb~            setZoom();~\\
\cellcolor{red} & 0 & \verb~13~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~15~ & & \verb~        public void OffsetBy(Vec2F offsetBy) {~\\
\cellcolor{red} & 0 & \verb~16~ & & \verb~            Offset += offsetBy;~\\
\cellcolor{red} & 0 & \verb~17~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~19~ & & \verb~        private void setZoom() {~\\
\cellcolor{red} & 0 & \verb~20~ & & \verb~            GL.MatrixMode(MatrixMode.Projection);~\\
\cellcolor{red} & 0 & \verb~21~ & & \verb~            GL.LoadIdentity();~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~            //GL.Ortho(-1.0, 1.0, -1.0, 1.0, 0.0, 4.0);~\\
\cellcolor{red} & 0 & \verb~23~ & & \verb~            GL.Ortho(0.0, 1.0 * Scale,0.0,1.0 * Scale, 0.0, 4.0);~\\
\cellcolor{red} & 0 & \verb~24~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~25~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~26~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Graphics.ChaseCamera}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Graphics.ChaseCamera\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{home/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Graphics/ChaseCamera.cs}\end{minipage} \\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 19\\
\textbf{Coverable lines:} & 19\\
\textbf{Total lines:} & 50\\
\textbf{Line coverage:} & 0\% (0 of 19)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 10\\
\textbf{Branch coverage:} & 0\% (0 of 10)\\
\textbf{Covered methods:} & 0\\
\textbf{Total methods:} & 2\\
\textbf{Method coverage:} & 0\% (0 of 2)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 0\% & 2 & 0\%\\
\hline
\textbf{EnqueueDirection(...} & 0\% & 8 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{home/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Graphics/ChaseCamera.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.Math;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~namespace DIKUArcade.Graphics {~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~/// <summary>A camera that takes a direction </summary>~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~    public class ChaseCamera : Camera {~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~        public Shape WorldShape;~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~        public DynamicShape cameraShape;~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~        // We want to expose the camera position, as it is quite nice to know what we are looking at.~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~        //public Vec2F CameraPos() { return cameraShape.Position; }~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~15~ & & \verb~        private Vec2F baseOffset = new Vec2F(0.5f, 0.5f);~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~~\\
\cellcolor{gray} &  & \verb~17~ & & \verb~~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~        private Queue<Vec2F> directionQueue;~\\
\cellcolor{gray} &  & \verb~19~ & & \verb~        // Set the frame delay of the camera~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~        private const int CAMERA_DELAY = 20;~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~23~ & & \verb~        public ChaseCamera(StationaryShape worldShape) {~\\
\cellcolor{gray} &  & \verb~24~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~25~ & & \verb~            cameraShape = new DynamicShape(0.5f, 0.5f, 0.0f, 0.0f);~\\
\cellcolor{red} & 0 & \verb~26~ & & \verb~            Offset = baseOffset - cameraShape.Position;//new Vec2F(0f, 0f);~\\
\cellcolor{red} & 0 & \verb~27~ & & \verb~            Scale = 1f;~\\
\cellcolor{gray} &  & \verb~28~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~29~ & & \verb~            WorldShape = worldShape;~\\
\cellcolor{gray} &  & \verb~30~ & & \verb~             // Initialize the queue and fill it with 0-vectors to make the camera lag behind by CAMERA_DELAY seconds~\\
\cellcolor{red} & 0 & \verb~31~ & & \verb~            directionQueue = new Queue<Vec2F>(CAMERA_DELAY);~\\
\cellcolor{red} & 0 & \verb~32~ & & \verb~            for (int i = 0; i < CAMERA_DELAY; i++) { directionQueue.Enqueue(new Vec2F(0f,0f)); }~\\
\cellcolor{red} & 0 & \verb~33~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~34~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~35~ & & \verb~        public void EnqueueDirection(Vec2F direction) {~\\
\cellcolor{red} & 0 & \verb~36~ & & \verb~            cameraShape.Direction = directionQueue.Dequeue();~\\
\cellcolor{red} & 0 & \verb~37~ & & \verb~            directionQueue.Enqueue(direction);~\\
\cellcolor{gray} &  & \verb~38~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~39~ & & \verb~            cameraShape.Move();~\\
\cellcolor{gray} &  & \verb~40~ & & \verb~~\\
\cellcolor{gray} &  & \verb~41~ & & \verb~            // Update camera offset and clamp it to the worldshape~\\
\cellcolor{red} & 0 & \verb~42~ & & \verb~            Offset = baseOffset - cameraShape.Position;~\\
\cellcolor{red} & 0 & \verb~43~ & & \verb~            if (-Offset.X      < WorldShape.Position.X)                       { Offset.X = -WorldShape.Position.X; }~\\
\cellcolor{red} & 0 & \verb~44~ & & \verb~            if (-Offset.X + 1f > WorldShape.Position.X + WorldShape.Extent.X) { Offset.X = -(WorldShape.Position.X + Wor~\\
\cellcolor{red} & 0 & \verb~45~ & & \verb~            if (-Offset.Y      < WorldShape.Position.Y)                       { Offset.Y = -WorldShape.Position.Y; }~\\
\cellcolor{red} & 0 & \verb~46~ & & \verb~            if (-Offset.Y + 1f > WorldShape.Position.Y + WorldShape.Extent.Y) { Offset.Y = -(WorldShape.Position.Y + Wor~\\
\cellcolor{gray} &  & \verb~47~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~48~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~49~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~50~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Graphics.DynamicCamera}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Graphics.DynamicCamera\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{me/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Graphics/DynamicCamera.cs}\end{minipage} \\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 46\\
\textbf{Coverable lines:} & 46\\
\textbf{Total lines:} & 79\\
\textbf{Line coverage:} & 0\% (0 of 46)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 20\\
\textbf{Branch coverage:} & 0\% (0 of 20)\\
\textbf{Covered methods:} & 0\\
\textbf{Total methods:} & 3\\
\textbf{Method coverage:} & 0\% (0 of 3)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{OffsetRelativeTo(...} & 0\% & 20 & 0\%\\
\hline
\textbf{Render()} & 100\% & 1 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{me/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Graphics/DynamicCamera.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using DIKUArcade.Math;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~namespace DIKUArcade.Graphics {~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~    public class DynamicCamera : Camera {~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~        public Shape WorldShape;~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~        private DynamicShape innerBounds;~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~        private Entity overlay;~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~        private Vec2F displacement;~\\
\cellcolor{red} & 0 & \verb~13~ & & \verb~        public DynamicCamera(StationaryShape worldShape) {~\\
\cellcolor{red} & 0 & \verb~14~ & & \verb~            Offset = new Vec2F(0.0f, 0.0f);~\\
\cellcolor{red} & 0 & \verb~15~ & & \verb~            Scale = 1f;~\\
\cellcolor{red} & 0 & \verb~16~ & & \verb~            WorldShape = worldShape;~\\
\cellcolor{red} & 0 & \verb~17~ & & \verb~            innerBounds = new DynamicShape(0.25f, 0.25f, 0.5f, 0.5f);~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~            //innerBounds.ScaleFromCenter(0.5f);~\\
\cellcolor{red} & 0 & \verb~19~ & & \verb~            displacement = innerBounds.Position;~\\
\cellcolor{red} & 0 & \verb~20~ & & \verb~            overlay = new Entity(innerBounds, new Image(Path.Combine("Assets", "Images", "Overlay.png")));~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~22~ & & \verb~            System.Console.WriteLine("Offset is: {0}", Offset);~\\
\cellcolor{red} & 0 & \verb~23~ & & \verb~            System.Console.WriteLine("inner is: {0}", innerBounds.Position);~\\
\cellcolor{red} & 0 & \verb~24~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~25~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~26~ & & \verb~        public void OffsetRelativeTo(Vec2F offsetRelativeTo) {~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~            // Check if "safe" inside the inner bounds and exit early~\\
\cellcolor{gray} &  & \verb~28~ & & \verb~            // The magic constant 0.03f is the players width and height~\\
\cellcolor{red} & 0 & \verb~29~ & & \verb~            if (innerBounds.Position.X <= offsetRelativeTo.X~\\
\cellcolor{red} & 0 & \verb~30~ & & \verb~                && offsetRelativeTo.X <= innerBounds.Position.X + innerBounds.Extent.X - 0.03f~\\
\cellcolor{red} & 0 & \verb~31~ & & \verb~                && innerBounds.Position.Y <= offsetRelativeTo.Y~\\
\cellcolor{red} & 0 & \verb~32~ & & \verb~                && offsetRelativeTo.Y <= innerBounds.Position.Y + innerBounds.Extent.Y - 0.03f) {~\\
\cellcolor{gray} &  & \verb~33~ & & \verb~                    //innerBounds.Direction = new Vec2F(0.0f, 0.0f);~\\
\cellcolor{red} & 0 & \verb~34~ & & \verb~                    return;~\\
\cellcolor{gray} &  & \verb~35~ & & \verb~                }~\\
\cellcolor{red} & 0 & \verb~36~ & & \verb~            else {~\\
\cellcolor{gray} &  & \verb~37~ & & \verb~                // Calculate new offset~\\
\cellcolor{gray} &  & \verb~38~ & & \verb~                // If the player has driven out the left side of the box~\\
\cellcolor{red} & 0 & \verb~39~ & & \verb~                if (offsetRelativeTo.X < innerBounds.Position.X)~\\
\cellcolor{red} & 0 & \verb~40~ & & \verb~                {~\\
\cellcolor{red} & 0 & \verb~41~ & & \verb~                    innerBounds.Position.X = offsetRelativeTo.X;~\\
\cellcolor{gray} &  & \verb~42~ & & \verb~                    //innerBounds.Direction.X = offsetRelativeTo.X - innerBounds.Position.X;~\\
\cellcolor{red} & 0 & \verb~43~ & & \verb~                }~\\
\cellcolor{red} & 0 & \verb~44~ & & \verb~                else if (offsetRelativeTo.X > innerBounds.Position.X + innerBounds.Extent.X - 0.03f) {~\\
\cellcolor{red} & 0 & \verb~45~ & & \verb~                    innerBounds.Position.X = (offsetRelativeTo.X - innerBounds.Extent.X - 0.03f);~\\
\cellcolor{gray} &  & \verb~46~ & & \verb~                    //innerBounds.Direction.X = (offsetRelativeTo.X - (innerBounds.Position.X + innerBounds.Extent.X -0.~\\
\cellcolor{red} & 0 & \verb~47~ & & \verb~                }~\\
\cellcolor{gray} &  & \verb~48~ & & \verb~                //innerBounds.Direction *= 3.0f;~\\
\cellcolor{gray} &  & \verb~49~ & & \verb~                //innerBounds.Move();~\\
\cellcolor{gray} &  & \verb~50~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~51~ & & \verb~                Offset = displacement - innerBounds.Position;~\\
\cellcolor{gray} &  & \verb~52~ & & \verb~                // Then check if outside the world and move stuff back~\\
\cellcolor{gray} &  & \verb~53~ & & \verb~                // Stop at the edge of the world~\\
\cellcolor{red} & 0 & \verb~54~ & & \verb~                if (-Offset.X < WorldShape.Position.X) { // Left side~\\
\cellcolor{red} & 0 & \verb~55~ & & \verb~                        Offset.X = -WorldShape.Position.X;~\\
\cellcolor{red} & 0 & \verb~56~ & & \verb~                        innerBounds.Position.X = offsetRelativeTo.X;//WorldShape.Position.X + innerBounds.Extent.X / 2.0~\\
\cellcolor{red} & 0 & \verb~57~ & & \verb~                    }~\\
\cellcolor{red} & 0 & \verb~58~ & & \verb~                if (-Offset.X + 1f > WorldShape.Position.X + WorldShape.Extent.X) { // Right side~\\
\cellcolor{red} & 0 & \verb~59~ & & \verb~                     Offset.X = -(WorldShape.Position.X + WorldShape.Extent.X - 1f);~\\
\cellcolor{red} & 0 & \verb~60~ & & \verb~                     innerBounds.Position.X = offsetRelativeTo.X - 0.03f;//WorldShape.Extent.X - innerBounds.Extent.X;~\\
\cellcolor{red} & 0 & \verb~61~ & & \verb~                    }~\\
\cellcolor{red} & 0 & \verb~62~ & & \verb~                if (-Offset.Y      < WorldShape.Position.Y) // Top~\\
\cellcolor{red} & 0 & \verb~63~ & & \verb~                    { Offset.Y = -WorldShape.Position.Y;~\\
\cellcolor{red} & 0 & \verb~64~ & & \verb~                    innerBounds.Position.Y = offsetRelativeTo.Y; }~\\
\cellcolor{red} & 0 & \verb~65~ & & \verb~                if (-Offset.Y + 1f > WorldShape.Position.Y + WorldShape.Extent.Y) // Bottom~\\
\cellcolor{red} & 0 & \verb~66~ & & \verb~                    {~\\
\cellcolor{red} & 0 & \verb~67~ & & \verb~                        Offset.Y = -(WorldShape.Position.Y + WorldShape.Extent.Y - 1.0f);~\\
\cellcolor{red} & 0 & \verb~68~ & & \verb~                        innerBounds.Position.Y = offsetRelativeTo.Y - 0.03f;~\\
\cellcolor{red} & 0 & \verb~69~ & & \verb~                    }~\\
\cellcolor{gray} &  & \verb~70~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~71~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~72~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~73~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~74~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~75~ & & \verb~        public void Render() {~\\
\cellcolor{red} & 0 & \verb~76~ & & \verb~            overlay.Image.Render(overlay.Shape, this);~\\
\cellcolor{red} & 0 & \verb~77~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~78~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~79~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Graphics.FollowCamera}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Graphics.FollowCamera\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{ome/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Graphics/FollowCamera.cs}\end{minipage} \\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 13\\
\textbf{Coverable lines:} & 13\\
\textbf{Total lines:} & 23\\
\textbf{Line coverage:} & 0\% (0 of 13)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 8\\
\textbf{Branch coverage:} & 0\% (0 of 8)\\
\textbf{Covered methods:} & 0\\
\textbf{Total methods:} & 2\\
\textbf{Method coverage:} & 0\% (0 of 2)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{OffsetRelativeTo(...} & 0\% & 8 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{ome/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Graphics/FollowCamera.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.Math;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~namespace DIKUArcade.Graphics {~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~    public class FollowCamera : Camera {~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~        public Shape WorldShape;~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~8~ & & \verb~        private Vec2F baseOffset = new Vec2F(0.5f, 0.5f);~\\
\cellcolor{red} & 0 & \verb~9~ & & \verb~        public FollowCamera(StationaryShape worldShape) {~\\
\cellcolor{red} & 0 & \verb~10~ & & \verb~            Offset = new Vec2F(0f, 0f);~\\
\cellcolor{red} & 0 & \verb~11~ & & \verb~            Scale = 1f;~\\
\cellcolor{red} & 0 & \verb~12~ & & \verb~            WorldShape = worldShape;~\\
\cellcolor{red} & 0 & \verb~13~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~15~ & & \verb~        public void OffsetRelativeTo(Vec2F offsetRelativeTo) {~\\
\cellcolor{red} & 0 & \verb~16~ & & \verb~            Offset = baseOffset - offsetRelativeTo;~\\
\cellcolor{red} & 0 & \verb~17~ & & \verb~            if (-Offset.X      < WorldShape.Position.X)                            { Offset.X = -WorldShape.Position.X; ~\\
\cellcolor{red} & 0 & \verb~18~ & & \verb~            if (-Offset.X + 1f > WorldShape.Position.X + WorldShape.Extent.X) { Offset.X = -(WorldShape.Position.X + Wor~\\
\cellcolor{red} & 0 & \verb~19~ & & \verb~            if (-Offset.Y      < WorldShape.Position.Y)                            { Offset.Y = -WorldShape.Position.Y; ~\\
\cellcolor{red} & 0 & \verb~20~ & & \verb~            if (-Offset.Y + 1f > WorldShape.Position.Y + WorldShape.Extent.Y) { Offset.Y = -(WorldShape.Position.Y + Wor~\\
\cellcolor{red} & 0 & \verb~21~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Graphics.Image}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Graphics.Image\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Graphics/Image.cs}\end{minipage} \\
\textbf{Covered lines:} & 3\\
\textbf{Uncovered lines:} & 12\\
\textbf{Coverable lines:} & 15\\
\textbf{Total lines:} & 28\\
\textbf{Line coverage:} & 20\% (3 of 15)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 0\\
\textbf{Covered methods:} & 1\\
\textbf{Total methods:} & 5\\
\textbf{Method coverage:} & 20\% (1 of 5)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 100\%\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{Render(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{Render(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{GetTexture()} & 100\% & 1 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Graphics/Image.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using System;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~namespace DIKUArcade.Graphics {~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~    public class Image : IBaseImage {~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~        private Texture texture;~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~~\\
\cellcolor{green} & 524 & \verb~9~ & & \verb~        public Image(string imageFile) {~\\
\cellcolor{green} & 262 & \verb~10~ & & \verb~            texture = new Texture(imageFile);~\\
\cellcolor{green} & 262 & \verb~11~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~13~ & & \verb~        public Image(Texture texture) {~\\
\cellcolor{red} & 0 & \verb~14~ & & \verb~            this.texture = texture;~\\
\cellcolor{red} & 0 & \verb~15~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~17~ & & \verb~        public void Render(Shape shape) {~\\
\cellcolor{red} & 0 & \verb~18~ & & \verb~            texture.Render(shape);~\\
\cellcolor{red} & 0 & \verb~19~ & & \verb~        }~\\
\cellcolor{red} & 0 & \verb~20~ & & \verb~        public void Render(Shape shape, Camera camera) {~\\
\cellcolor{red} & 0 & \verb~21~ & & \verb~            texture.Render(shape, camera);~\\
\cellcolor{red} & 0 & \verb~22~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~24~ & & \verb~        public Texture GetTexture() {~\\
\cellcolor{red} & 0 & \verb~25~ & & \verb~            return texture;~\\
\cellcolor{red} & 0 & \verb~26~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~28~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Graphics.ImageStride}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Graphics.ImageStride\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{home/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Graphics/ImageStride.cs}\end{minipage} \\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 87\\
\textbf{Coverable lines:} & 87\\
\textbf{Total lines:} & 191\\
\textbf{Line coverage:} & 0\% (0 of 87)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 32\\
\textbf{Branch coverage:} & 0\% (0 of 32)\\
\textbf{Covered methods:} & 0\\
\textbf{Total methods:} & 10\\
\textbf{Method coverage:} & 0\% (0 of 10)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 0\% & 6 & 0\%\\
\hline
\textbf{.ctor(...)} & 0\% & 6 & 0\%\\
\hline
\textbf{.ctor(...)} & 0\% & 6 & 0\%\\
\hline
\textbf{CreateStrides(...)} & 0\% & 2 & 0\%\\
\hline
\textbf{StartAnimation()} & 100\% & 1 & 0\%\\
\hline
\textbf{StopAnimation()} & 100\% & 1 & 0\%\\
\hline
\textbf{SetAnimationFrequenc} & 0\% & 2 & 0\%\\
\hline
\textbf{ChangeAnimationFrequ} & 0\% & 2 & 0\%\\
\hline
\textbf{Render(...)} & 0\% & 8 & 0\%\\
\hline
\textbf{Render(...)} & 100\% & 1 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{home/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Graphics/ImageStride.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using System;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using System.Collections.Generic;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~using DIKUArcade.Timers;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~using DIKUArcade.Math;~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~using DIKUArcade.Utilities;~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~namespace DIKUArcade.Graphics {~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~    /// Image stride to show animations based on a list of textures~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~    /// and an animation frequency.~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~    public class ImageStride : IBaseImage {~\\
\cellcolor{gray} &  & \verb~15~ & & \verb~        private int animFrequency;~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~~\\
\cellcolor{gray} &  & \verb~17~ & & \verb~        private double lastTime;~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~        private bool animate;~\\
\cellcolor{gray} &  & \verb~19~ & & \verb~~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~        private List<Texture> textures;~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~        private readonly int maxImageCount;~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~        private int currentImageCount;~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~~\\
\cellcolor{gray} &  & \verb~24~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~25~ & & \verb~        /// This value is only added for random animation offset,~\\
\cellcolor{gray} &  & \verb~26~ & & \verb~        /// e.g. 100 objects created at the same time with the same~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~        /// animation frequency will not change texture at the exact~\\
\cellcolor{gray} &  & \verb~28~ & & \verb~        /// same time.~\\
\cellcolor{gray} &  & \verb~29~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~30~ & & \verb~        private double timerOffset;~\\
\cellcolor{gray} &  & \verb~31~ & & \verb~~\\
\cellcolor{gray} &  & \verb~32~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~33~ & & \verb~        ///~\\
\cellcolor{gray} &  & \verb~34~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~35~ & & \verb~        /// <param name="milliseconds">Time between consecutive frames</param>~\\
\cellcolor{gray} &  & \verb~36~ & & \verb~        /// <param name="imageFiles">List of image files to include in strides</param>~\\
\cellcolor{red} & 0 & \verb~37~ & & \verb~        public ImageStride(int milliseconds, params string[] imageFiles) {~\\
\cellcolor{red} & 0 & \verb~38~ & & \verb~            if (milliseconds < 0) {~\\
\cellcolor{red} & 0 & \verb~39~ & & \verb~                throw new ArgumentException("milliseconds must be a positive integer");~\\
\cellcolor{gray} &  & \verb~40~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~41~ & & \verb~            animFrequency = milliseconds;~\\
\cellcolor{red} & 0 & \verb~42~ & & \verb~            animate = true;~\\
\cellcolor{gray} &  & \verb~43~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~44~ & & \verb~            int imgs = imageFiles.Length;~\\
\cellcolor{red} & 0 & \verb~45~ & & \verb~            if (imgs == 0) {~\\
\cellcolor{gray} &  & \verb~46~ & & \verb~                // ReSharper disable once NotResolvedInText~\\
\cellcolor{red} & 0 & \verb~47~ & & \verb~                throw new ArgumentNullException("At least one image file must be specified");~\\
\cellcolor{gray} &  & \verb~48~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~49~ & & \verb~            maxImageCount = imgs - 1;~\\
\cellcolor{red} & 0 & \verb~50~ & & \verb~            currentImageCount = RandomGenerator.Generator.Next(imgs);~\\
\cellcolor{red} & 0 & \verb~51~ & & \verb~            timerOffset = RandomGenerator.Generator.Next(100);~\\
\cellcolor{gray} &  & \verb~52~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~53~ & & \verb~            textures = new List<Texture>(imgs);~\\
\cellcolor{red} & 0 & \verb~54~ & & \verb~            foreach (string imgFile in imageFiles)~\\
\cellcolor{red} & 0 & \verb~55~ & & \verb~            {~\\
\cellcolor{red} & 0 & \verb~56~ & & \verb~                textures.Add(new Texture(imgFile));~\\
\cellcolor{red} & 0 & \verb~57~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~58~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~59~ & & \verb~~\\
\cellcolor{gray} &  & \verb~60~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~61~ & & \verb~        ///~\\
\cellcolor{gray} &  & \verb~62~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~63~ & & \verb~        /// <param name="milliseconds">Time between consecutive frames</param>~\\
\cellcolor{gray} &  & \verb~64~ & & \verb~        /// <param name="images">List of images to include in strides</param>~\\
\cellcolor{red} & 0 & \verb~65~ & & \verb~        public ImageStride(int milliseconds, params Image[] images) {~\\
\cellcolor{red} & 0 & \verb~66~ & & \verb~            if (milliseconds < 0) {~\\
\cellcolor{red} & 0 & \verb~67~ & & \verb~                throw new ArgumentException("milliseconds must be a positive integer");~\\
\cellcolor{gray} &  & \verb~68~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~69~ & & \verb~            animFrequency = milliseconds;~\\
\cellcolor{red} & 0 & \verb~70~ & & \verb~            animate = true;~\\
\cellcolor{gray} &  & \verb~71~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~72~ & & \verb~            int imgs = images.Length;~\\
\cellcolor{red} & 0 & \verb~73~ & & \verb~            if (imgs == 0) {~\\
\cellcolor{gray} &  & \verb~74~ & & \verb~                // ReSharper disable once NotResolvedInText~\\
\cellcolor{red} & 0 & \verb~75~ & & \verb~                throw new ArgumentNullException("at least one image file must be specified");~\\
\cellcolor{gray} &  & \verb~76~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~77~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~78~ & & \verb~            maxImageCount = imgs - 1;~\\
\cellcolor{red} & 0 & \verb~79~ & & \verb~            currentImageCount = RandomGenerator.Generator.Next(imgs);~\\
\cellcolor{red} & 0 & \verb~80~ & & \verb~            timerOffset = RandomGenerator.Generator.Next(100);~\\
\cellcolor{gray} &  & \verb~81~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~82~ & & \verb~            textures = new List<Texture>(imgs);~\\
\cellcolor{red} & 0 & \verb~83~ & & \verb~            foreach (Image img in images)~\\
\cellcolor{red} & 0 & \verb~84~ & & \verb~            {~\\
\cellcolor{red} & 0 & \verb~85~ & & \verb~                textures.Add(img.GetTexture());~\\
\cellcolor{red} & 0 & \verb~86~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~87~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~88~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~89~ & & \verb~        public ImageStride(int milliseconds, List<Image> images) {~\\
\cellcolor{red} & 0 & \verb~90~ & & \verb~            if (milliseconds < 0) {~\\
\cellcolor{red} & 0 & \verb~91~ & & \verb~                throw new ArgumentException("milliseconds must be a positive integer");~\\
\cellcolor{gray} &  & \verb~92~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~93~ & & \verb~            animFrequency = milliseconds;~\\
\cellcolor{red} & 0 & \verb~94~ & & \verb~            animate = true;~\\
\cellcolor{gray} &  & \verb~95~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~96~ & & \verb~            int imgs = images.Count;~\\
\cellcolor{red} & 0 & \verb~97~ & & \verb~            if (imgs == 0) {~\\
\cellcolor{gray} &  & \verb~98~ & & \verb~                // ReSharper disable once NotResolvedInText~\\
\cellcolor{red} & 0 & \verb~99~ & & \verb~                throw new ArgumentNullException("at least one image file must be specified");~\\
\cellcolor{gray} &  & \verb~100~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~101~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~102~ & & \verb~            maxImageCount = imgs - 1;~\\
\cellcolor{red} & 0 & \verb~103~ & & \verb~            currentImageCount = RandomGenerator.Generator.Next(imgs);~\\
\cellcolor{red} & 0 & \verb~104~ & & \verb~            timerOffset = RandomGenerator.Generator.Next(100);~\\
\cellcolor{gray} &  & \verb~105~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~106~ & & \verb~            textures = new List<Texture>(imgs);~\\
\cellcolor{red} & 0 & \verb~107~ & & \verb~            foreach (Image img in images)~\\
\cellcolor{red} & 0 & \verb~108~ & & \verb~            {~\\
\cellcolor{red} & 0 & \verb~109~ & & \verb~                textures.Add(img.GetTexture());~\\
\cellcolor{red} & 0 & \verb~110~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~111~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~112~ & & \verb~~\\
\cellcolor{gray} &  & \verb~113~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~114~ & & \verb~        /// Create a List of images from an image stride file.~\\
\cellcolor{gray} &  & \verb~115~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~116~ & & \verb~        /// <param name="numStrides">Total number of strides in the image</param>~\\
\cellcolor{gray} &  & \verb~117~ & & \verb~        /// <param name="imagePath">The relative path to the image</param>~\\
\cellcolor{gray} &  & \verb~118~ & & \verb~        /// <returns>A list of Image objects, each corresponding to a stride of the image.</returns>~\\
\cellcolor{red} & 0 & \verb~119~ & & \verb~        public static List<Image> CreateStrides(int numStrides, string imagePath) {~\\
\cellcolor{red} & 0 & \verb~120~ & & \verb~            var res = new List<Image>();~\\
\cellcolor{gray} &  & \verb~121~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~122~ & & \verb~            for (int i = 0; i < numStrides; i++) {~\\
\cellcolor{red} & 0 & \verb~123~ & & \verb~                res.Add(new Image(new Texture(imagePath, i, numStrides)));~\\
\cellcolor{red} & 0 & \verb~124~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~125~ & & \verb~            return res;~\\
\cellcolor{red} & 0 & \verb~126~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~127~ & & \verb~~\\
\cellcolor{gray} &  & \verb~128~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~129~ & & \verb~        /// Restart animation for this ImageStride object~\\
\cellcolor{gray} &  & \verb~130~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~131~ & & \verb~        public void StartAnimation() {~\\
\cellcolor{red} & 0 & \verb~132~ & & \verb~            animate = true;~\\
\cellcolor{red} & 0 & \verb~133~ & & \verb~            lastTime = StaticTimer.GetElapsedMilliseconds();~\\
\cellcolor{red} & 0 & \verb~134~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~135~ & & \verb~~\\
\cellcolor{gray} &  & \verb~136~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~137~ & & \verb~        /// Halt animation for this ImageStride object~\\
\cellcolor{gray} &  & \verb~138~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~139~ & & \verb~        public void StopAnimation() {~\\
\cellcolor{red} & 0 & \verb~140~ & & \verb~            animate = false;~\\
\cellcolor{red} & 0 & \verb~141~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~142~ & & \verb~~\\
\cellcolor{gray} &  & \verb~143~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~144~ & & \verb~        /// Change the animation frequency for this ImageStride object~\\
\cellcolor{gray} &  & \verb~145~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~146~ & & \verb~        /// <param name="milliseconds"></param>~\\
\cellcolor{gray} &  & \verb~147~ & & \verb~        /// <exception cref="ArgumentException">milliseconds must be a positive integer</exception>~\\
\cellcolor{red} & 0 & \verb~148~ & & \verb~        public void SetAnimationFrequency(int milliseconds) {~\\
\cellcolor{red} & 0 & \verb~149~ & & \verb~            if (milliseconds < 0) {~\\
\cellcolor{red} & 0 & \verb~150~ & & \verb~                throw new ArgumentException("milliseconds must be a positive integer");~\\
\cellcolor{gray} &  & \verb~151~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~152~ & & \verb~            animFrequency = milliseconds;~\\
\cellcolor{red} & 0 & \verb~153~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~154~ & & \verb~~\\
\cellcolor{gray} &  & \verb~155~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~156~ & & \verb~        /// Relatively change the animation frequency for this ImageStride object~\\
\cellcolor{gray} &  & \verb~157~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~158~ & & \verb~        /// <param name="millisecondsChange"></param>~\\
\cellcolor{gray} &  & \verb~159~ & & \verb~        /// <exception cref="ArgumentException">milliseconds must be a positive integer</exception>~\\
\cellcolor{red} & 0 & \verb~160~ & & \verb~        public void ChangeAnimationFrequency(int millisecondsChange) {~\\
\cellcolor{red} & 0 & \verb~161~ & & \verb~            animFrequency += millisecondsChange;~\\
\cellcolor{red} & 0 & \verb~162~ & & \verb~            if (animFrequency < 0) {~\\
\cellcolor{red} & 0 & \verb~163~ & & \verb~                animFrequency = 0;~\\
\cellcolor{red} & 0 & \verb~164~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~165~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~166~ & & \verb~~\\
\cellcolor{gray} &  & \verb~167~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~168~ & & \verb~        /// Render this ImageStride object onto the currently active drawing window~\\
\cellcolor{gray} &  & \verb~169~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~170~ & & \verb~        /// <param name="shape">The Shape object for the rendered image</param>~\\
\cellcolor{red} & 0 & \verb~171~ & & \verb~        public void Render(Shape shape) {~\\
\cellcolor{gray} &  & \verb~172~ & & \verb~            // measure elapsed time~\\
\cellcolor{red} & 0 & \verb~173~ & & \verb~            double elapsed = StaticTimer.GetElapsedMilliseconds() + timerOffset;~\\
\cellcolor{gray} &  & \verb~174~ & & \verb~~\\
\cellcolor{gray} &  & \verb~175~ & & \verb~            // the desired number of milliseconds has passed, change texture stride~\\
\cellcolor{red} & 0 & \verb~176~ & & \verb~            if (animFrequency > 0 && animate && elapsed - lastTime > animFrequency) {~\\
\cellcolor{red} & 0 & \verb~177~ & & \verb~                lastTime = elapsed;~\\
\cellcolor{gray} &  & \verb~178~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~179~ & & \verb~                currentImageCount =~\\
\cellcolor{red} & 0 & \verb~180~ & & \verb~                    (currentImageCount >= maxImageCount) ? 0 : currentImageCount + 1;~\\
\cellcolor{red} & 0 & \verb~181~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~182~ & & \verb~~\\
\cellcolor{gray} &  & \verb~183~ & & \verb~            // render the current texture object~\\
\cellcolor{red} & 0 & \verb~184~ & & \verb~            textures[currentImageCount].Render(shape);~\\
\cellcolor{red} & 0 & \verb~185~ & & \verb~        }~\\
\cellcolor{red} & 0 & \verb~186~ & & \verb~        public void Render(Shape shape, Camera camera) {~\\
\cellcolor{red} & 0 & \verb~187~ & & \verb~            throw new NotImplementedException();~\\
\cellcolor{gray} &  & \verb~188~ & & \verb~~\\
\cellcolor{gray} &  & \verb~189~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~190~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~191~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Graphics.NoImage}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Graphics.NoImage\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Graphics/NoImage.cs}\end{minipage} \\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 3\\
\textbf{Coverable lines:} & 3\\
\textbf{Total lines:} & 11\\
\textbf{Line coverage:} & 0\% (0 of 3)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 0\\
\textbf{Covered methods:} & 0\\
\textbf{Total methods:} & 3\\
\textbf{Method coverage:} & 0\% (0 of 3)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor()} & 100\% & 1 & 0\%\\
\hline
\textbf{Render(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{Render(...)} & 100\% & 1 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Graphics/NoImage.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using System;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~namespace DIKUArcade.Graphics {~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~    /// A stub for an image, to use with entities that are non-drawable~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~    public class NoImage : IBaseImage {~\\
\cellcolor{red} & 0 & \verb~7~ & & \verb~        public NoImage() {}~\\
\cellcolor{red} & 0 & \verb~8~ & & \verb~        public void Render(Shape shape) {}~\\
\cellcolor{red} & 0 & \verb~9~ & & \verb~        public void Render(Shape shape, Camera camera) {}~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Graphics.StaticCamera}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Graphics.StaticCamera\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{ome/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Graphics/StaticCamera.cs}\end{minipage} \\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 4\\
\textbf{Coverable lines:} & 4\\
\textbf{Total lines:} & 14\\
\textbf{Line coverage:} & 0\% (0 of 4)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 0\\
\textbf{Covered methods:} & 0\\
\textbf{Total methods:} & 1\\
\textbf{Method coverage:} & 0\% (0 of 1)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor()} & 100\% & 1 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{ome/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Graphics/StaticCamera.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Math;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~namespace DIKUArcade.Graphics {~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~    public class StaticCamera : Camera {~\\
\cellcolor{red} & 0 & \verb~5~ & & \verb~        public StaticCamera() {~\\
\cellcolor{red} & 0 & \verb~6~ & & \verb~            Offset = new Vec2F(0f, 0f);~\\
\cellcolor{red} & 0 & \verb~7~ & & \verb~            Scale = 1f;~\\
\cellcolor{red} & 0 & \verb~8~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Graphics.Text}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Graphics.Text\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Graphics/Text.cs}\end{minipage} \\
\textbf{Covered lines:} & 53\\
\textbf{Uncovered lines:} & 88\\
\textbf{Coverable lines:} & 141\\
\textbf{Total lines:} & 300\\
\textbf{Line coverage:} & 37.5\% (53 of 141)\\
\textbf{Covered branches:} & 6\\
\textbf{Total branches:} & 78\\
\textbf{Branch coverage:} & 7.6\% (6 of 78)\\
\textbf{Covered methods:} & 5\\
\textbf{Total methods:} & 17\\
\textbf{Method coverage:} & 29.4\% (5 of 17)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 100\%\\
\hline
\textbf{CreateBitmapTexture(} & 100\% & 1 & 100\%\\
\hline
\textbf{BindTexture()} & 100\% & 1 & 100\%\\
\hline
\textbf{UnbindTexture()} & 100\% & 1 & 100\%\\
\hline
\textbf{GetShape()} & 100\% & 1 & 0\%\\
\hline
\textbf{SetText(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{SetFontSize(...)} & 0\% & 2 & 0\%\\
\hline
\textbf{SetFont(...)} & 0\% & 4 & 0\%\\
\hline
\textbf{SetColor(...)} & 0\% & 12 & 0\%\\
\hline
\textbf{SetColor(...)} & 50.0\% & 12 & 87.50\%\\
\hline
\textbf{SetColor(...)} & 0\% & 16 & 0\%\\
\hline
\textbf{SetColor(...)} & 0\% & 16 & 0\%\\
\hline
\textbf{SetColor(...)} & 0\% & 16 & 0\%\\
\hline
\textbf{SetColor(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{CreateMatrix()} & 100\% & 1 & 0\%\\
\hline
\textbf{ScaleText(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{RenderText()} & 100\% & 1 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Graphics/Text.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using System;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using System.Drawing;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using System.Drawing.Imaging;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~using System.Drawing.Text;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~using OpenTK.Graphics.OpenGL;~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~using DIKUArcade.Math;~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~using OpenTK.Mathematics;~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~namespace DIKUArcade.Graphics {~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~    public class Text {~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~        // TODO: Add method for centering text (vertically, horizontally) within its shape!~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~        /// OpenGL texture handle~\\
\cellcolor{gray} &  & \verb~15~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~        private int textureId;~\\
\cellcolor{gray} &  & \verb~17~ & & \verb~~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~19~ & & \verb~        /// The string value for the text~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~        private string text;~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~24~ & & \verb~        /// The font size for the text string~\\
\cellcolor{gray} &  & \verb~25~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~26~ & & \verb~        private int fontSize;~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~~\\
\cellcolor{gray} &  & \verb~28~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~29~ & & \verb~        /// The position and size of the text~\\
\cellcolor{gray} &  & \verb~30~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~31~ & & \verb~        private StationaryShape shape;~\\
\cellcolor{gray} &  & \verb~32~ & & \verb~~\\
\cellcolor{gray} &  & \verb~33~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~34~ & & \verb~        /// The color for the text~\\
\cellcolor{gray} &  & \verb~35~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~36~ & & \verb~        private System.Drawing.Color color;~\\
\cellcolor{gray} &  & \verb~37~ & & \verb~~\\
\cellcolor{gray} &  & \verb~38~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~39~ & & \verb~        /// The font family of the text.~\\
\cellcolor{gray} &  & \verb~40~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~41~ & & \verb~        private System.Drawing.Font font;~\\
\cellcolor{gray} &  & \verb~42~ & & \verb~~\\
\cellcolor{green} & 266 & \verb~43~ & & \verb~        public Text(string text, Vec2F pos, Vec2F extent) {~\\
\cellcolor{green} & 133 & \verb~44~ & & \verb~            this.text = text;~\\
\cellcolor{green} & 133 & \verb~45~ & & \verb~            shape = new StationaryShape(pos, extent);~\\
\cellcolor{green} & 133 & \verb~46~ & & \verb~            color = System.Drawing.Color.Black;~\\
\cellcolor{green} & 133 & \verb~47~ & & \verb~            fontSize = 50;~\\
\cellcolor{green} & 133 & \verb~48~ & & \verb~            font = new Font("Arial", fontSize);~\\
\cellcolor{gray} &  & \verb~49~ & & \verb~~\\
\cellcolor{gray} &  & \verb~50~ & & \verb~            // create a texture id~\\
\cellcolor{green} & 133 & \verb~51~ & & \verb~            textureId = GL.GenTexture();~\\
\cellcolor{gray} &  & \verb~52~ & & \verb~~\\
\cellcolor{gray} &  & \verb~53~ & & \verb~            // bind this new texture id~\\
\cellcolor{green} & 133 & \verb~54~ & & \verb~            BindTexture();~\\
\cellcolor{gray} &  & \verb~55~ & & \verb~~\\
\cellcolor{gray} &  & \verb~56~ & & \verb~            // set texture properties, filters, blending functions, etc.~\\
\cellcolor{green} & 133 & \verb~57~ & & \verb~            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, (int)All.Linear);~\\
\cellcolor{green} & 133 & \verb~58~ & & \verb~            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, (int)All.Linear);~\\
\cellcolor{gray} &  & \verb~59~ & & \verb~~\\
\cellcolor{green} & 133 & \verb~60~ & & \verb~            GL.Enable(EnableCap.Blend);~\\
\cellcolor{green} & 133 & \verb~61~ & & \verb~            GL.BlendFunc(BlendingFactor.SrcAlpha, BlendingFactor.OneMinusSrcAlpha);~\\
\cellcolor{gray} &  & \verb~62~ & & \verb~~\\
\cellcolor{green} & 133 & \verb~63~ & & \verb~            GL.Enable(EnableCap.DepthTest);~\\
\cellcolor{green} & 133 & \verb~64~ & & \verb~            GL.DepthFunc(DepthFunction.Lequal);~\\
\cellcolor{gray} &  & \verb~65~ & & \verb~~\\
\cellcolor{green} & 133 & \verb~66~ & & \verb~            GL.Enable(EnableCap.Texture2D);~\\
\cellcolor{green} & 133 & \verb~67~ & & \verb~            GL.Enable(EnableCap.AlphaTest);~\\
\cellcolor{gray} &  & \verb~68~ & & \verb~~\\
\cellcolor{green} & 133 & \verb~69~ & & \verb~            GL.AlphaFunc(AlphaFunction.Gequal, 0.5f);~\\
\cellcolor{gray} &  & \verb~70~ & & \verb~~\\
\cellcolor{gray} &  & \verb~71~ & & \verb~            // unbind this new texture~\\
\cellcolor{green} & 133 & \verb~72~ & & \verb~            UnbindTexture();~\\
\cellcolor{gray} &  & \verb~73~ & & \verb~~\\
\cellcolor{gray} &  & \verb~74~ & & \verb~            // create a texture~\\
\cellcolor{green} & 133 & \verb~75~ & & \verb~            CreateBitmapTexture();~\\
\cellcolor{green} & 133 & \verb~76~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~77~ & & \verb~~\\
\cellcolor{gray} &  & \verb~78~ & & \verb~        // This method assumes that~\\
\cellcolor{green} & 290 & \verb~79~ & & \verb~        private void CreateBitmapTexture() {~\\
\cellcolor{green} & 290 & \verb~80~ & & \verb~            BindTexture();~\\
\cellcolor{gray} &  & \verb~81~ & & \verb~~\\
\cellcolor{green} & 290 & \verb~82~ & & \verb~            System.Drawing.Bitmap textBmp = new System.Drawing.Bitmap(500, 500); // match window size~\\
\cellcolor{gray} &  & \verb~83~ & & \verb~~\\
\cellcolor{gray} &  & \verb~84~ & & \verb~            // just allocate memory, so we can update efficiently using TexSubImage2D~\\
\cellcolor{green} & 290 & \verb~85~ & & \verb~            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgba, textBmp.Width, textBmp.Height, 0,~\\
\cellcolor{green} & 290 & \verb~86~ & & \verb~                OpenTK.Graphics.OpenGL.PixelFormat.Bgra, PixelType.UnsignedByte, IntPtr.Zero);~\\
\cellcolor{gray} &  & \verb~87~ & & \verb~~\\
\cellcolor{green} & 290 & \verb~88~ & & \verb~            using (System.Drawing.Graphics gfx = System.Drawing.Graphics.FromImage(textBmp))~\\
\cellcolor{green} & 290 & \verb~89~ & & \verb~            {~\\
\cellcolor{green} & 290 & \verb~90~ & & \verb~                gfx.Clear(System.Drawing.Color.Transparent);~\\
\cellcolor{gray} &  & \verb~91~ & & \verb~                // TODO: Could create an enumeration for choosing btw different font families!~\\
\cellcolor{green} & 290 & \verb~92~ & & \verb~                Font drawFont = font;~\\
\cellcolor{green} & 290 & \verb~93~ & & \verb~                SolidBrush drawBrush = new SolidBrush(color);~\\
\cellcolor{gray} &  & \verb~94~ & & \verb~~\\
\cellcolor{gray} &  & \verb~95~ & & \verb~                // TODO: Maybe we should not use shape.Position here, because different coordinate system !!?~\\
\cellcolor{green} & 290 & \verb~96~ & & \verb~                System.Drawing.PointF drawPoint = new System.Drawing.PointF(shape.Position.X, shape.Position.Y);~\\
\cellcolor{gray} &  & \verb~97~ & & \verb~~\\
\cellcolor{green} & 290 & \verb~98~ & & \verb~                gfx.DrawString(text, drawFont, drawBrush, drawPoint); // Draw as many strings as you need~\\
\cellcolor{green} & 290 & \verb~99~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~100~ & & \verb~~\\
\cellcolor{green} & 290 & \verb~101~ & & \verb~            BitmapData data = textBmp.LockBits(new System.Drawing.Rectangle(0, 0, textBmp.Width, textBmp.Height),~\\
\cellcolor{green} & 290 & \verb~102~ & & \verb~                ImageLockMode.ReadOnly, System.Drawing.Imaging.PixelFormat.Format32bppArgb);~\\
\cellcolor{green} & 290 & \verb~103~ & & \verb~            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgba, textBmp.Width, textBmp.Height, 0,~\\
\cellcolor{green} & 290 & \verb~104~ & & \verb~                OpenTK.Graphics.OpenGL.PixelFormat.Bgra, PixelType.UnsignedByte, data.Scan0);~\\
\cellcolor{green} & 290 & \verb~105~ & & \verb~            textBmp.UnlockBits(data);~\\
\cellcolor{gray} &  & \verb~106~ & & \verb~~\\
\cellcolor{green} & 290 & \verb~107~ & & \verb~            UnbindTexture();~\\
\cellcolor{green} & 290 & \verb~108~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~109~ & & \verb~~\\
\cellcolor{green} & 423 & \verb~110~ & & \verb~        private void BindTexture() {~\\
\cellcolor{green} & 423 & \verb~111~ & & \verb~            GL.BindTexture(TextureTarget.Texture2D, textureId);~\\
\cellcolor{green} & 423 & \verb~112~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~113~ & & \verb~~\\
\cellcolor{green} & 423 & \verb~114~ & & \verb~        private void UnbindTexture() {~\\
\cellcolor{green} & 423 & \verb~115~ & & \verb~            GL.BindTexture(TextureTarget.Texture2D, 0); // 0 is invalid texture id~\\
\cellcolor{green} & 423 & \verb~116~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~117~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~118~ & & \verb~        public StationaryShape GetShape() {~\\
\cellcolor{red} & 0 & \verb~119~ & & \verb~            return shape;~\\
\cellcolor{red} & 0 & \verb~120~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~121~ & & \verb~~\\
\cellcolor{gray} &  & \verb~122~ & & \verb~        #region ChangeTextProperties~\\
\cellcolor{gray} &  & \verb~123~ & & \verb~~\\
\cellcolor{gray} &  & \verb~124~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~125~ & & \verb~        /// Set the text string for this Text object.~\\
\cellcolor{gray} &  & \verb~126~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~127~ & & \verb~        /// <param name="newText">The new text string</param>~\\
\cellcolor{red} & 0 & \verb~128~ & & \verb~        public void SetText(string newText) {~\\
\cellcolor{red} & 0 & \verb~129~ & & \verb~            text = newText;~\\
\cellcolor{red} & 0 & \verb~130~ & & \verb~            CreateBitmapTexture();~\\
\cellcolor{red} & 0 & \verb~131~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~132~ & & \verb~~\\
\cellcolor{gray} &  & \verb~133~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~134~ & & \verb~        /// Set the font size for this Text object.~\\
\cellcolor{gray} &  & \verb~135~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~136~ & & \verb~        /// <param name="newSize">The new font size</param>~\\
\cellcolor{gray} &  & \verb~137~ & & \verb~        /// <exception cref="ArgumentOutOfRangeException">Font size must be a~\\
\cellcolor{gray} &  & \verb~138~ & & \verb~        /// positive integer.</exception>~\\
\cellcolor{red} & 0 & \verb~139~ & & \verb~        public void SetFontSize(int newSize) {~\\
\cellcolor{red} & 0 & \verb~140~ & & \verb~            if (newSize < 0) {~\\
\cellcolor{gray} &  & \verb~141~ & & \verb~                // ReSharper disable once NotResolvedInText~\\
\cellcolor{red} & 0 & \verb~142~ & & \verb~                throw  new ArgumentOutOfRangeException("Font size must be a positive integer");~\\
\cellcolor{gray} &  & \verb~143~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~144~ & & \verb~            fontSize = newSize;~\\
\cellcolor{red} & 0 & \verb~145~ & & \verb~            CreateBitmapTexture();~\\
\cellcolor{red} & 0 & \verb~146~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~147~ & & \verb~~\\
\cellcolor{gray} &  & \verb~148~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~149~ & & \verb~        /// Set the font for this Text object, if the font is installed.~\\
\cellcolor{gray} &  & \verb~150~ & & \verb~        /// If the font is not installed defaults to Arial.~\\
\cellcolor{gray} &  & \verb~151~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~152~ & & \verb~        /// <param name="fontfamily">The name of the font family</param>~\\
\cellcolor{red} & 0 & \verb~153~ & & \verb~        public void SetFont(string fontfamily) {~\\
\cellcolor{gray} &  & \verb~154~ & & \verb~            // The loop below checks if said font is installed, if not defaults to Arial.~\\
\cellcolor{red} & 0 & \verb~155~ & & \verb~            var fontsCollection = new InstalledFontCollection();~\\
\cellcolor{red} & 0 & \verb~156~ & & \verb~            foreach (var fontFamily in fontsCollection.Families) {~\\
\cellcolor{red} & 0 & \verb~157~ & & \verb~                if (fontFamily.Name == fontfamily) {~\\
\cellcolor{red} & 0 & \verb~158~ & & \verb~                    font = new Font(fontfamily, fontSize);~\\
\cellcolor{red} & 0 & \verb~159~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~160~ & & \verb~                }~\\
\cellcolor{red} & 0 & \verb~161~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~162~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~163~ & & \verb~            CreateBitmapTexture();~\\
\cellcolor{red} & 0 & \verb~164~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~165~ & & \verb~~\\
\cellcolor{gray} &  & \verb~166~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~167~ & & \verb~        /// Change text color~\\
\cellcolor{gray} &  & \verb~168~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~169~ & & \verb~        /// <param name="vec">Vec3F containing the RGB color values.</param>~\\
\cellcolor{gray} &  & \verb~170~ & & \verb~        /// <exception cref="ArgumentOutOfRangeException">Normalized color values must be~\\
\cellcolor{gray} &  & \verb~171~ & & \verb~        /// between 0 and 1.</exception>~\\
\cellcolor{red} & 0 & \verb~172~ & & \verb~        public void SetColor(Vec3F vec) {~\\
\cellcolor{red} & 0 & \verb~173~ & & \verb~            if (vec.X < 0.0f || vec.X > 1.0f ||~\\
\cellcolor{red} & 0 & \verb~174~ & & \verb~                vec.Y < 0.0f || vec.Y > 1.0f ||~\\
\cellcolor{red} & 0 & \verb~175~ & & \verb~                vec.Z < 0.0f || vec.Z > 1.0f) {~\\
\cellcolor{red} & 0 & \verb~176~ & & \verb~                throw new ArgumentOutOfRangeException($"RGB Color values must be between 0 and 1: {vec}");~\\
\cellcolor{gray} &  & \verb~177~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~178~ & & \verb~            color = System.Drawing.Color.FromArgb((int)(vec.X * 255.0f), (int)(vec.Y * 255.0f), (int)(vec.Z * 255.0f));~\\
\cellcolor{red} & 0 & \verb~179~ & & \verb~            CreateBitmapTexture();~\\
\cellcolor{red} & 0 & \verb~180~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~181~ & & \verb~~\\
\cellcolor{gray} &  & \verb~182~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~183~ & & \verb~        /// Change text color~\\
\cellcolor{gray} &  & \verb~184~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~185~ & & \verb~        /// <param name="vec">Vec3I containing the RGB color values.</param>~\\
\cellcolor{gray} &  & \verb~186~ & & \verb~        /// <exception cref="ArgumentOutOfRangeException">Color values must be~\\
\cellcolor{gray} &  & \verb~187~ & & \verb~        /// between 0 and 255.</exception>~\\
\cellcolor{green} & 157 & \verb~188~ & & \verb~        public void SetColor(Vec3I vec) {~\\
\cellcolor{orange} & 157 & \verb~189~ & & \verb~            if (vec.X < 0 || vec.X > 255 ||~\\
\cellcolor{green} & 157 & \verb~190~ & & \verb~                vec.Y < 0 || vec.Y > 255 ||~\\
\cellcolor{green} & 157 & \verb~191~ & & \verb~                vec.Z < 0 || vec.Z > 255) {~\\
\cellcolor{red} & 0 & \verb~192~ & & \verb~                throw new ArgumentOutOfRangeException($"RGB Color values must be between 0 and 255: {vec}");~\\
\cellcolor{gray} &  & \verb~193~ & & \verb~            }~\\
\cellcolor{green} & 157 & \verb~194~ & & \verb~            color = System.Drawing.Color.FromArgb(vec.X, vec.Y, vec.Z);~\\
\cellcolor{green} & 157 & \verb~195~ & & \verb~            CreateBitmapTexture();~\\
\cellcolor{green} & 157 & \verb~196~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~197~ & & \verb~~\\
\cellcolor{gray} &  & \verb~198~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~199~ & & \verb~        /// Change text color~\\
\cellcolor{gray} &  & \verb~200~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~201~ & & \verb~        /// <param name="vec">Vec4I containing the ARGB color values.</param>~\\
\cellcolor{gray} &  & \verb~202~ & & \verb~        /// <exception cref="ArgumentOutOfRangeException">Color values must be~\\
\cellcolor{gray} &  & \verb~203~ & & \verb~        /// between 0 and 255.</exception>~\\
\cellcolor{red} & 0 & \verb~204~ & & \verb~        public void SetColor(int a, int r, int g, int b) {~\\
\cellcolor{red} & 0 & \verb~205~ & & \verb~            if (a < 0 || a > 255 ||~\\
\cellcolor{red} & 0 & \verb~206~ & & \verb~                r < 0 || r > 255 ||~\\
\cellcolor{red} & 0 & \verb~207~ & & \verb~                g < 0 || g > 255 ||~\\
\cellcolor{red} & 0 & \verb~208~ & & \verb~                b < 0 || b > 255) {~\\
\cellcolor{red} & 0 & \verb~209~ & & \verb~                throw new ArgumentOutOfRangeException($"ARGB Color values must be between 0 and 255: {a} {r} {g} {b}");~\\
\cellcolor{gray} &  & \verb~210~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~211~ & & \verb~            color = System.Drawing.Color.FromArgb(a, r, g, b);~\\
\cellcolor{red} & 0 & \verb~212~ & & \verb~            CreateBitmapTexture();~\\
\cellcolor{red} & 0 & \verb~213~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~214~ & & \verb~~\\
\cellcolor{gray} &  & \verb~215~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~216~ & & \verb~        /// Change text color~\\
\cellcolor{gray} &  & \verb~217~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~218~ & & \verb~        /// <param name="vec">Vec4I containing the ARGB color values.</param>~\\
\cellcolor{gray} &  & \verb~219~ & & \verb~        /// <exception cref="ArgumentOutOfRangeException">Color values must be~\\
\cellcolor{gray} &  & \verb~220~ & & \verb~        /// between 0 and 255.</exception>~\\
\cellcolor{red} & 0 & \verb~221~ & & \verb~        public void SetColor(Vec4I vec) {~\\
\cellcolor{red} & 0 & \verb~222~ & & \verb~            if (vec.X < 0 || vec.X > 255 ||~\\
\cellcolor{red} & 0 & \verb~223~ & & \verb~                vec.Y < 0 || vec.Y > 255 ||~\\
\cellcolor{red} & 0 & \verb~224~ & & \verb~                vec.Z < 0 || vec.Z > 255 ||~\\
\cellcolor{red} & 0 & \verb~225~ & & \verb~                vec.W < 0 || vec.W > 255) {~\\
\cellcolor{red} & 0 & \verb~226~ & & \verb~                throw new ArgumentOutOfRangeException($"ARGB Color values must be between 0 and 255: {vec}");~\\
\cellcolor{gray} &  & \verb~227~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~228~ & & \verb~            color = System.Drawing.Color.FromArgb(vec.X, vec.Y, vec.Z, vec.W);~\\
\cellcolor{red} & 0 & \verb~229~ & & \verb~            CreateBitmapTexture();~\\
\cellcolor{red} & 0 & \verb~230~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~231~ & & \verb~~\\
\cellcolor{gray} &  & \verb~232~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~233~ & & \verb~        /// Change text color~\\
\cellcolor{gray} &  & \verb~234~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~235~ & & \verb~        /// <param name="vec">Vec3F containing the RGB color values.</param>~\\
\cellcolor{gray} &  & \verb~236~ & & \verb~        /// <exception cref="ArgumentOutOfRangeException">Normalized color values must be~\\
\cellcolor{gray} &  & \verb~237~ & & \verb~        /// between 0 and 1.</exception>~\\
\cellcolor{red} & 0 & \verb~238~ & & \verb~        public void SetColor(Vec4F vec) {~\\
\cellcolor{red} & 0 & \verb~239~ & & \verb~            if (vec.X < 0.0f || vec.X > 1.0f ||~\\
\cellcolor{red} & 0 & \verb~240~ & & \verb~                vec.Y < 0.0f || vec.Y > 1.0f ||~\\
\cellcolor{red} & 0 & \verb~241~ & & \verb~                vec.Z < 0.0f || vec.Z > 1.0f ||~\\
\cellcolor{red} & 0 & \verb~242~ & & \verb~                vec.W < 0.0f || vec.W > 1.0f) {~\\
\cellcolor{red} & 0 & \verb~243~ & & \verb~                throw new ArgumentOutOfRangeException($"ARGB Color values must be between 0 and 1: {vec}");~\\
\cellcolor{gray} &  & \verb~244~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~245~ & & \verb~            color = System.Drawing.Color.FromArgb((int)(vec.X * 255.0f), (int)(vec.Y * 255.0f), (int)(vec.Z * 255.0f), (~\\
\cellcolor{red} & 0 & \verb~246~ & & \verb~            CreateBitmapTexture();~\\
\cellcolor{red} & 0 & \verb~247~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~248~ & & \verb~~\\
\cellcolor{gray} &  & \verb~249~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~250~ & & \verb~        /// Change text color~\\
\cellcolor{gray} &  & \verb~251~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~252~ & & \verb~        /// <param name="newColor">System.Drawing.Color containing new color channel values.</param>~\\
\cellcolor{red} & 0 & \verb~253~ & & \verb~        public void SetColor(System.Drawing.Color newColor) {~\\
\cellcolor{red} & 0 & \verb~254~ & & \verb~            color = newColor;~\\
\cellcolor{red} & 0 & \verb~255~ & & \verb~            CreateBitmapTexture();~\\
\cellcolor{red} & 0 & \verb~256~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~257~ & & \verb~~\\
\cellcolor{gray} &  & \verb~258~ & & \verb~        #endregion~\\
\cellcolor{gray} &  & \verb~259~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~260~ & & \verb~        private Matrix4 CreateMatrix() {~\\
\cellcolor{gray} &  & \verb~261~ & & \verb~            // ensure that rotation is performed around the center of the shape~\\
\cellcolor{gray} &  & \verb~262~ & & \verb~            // instead of the bottom-left corner~\\
\cellcolor{red} & 0 & \verb~263~ & & \verb~            var halfX = shape.Extent.X / 2.0f;~\\
\cellcolor{red} & 0 & \verb~264~ & & \verb~            var halfY = shape.Extent.Y / 2.0f;~\\
\cellcolor{gray} &  & \verb~265~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~266~ & & \verb~            return Matrix4.CreateTranslation(-halfX, -halfY, 0.0f) *~\\
\cellcolor{red} & 0 & \verb~267~ & & \verb~                   Matrix4.CreateRotationZ(shape.Rotation) *~\\
\cellcolor{red} & 0 & \verb~268~ & & \verb~                   Matrix4.CreateTranslation(shape.Position.X + halfX, shape.Position.Y + halfY,~\\
\cellcolor{red} & 0 & \verb~269~ & & \verb~                       0.0f);~\\
\cellcolor{red} & 0 & \verb~270~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~271~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~272~ & & \verb~        public void ScaleText(float scale) {~\\
\cellcolor{red} & 0 & \verb~273~ & & \verb~            shape.Position *= scale;~\\
\cellcolor{red} & 0 & \verb~274~ & & \verb~            shape.Scale(scale);~\\
\cellcolor{red} & 0 & \verb~275~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~276~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~277~ & & \verb~        public void RenderText() {~\\
\cellcolor{gray} &  & \verb~278~ & & \verb~            // bind this texture~\\
\cellcolor{red} & 0 & \verb~279~ & & \verb~            BindTexture();~\\
\cellcolor{gray} &  & \verb~280~ & & \verb~~\\
\cellcolor{gray} &  & \verb~281~ & & \verb~            // render this texture~\\
\cellcolor{red} & 0 & \verb~282~ & & \verb~            Matrix4 modelViewMatrix = CreateMatrix();~\\
\cellcolor{red} & 0 & \verb~283~ & & \verb~            GL.MatrixMode(MatrixMode.Modelview);~\\
\cellcolor{red} & 0 & \verb~284~ & & \verb~            GL.LoadMatrix(ref modelViewMatrix);~\\
\cellcolor{gray} &  & \verb~285~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~286~ & & \verb~            GL.Color4(1f,1f,1f,1f);~\\
\cellcolor{red} & 0 & \verb~287~ & & \verb~            GL.Begin(PrimitiveType.Quads);~\\
\cellcolor{gray} &  & \verb~288~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~289~ & & \verb~            GL.TexCoord2(0, 1); GL.Vertex2(0.0f, 0.0f);                      // Top Left~\\
\cellcolor{red} & 0 & \verb~290~ & & \verb~            GL.TexCoord2(0, 0); GL.Vertex2(0.0f, shape.Extent.Y);            // Bottom Left~\\
\cellcolor{red} & 0 & \verb~291~ & & \verb~            GL.TexCoord2(1, 0); GL.Vertex2(shape.Extent.X, shape.Extent.Y);  // Bottom Right~\\
\cellcolor{red} & 0 & \verb~292~ & & \verb~            GL.TexCoord2(1, 1); GL.Vertex2(shape.Extent.X, 0.0f);            // Top Right~\\
\cellcolor{gray} &  & \verb~293~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~294~ & & \verb~            GL.End();~\\
\cellcolor{gray} &  & \verb~295~ & & \verb~~\\
\cellcolor{gray} &  & \verb~296~ & & \verb~            // unbind this texture~\\
\cellcolor{red} & 0 & \verb~297~ & & \verb~            UnbindTexture();~\\
\cellcolor{red} & 0 & \verb~298~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~299~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~300~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Graphics.Texture}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Graphics.Texture\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Graphics/Texture.cs}\end{minipage} \\
\textbf{Covered lines:} & 38\\
\textbf{Uncovered lines:} & 92\\
\textbf{Coverable lines:} & 130\\
\textbf{Total lines:} & 226\\
\textbf{Line coverage:} & 29.2\% (38 of 130)\\
\textbf{Covered branches:} & 3\\
\textbf{Total branches:} & 14\\
\textbf{Branch coverage:} & 21.4\% (3 of 14)\\
\textbf{Covered methods:} & 3\\
\textbf{Total methods:} & 8\\
\textbf{Method coverage:} & 37.5\% (3 of 8)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 75.00\% & 4 & 94.11\%\\
\hline
\textbf{.ctor(...)} & 0\% & 10 & 0\%\\
\hline
\textbf{BindTexture()} & 100\% & 1 & 100\%\\
\hline
\textbf{UnbindTexture()} & 100\% & 1 & 100\%\\
\hline
\textbf{CreateMatrix(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{CreateMatrix(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{Render(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{Render(...)} & 100\% & 1 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Graphics/Texture.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using System;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using System.Drawing.Imaging;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~using OpenTK.Mathematics;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~using OpenTK.Graphics.OpenGL;~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~namespace DIKUArcade.Graphics {~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~    public class Texture {~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~        /// OpenGL texture handle~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~        public static double offsetX = 0.0;~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~        public static double offsetY = 0.0;~\\
\cellcolor{gray} &  & \verb~15~ & & \verb~        private int textureId;~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~~\\
\cellcolor{green} & 524 & \verb~17~ & & \verb~        public Texture(string filename) {~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~            // create a texture id~\\
\cellcolor{green} & 262 & \verb~19~ & & \verb~            textureId = GL.GenTexture();~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~            // bind this new texture id~\\
\cellcolor{green} & 262 & \verb~22~ & & \verb~            BindTexture();~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~~\\
\cellcolor{gray} &  & \verb~24~ & & \verb~            // find base path~\\
\cellcolor{green} & 262 & \verb~25~ & & \verb~            var dir = new DirectoryInfo(Path.GetDirectoryName(~\\
\cellcolor{green} & 262 & \verb~26~ & & \verb~                System.Reflection.Assembly.GetExecutingAssembly().Location));~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~~\\
\cellcolor{green} & 786 & \verb~28~ & & \verb~            while (dir.Name != "bin")~\\
\cellcolor{green} & 524 & \verb~29~ & & \verb~            {~\\
\cellcolor{green} & 524 & \verb~30~ & & \verb~                dir = dir.Parent;~\\
\cellcolor{green} & 524 & \verb~31~ & & \verb~            }~\\
\cellcolor{green} & 262 & \verb~32~ & & \verb~            dir = dir.Parent;~\\
\cellcolor{gray} &  & \verb~33~ & & \verb~~\\
\cellcolor{gray} &  & \verb~34~ & & \verb~            // load image file~\\
\cellcolor{green} & 262 & \verb~35~ & & \verb~            var path = Path.Combine(dir.FullName.ToString(), filename);~\\
\cellcolor{orange} & 262 & \verb~36~ & & \verb~            if (!File.Exists(path))~\\
\cellcolor{red} & 0 & \verb~37~ & & \verb~            {~\\
\cellcolor{red} & 0 & \verb~38~ & & \verb~                throw new FileNotFoundException($"Error: The file \"{path}\" does not exist.");~\\
\cellcolor{gray} &  & \verb~39~ & & \verb~            }~\\
\cellcolor{green} & 262 & \verb~40~ & & \verb~            System.Drawing.Bitmap image = new System.Drawing.Bitmap(path);~\\
\cellcolor{green} & 262 & \verb~41~ & & \verb~            BitmapData data = image.LockBits(new System.Drawing.Rectangle(0, 0, image.Width, image.Height),~\\
\cellcolor{green} & 262 & \verb~42~ & & \verb~                ImageLockMode.ReadOnly, System.Drawing.Imaging.PixelFormat.Format32bppPArgb);~\\
\cellcolor{gray} &  & \verb~43~ & & \verb~~\\
\cellcolor{gray} &  & \verb~44~ & & \verb~            // attach it to OpenGL context~\\
\cellcolor{green} & 262 & \verb~45~ & & \verb~            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgba,~\\
\cellcolor{green} & 262 & \verb~46~ & & \verb~                data.Width, data.Height, 0, OpenTK.Graphics.OpenGL.PixelFormat.Bgra,~\\
\cellcolor{green} & 262 & \verb~47~ & & \verb~                PixelType.UnsignedByte, data.Scan0);~\\
\cellcolor{gray} &  & \verb~48~ & & \verb~~\\
\cellcolor{green} & 262 & \verb~49~ & & \verb~            image.UnlockBits(data);~\\
\cellcolor{gray} &  & \verb~50~ & & \verb~~\\
\cellcolor{gray} &  & \verb~51~ & & \verb~            // set texture properties, filters, blending functions, etc.~\\
\cellcolor{green} & 262 & \verb~52~ & & \verb~            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter,~\\
\cellcolor{green} & 262 & \verb~53~ & & \verb~                (int)TextureMinFilter.Linear);~\\
\cellcolor{green} & 262 & \verb~54~ & & \verb~            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter,~\\
\cellcolor{green} & 262 & \verb~55~ & & \verb~                (int)TextureMagFilter.Linear);~\\
\cellcolor{gray} &  & \verb~56~ & & \verb~~\\
\cellcolor{green} & 262 & \verb~57~ & & \verb~            GL.Enable(EnableCap.Blend);~\\
\cellcolor{green} & 262 & \verb~58~ & & \verb~            GL.BlendFunc(BlendingFactor.SrcAlpha, BlendingFactor.OneMinusSrcAlpha);~\\
\cellcolor{green} & 262 & \verb~59~ & & \verb~            GL.Enable(EnableCap.DepthTest);~\\
\cellcolor{green} & 262 & \verb~60~ & & \verb~            GL.DepthFunc(DepthFunction.Lequal);~\\
\cellcolor{gray} &  & \verb~61~ & & \verb~~\\
\cellcolor{green} & 262 & \verb~62~ & & \verb~            GL.Enable(EnableCap.Texture2D);~\\
\cellcolor{green} & 262 & \verb~63~ & & \verb~            GL.Enable(EnableCap.AlphaTest);~\\
\cellcolor{gray} &  & \verb~64~ & & \verb~~\\
\cellcolor{green} & 262 & \verb~65~ & & \verb~            GL.AlphaFunc(AlphaFunction.Gequal, 0.5f);~\\
\cellcolor{gray} &  & \verb~66~ & & \verb~~\\
\cellcolor{gray} &  & \verb~67~ & & \verb~            // unbind the texture~\\
\cellcolor{green} & 262 & \verb~68~ & & \verb~            UnbindTexture();~\\
\cellcolor{green} & 262 & \verb~69~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~70~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~71~ & & \verb~        public Texture(string filename, int currentStride, int stridesInImage)~\\
\cellcolor{red} & 0 & \verb~72~ & & \verb~        {~\\
\cellcolor{red} & 0 & \verb~73~ & & \verb~            if (currentStride < 0 || currentStride >= stridesInImage || stridesInImage < 0)~\\
\cellcolor{red} & 0 & \verb~74~ & & \verb~            {~\\
\cellcolor{red} & 0 & \verb~75~ & & \verb~                throw new ArgumentOutOfRangeException(~\\
\cellcolor{red} & 0 & \verb~76~ & & \verb~                    $"Invalid stride numbers: ({currentStride}/{stridesInImage})");~\\
\cellcolor{gray} &  & \verb~77~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~78~ & & \verb~            // create a texture id~\\
\cellcolor{red} & 0 & \verb~79~ & & \verb~            textureId = GL.GenTexture();~\\
\cellcolor{gray} &  & \verb~80~ & & \verb~~\\
\cellcolor{gray} &  & \verb~81~ & & \verb~            // bind this new texture id~\\
\cellcolor{red} & 0 & \verb~82~ & & \verb~            BindTexture();~\\
\cellcolor{gray} &  & \verb~83~ & & \verb~~\\
\cellcolor{gray} &  & \verb~84~ & & \verb~            // find base path~\\
\cellcolor{red} & 0 & \verb~85~ & & \verb~            var dir = new DirectoryInfo(Path.GetDirectoryName(~\\
\cellcolor{red} & 0 & \verb~86~ & & \verb~                System.Reflection.Assembly.GetExecutingAssembly().Location));~\\
\cellcolor{gray} &  & \verb~87~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~88~ & & \verb~            while (dir.Name != "bin")~\\
\cellcolor{red} & 0 & \verb~89~ & & \verb~            {~\\
\cellcolor{red} & 0 & \verb~90~ & & \verb~                dir = dir.Parent;~\\
\cellcolor{red} & 0 & \verb~91~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~92~ & & \verb~            dir = dir.Parent;~\\
\cellcolor{gray} &  & \verb~93~ & & \verb~~\\
\cellcolor{gray} &  & \verb~94~ & & \verb~            // load image file~\\
\cellcolor{red} & 0 & \verb~95~ & & \verb~            var path = Path.Combine(dir.FullName.ToString(), filename);~\\
\cellcolor{red} & 0 & \verb~96~ & & \verb~            if (!File.Exists(path))~\\
\cellcolor{red} & 0 & \verb~97~ & & \verb~            {~\\
\cellcolor{red} & 0 & \verb~98~ & & \verb~                throw new FileNotFoundException($"Error: The file \"{path}\" does not exist.");~\\
\cellcolor{gray} &  & \verb~99~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~100~ & & \verb~            System.Drawing.Bitmap image = new System.Drawing.Bitmap(path);~\\
\cellcolor{red} & 0 & \verb~101~ & & \verb~            var width = (int)((float)image.Width / (float)stridesInImage);~\\
\cellcolor{red} & 0 & \verb~102~ & & \verb~            var posX = currentStride * width;~\\
\cellcolor{red} & 0 & \verb~103~ & & \verb~            BitmapData data = image.LockBits(new System.Drawing.Rectangle(posX, 0, width, image.Height),~\\
\cellcolor{red} & 0 & \verb~104~ & & \verb~                ImageLockMode.ReadOnly, System.Drawing.Imaging.PixelFormat.Format32bppPArgb);~\\
\cellcolor{gray} &  & \verb~105~ & & \verb~~\\
\cellcolor{gray} &  & \verb~106~ & & \verb~            // attach it to OpenGL context~\\
\cellcolor{red} & 0 & \verb~107~ & & \verb~            GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgba,~\\
\cellcolor{red} & 0 & \verb~108~ & & \verb~                data.Width, data.Height, 0, OpenTK.Graphics.OpenGL.PixelFormat.Bgra,~\\
\cellcolor{red} & 0 & \verb~109~ & & \verb~                PixelType.UnsignedByte, data.Scan0);~\\
\cellcolor{gray} &  & \verb~110~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~111~ & & \verb~            image.UnlockBits(data);~\\
\cellcolor{gray} &  & \verb~112~ & & \verb~~\\
\cellcolor{gray} &  & \verb~113~ & & \verb~            // set texture properties, filters, blending functions, etc.~\\
\cellcolor{red} & 0 & \verb~114~ & & \verb~            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter,~\\
\cellcolor{red} & 0 & \verb~115~ & & \verb~                (int)TextureMinFilter.Linear);~\\
\cellcolor{red} & 0 & \verb~116~ & & \verb~            GL.TexParameter(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter,~\\
\cellcolor{red} & 0 & \verb~117~ & & \verb~                (int)TextureMagFilter.Linear);~\\
\cellcolor{gray} &  & \verb~118~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~119~ & & \verb~            GL.Enable(EnableCap.Blend);~\\
\cellcolor{red} & 0 & \verb~120~ & & \verb~            GL.BlendFunc(BlendingFactor.SrcAlpha, BlendingFactor.OneMinusSrcAlpha);~\\
\cellcolor{red} & 0 & \verb~121~ & & \verb~            GL.Enable(EnableCap.DepthTest);~\\
\cellcolor{red} & 0 & \verb~122~ & & \verb~            GL.DepthFunc(DepthFunction.Lequal);~\\
\cellcolor{gray} &  & \verb~123~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~124~ & & \verb~            GL.Enable(EnableCap.Texture2D);~\\
\cellcolor{red} & 0 & \verb~125~ & & \verb~            GL.Enable(EnableCap.AlphaTest);~\\
\cellcolor{gray} &  & \verb~126~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~127~ & & \verb~            GL.AlphaFunc(AlphaFunction.Gequal, 0.5f);~\\
\cellcolor{gray} &  & \verb~128~ & & \verb~~\\
\cellcolor{gray} &  & \verb~129~ & & \verb~            // unbind the texture~\\
\cellcolor{red} & 0 & \verb~130~ & & \verb~            UnbindTexture();~\\
\cellcolor{red} & 0 & \verb~131~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~132~ & & \verb~~\\
\cellcolor{gray} &  & \verb~133~ & & \verb~        private void BindTexture()~\\
\cellcolor{green} & 262 & \verb~134~ & & \verb~        {~\\
\cellcolor{green} & 262 & \verb~135~ & & \verb~            GL.BindTexture(TextureTarget.Texture2D, textureId);~\\
\cellcolor{green} & 262 & \verb~136~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~137~ & & \verb~~\\
\cellcolor{gray} &  & \verb~138~ & & \verb~        private void UnbindTexture()~\\
\cellcolor{green} & 262 & \verb~139~ & & \verb~        {~\\
\cellcolor{green} & 262 & \verb~140~ & & \verb~            GL.BindTexture(TextureTarget.Texture2D, 0); // 0 is invalid texture id~\\
\cellcolor{green} & 262 & \verb~141~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~142~ & & \verb~~\\
\cellcolor{gray} &  & \verb~143~ & & \verb~        private Matrix4 CreateMatrix(Shape shape)~\\
\cellcolor{red} & 0 & \verb~144~ & & \verb~        {~\\
\cellcolor{gray} &  & \verb~145~ & & \verb~            // ensure that rotation is performed around the center of the shape~\\
\cellcolor{gray} &  & \verb~146~ & & \verb~            // instead of the bottom-left corner~\\
\cellcolor{red} & 0 & \verb~147~ & & \verb~            var halfX = shape.Extent.X / 2.0f;~\\
\cellcolor{red} & 0 & \verb~148~ & & \verb~            var halfY = shape.Extent.Y / 2.0f;~\\
\cellcolor{gray} &  & \verb~149~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~150~ & & \verb~            return Matrix4.CreateTranslation(-halfX, -halfY, 0.0f) *~\\
\cellcolor{red} & 0 & \verb~151~ & & \verb~                   Matrix4.CreateRotationZ(shape.Rotation) *~\\
\cellcolor{red} & 0 & \verb~152~ & & \verb~                   Matrix4.CreateTranslation(shape.Position.X + halfX, shape.Position.Y + halfY,~\\
\cellcolor{red} & 0 & \verb~153~ & & \verb~                       0.0f);~\\
\cellcolor{red} & 0 & \verb~154~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~155~ & & \verb~~\\
\cellcolor{gray} &  & \verb~156~ & & \verb~        // Render things that are affected by a camera (if the game has one)~\\
\cellcolor{gray} &  & \verb~157~ & & \verb~        private Matrix4 CreateMatrix(Shape shape, Camera camera)~\\
\cellcolor{red} & 0 & \verb~158~ & & \verb~        {~\\
\cellcolor{gray} &  & \verb~159~ & & \verb~            // ensure that rotation is performed around the center of the shape~\\
\cellcolor{gray} &  & \verb~160~ & & \verb~            // instead of the bottom-left corner~\\
\cellcolor{red} & 0 & \verb~161~ & & \verb~            var halfX = shape.Extent.X / 2.0f;~\\
\cellcolor{red} & 0 & \verb~162~ & & \verb~            var halfY = shape.Extent.Y / 2.0f;~\\
\cellcolor{gray} &  & \verb~163~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~164~ & & \verb~            return Matrix4.CreateTranslation(~\\
\cellcolor{red} & 0 & \verb~165~ & & \verb~                -halfX - camera.Offset.X,~\\
\cellcolor{red} & 0 & \verb~166~ & & \verb~                -halfY - camera.Offset.Y,~\\
\cellcolor{red} & 0 & \verb~167~ & & \verb~                0.0f) *~\\
\cellcolor{red} & 0 & \verb~168~ & & \verb~                   Matrix4.CreateRotationZ(shape.Rotation) *~\\
\cellcolor{red} & 0 & \verb~169~ & & \verb~                   Matrix4.CreateTranslation(shape.Position.X + halfX + camera.Offset.X,~\\
\cellcolor{red} & 0 & \verb~170~ & & \verb~                    shape.Position.Y + halfY + camera.Offset.Y,~\\
\cellcolor{red} & 0 & \verb~171~ & & \verb~                       0.0f);~\\
\cellcolor{red} & 0 & \verb~172~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~173~ & & \verb~~\\
\cellcolor{gray} &  & \verb~174~ & & \verb~        public void Render(Shape shape, Camera camera)~\\
\cellcolor{red} & 0 & \verb~175~ & & \verb~        {~\\
\cellcolor{gray} &  & \verb~176~ & & \verb~~\\
\cellcolor{gray} &  & \verb~177~ & & \verb~            // bind this texture~\\
\cellcolor{red} & 0 & \verb~178~ & & \verb~            BindTexture();~\\
\cellcolor{gray} &  & \verb~179~ & & \verb~~\\
\cellcolor{gray} &  & \verb~180~ & & \verb~            // render this texture~\\
\cellcolor{red} & 0 & \verb~181~ & & \verb~            Matrix4 modelViewMatrix = CreateMatrix(shape, camera);~\\
\cellcolor{red} & 0 & \verb~182~ & & \verb~            GL.MatrixMode(MatrixMode.Modelview);~\\
\cellcolor{red} & 0 & \verb~183~ & & \verb~            GL.LoadMatrix(ref modelViewMatrix);~\\
\cellcolor{gray} &  & \verb~184~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~185~ & & \verb~            GL.Translate(camera.Offset.X, camera.Offset.Y, 0);~\\
\cellcolor{gray} &  & \verb~186~ & & \verb~            //GL.Scale(camera.Scale, camera.Scale, 1f);~\\
\cellcolor{red} & 0 & \verb~187~ & & \verb~            GL.Color4(1f, 1f, 1f, 1f);~\\
\cellcolor{red} & 0 & \verb~188~ & & \verb~            GL.Begin(PrimitiveType.Quads);~\\
\cellcolor{gray} &  & \verb~189~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~190~ & & \verb~            GL.TexCoord2(0, 1); GL.Vertex2(0.0f, 0.0f);                      // Top Left~\\
\cellcolor{red} & 0 & \verb~191~ & & \verb~            GL.TexCoord2(0, 0); GL.Vertex2(0.0f, shape.Extent.Y);            // Bottom Left~\\
\cellcolor{red} & 0 & \verb~192~ & & \verb~            GL.TexCoord2(1, 0); GL.Vertex2(shape.Extent.X, shape.Extent.Y);  // Bottom Right~\\
\cellcolor{red} & 0 & \verb~193~ & & \verb~            GL.TexCoord2(1, 1); GL.Vertex2(shape.Extent.X, 0.0f);            // Top Right~\\
\cellcolor{gray} &  & \verb~194~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~195~ & & \verb~            GL.End();~\\
\cellcolor{gray} &  & \verb~196~ & & \verb~~\\
\cellcolor{gray} &  & \verb~197~ & & \verb~            // unbind this texture~\\
\cellcolor{red} & 0 & \verb~198~ & & \verb~            UnbindTexture();~\\
\cellcolor{red} & 0 & \verb~199~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~200~ & & \verb~~\\
\cellcolor{gray} &  & \verb~201~ & & \verb~        public void Render(Shape shape)~\\
\cellcolor{red} & 0 & \verb~202~ & & \verb~        {~\\
\cellcolor{gray} &  & \verb~203~ & & \verb~~\\
\cellcolor{gray} &  & \verb~204~ & & \verb~            // bind this texture~\\
\cellcolor{red} & 0 & \verb~205~ & & \verb~            BindTexture();~\\
\cellcolor{gray} &  & \verb~206~ & & \verb~~\\
\cellcolor{gray} &  & \verb~207~ & & \verb~            // render this texture~\\
\cellcolor{red} & 0 & \verb~208~ & & \verb~            Matrix4 modelViewMatrix = CreateMatrix(shape);~\\
\cellcolor{red} & 0 & \verb~209~ & & \verb~            GL.MatrixMode(MatrixMode.Modelview);~\\
\cellcolor{red} & 0 & \verb~210~ & & \verb~            GL.LoadMatrix(ref modelViewMatrix);~\\
\cellcolor{gray} &  & \verb~211~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~212~ & & \verb~            GL.Color4(1f, 1f, 1f, 1f);~\\
\cellcolor{red} & 0 & \verb~213~ & & \verb~            GL.Begin(PrimitiveType.Quads);~\\
\cellcolor{gray} &  & \verb~214~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~215~ & & \verb~            GL.TexCoord2(0, 1); GL.Vertex2(0.0f, 0.0f);                      // Top Left~\\
\cellcolor{red} & 0 & \verb~216~ & & \verb~            GL.TexCoord2(0, 0); GL.Vertex2(0.0f, shape.Extent.Y);            // Bottom Left~\\
\cellcolor{red} & 0 & \verb~217~ & & \verb~            GL.TexCoord2(1, 0); GL.Vertex2(shape.Extent.X, shape.Extent.Y);  // Bottom Right~\\
\cellcolor{red} & 0 & \verb~218~ & & \verb~            GL.TexCoord2(1, 1); GL.Vertex2(shape.Extent.X, 0.0f);            // Top Right~\\
\cellcolor{gray} &  & \verb~219~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~220~ & & \verb~            GL.End();~\\
\cellcolor{gray} &  & \verb~221~ & & \verb~~\\
\cellcolor{gray} &  & \verb~222~ & & \verb~            // unbind this texture~\\
\cellcolor{red} & 0 & \verb~223~ & & \verb~            UnbindTexture();~\\
\cellcolor{red} & 0 & \verb~224~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~225~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~226~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.GUI.Window}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.GUI.Window\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/GUI/Window.cs}\end{minipage} \\
\textbf{Covered lines:} & 6\\
\textbf{Uncovered lines:} & 172\\
\textbf{Coverable lines:} & 178\\
\textbf{Total lines:} & 377\\
\textbf{Line coverage:} & 3.3\% (6 of 178)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 74\\
\textbf{Branch coverage:} & 0\% (0 of 74)\\
\textbf{Covered methods:} & 1\\
\textbf{Total methods:} & 26\\
\textbf{Method coverage:} & 3.8\% (1 of 26)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{get\_Title()} & 100\% & 1 & 0\%\\
\hline
\textbf{set\_Title(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{get\_Resizable()} & 100\% & 1 & 0\%\\
\hline
\textbf{CreateOpenGLContext(} & 100\% & 1 & 100\%\\
\hline
\textbf{ActivateThisWindowCo} & 100\% & 1 & 0\%\\
\hline
\textbf{.ctor(...)} & 0\% & 10 & 0\%\\
\hline
\textbf{Finalize()} & 0\% & 2 & 0\%\\
\hline
\textbf{DefaultResizeHandler} & 0\% & 2 & 0\%\\
\hline
\textbf{AddDefaultResizeHand} & 100\% & 1 & 0\%\\
\hline
\textbf{RemoveDefaultResizeH} & 100\% & 1 & 0\%\\
\hline
\textbf{DefaultKeyEventHandl} & 0\% & 4 & 0\%\\
\hline
\textbf{AddDefaultKeyEventHa} & 100\% & 1 & 0\%\\
\hline
\textbf{RemoveDefaultKeyEven} & 100\% & 1 & 0\%\\
\hline
\textbf{SetKeyEventHandler(.} & 0\% & 2 & 0\%\\
\hline
\textbf{IsRunning()} & 100\% & 1 & 0\%\\
\hline
\textbf{CloseWindow()} & 100\% & 1 & 0\%\\
\hline
\textbf{DestroyWindow()} & 100\% & 1 & 0\%\\
\hline
\textbf{Clear()} & 100\% & 1 & 0\%\\
\hline
\textbf{SetClearColor(...)} & 0\% & 12 & 0\%\\
\hline
\textbf{SetClearColor(...)} & 0\% & 12 & 0\%\\
\hline
\textbf{SetClearColor(...)} & 0\% & 12 & 0\%\\
\hline
\textbf{SetClearColor(...)} & 0\% & 12 & 0\%\\
\hline
\textbf{SetClearColor(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{SwapBuffers()} & 100\% & 1 & 0\%\\
\hline
\textbf{PollEvents()} & 100\% & 1 & 0\%\\
\hline
\textbf{SaveScreenShot()} & 0\% & 6 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/GUI/Window.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using System;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using PixelFormat = System.Drawing.Imaging.PixelFormat;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using Bitmap = System.Drawing.Bitmap;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~using RotateFlipType = System.Drawing.RotateFlipType;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~using System.Drawing.Imaging;~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~using OpenTK.Windowing.Desktop;~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~using OpenTK.Windowing.Common;~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~using OpenTK.Graphics.OpenGL;~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~using DIKUArcade.Input;~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~namespace DIKUArcade.GUI {~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~    /// This class represents a graphical window in the DIKUArcade game engine.~\\
\cellcolor{gray} &  & \verb~15~ & & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~    public class Window {~\\
\cellcolor{gray} &  & \verb~17~ & & \verb~        private static uint screenShotCounter;~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~~\\
\cellcolor{gray} &  & \verb~19~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~        /// Every DIKUArcade.Window instance has its own private~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~        /// OpenTK.GameWindow object.~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~        private GameWindow window;~\\
\cellcolor{gray} &  & \verb~24~ & & \verb~~\\
\cellcolor{gray} &  & \verb~25~ & & \verb~        private bool isRunning;~\\
\cellcolor{gray} &  & \verb~26~ & & \verb~~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~        public string Title {~\\
\cellcolor{red} & 0 & \verb~28~ & & \verb~            get { return window.Title; }~\\
\cellcolor{red} & 0 & \verb~29~ & & \verb~            set { window.Title = value; }~\\
\cellcolor{gray} &  & \verb~30~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~31~ & & \verb~~\\
\cellcolor{gray} &  & \verb~32~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~33~ & & \verb~        /// Get or set if this Window instance should be resizable.~\\
\cellcolor{gray} &  & \verb~34~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~35~ & & \verb~        public bool Resizable { get; set; } = true;~\\
\cellcolor{gray} &  & \verb~36~ & & \verb~~\\
\cellcolor{gray} &  & \verb~37~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~38~ & & \verb~        /// Instance for transforming OpenTK key events to DIKUArcade-interfaced~\\
\cellcolor{gray} &  & \verb~39~ & & \verb~        /// key events, based on globalization settings.~\\
\cellcolor{gray} &  & \verb~40~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~41~ & & \verb~        private IKeyTransformer keyTransformer;~\\
\cellcolor{gray} &  & \verb~42~ & & \verb~~\\
\cellcolor{gray} &  & \verb~43~ & & \verb~~\\
\cellcolor{gray} &  & \verb~44~ & & \verb~        #region OpenGLContext~\\
\cellcolor{gray} &  & \verb~45~ & & \verb~~\\
\cellcolor{gray} &  & \verb~46~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~47~ & & \verb~        /// A static, private OpenTK.GameWindow instance.~\\
\cellcolor{gray} &  & \verb~48~ & & \verb~        /// Only used for initializing an OpenGL context in the background.~\\
\cellcolor{gray} &  & \verb~49~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~50~ & & \verb~        private static GameWindow _contextWin;~\\
\cellcolor{gray} &  & \verb~51~ & & \verb~~\\
\cellcolor{gray} &  & \verb~52~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~53~ & & \verb~        /// Use this method to create an OpenGL context.~\\
\cellcolor{gray} &  & \verb~54~ & & \verb~        /// Never use this method in your application, ONLY in unit testing.~\\
\cellcolor{gray} &  & \verb~55~ & & \verb~        /// This will enable you to unit test classes which use OpenGL-dependent~\\
\cellcolor{gray} &  & \verb~56~ & & \verb~        /// function calls, including `Text', `Image', and `ImageStride' classes.~\\
\cellcolor{gray} &  & \verb~57~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 210 & \verb~58~ & & \verb~        public static void CreateOpenGLContext() {~\\
\cellcolor{green} & 210 & \verb~59~ & & \verb~            var settings = new GameWindowSettings();~\\
\cellcolor{green} & 210 & \verb~60~ & & \verb~            var nativeSettings = new NativeWindowSettings();~\\
\cellcolor{green} & 210 & \verb~61~ & & \verb~            Window._contextWin = new GameWindow(settings, nativeSettings);~\\
\cellcolor{green} & 210 & \verb~62~ & & \verb~            Window._contextWin.Context.MakeCurrent();~\\
\cellcolor{green} & 210 & \verb~63~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~64~ & & \verb~~\\
\cellcolor{gray} &  & \verb~65~ & & \verb~        #endregion~\\
\cellcolor{gray} &  & \verb~66~ & & \verb~~\\
\cellcolor{gray} &  & \verb~67~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~68~ & & \verb~        private void ActivateThisWindowContext(string title, uint width, uint height, bool fullscreen) {~\\
\cellcolor{gray} &  & \verb~69~ & & \verb~            // We use OpenGL 2.0 (ie. fixed-function pipeline!)~\\
\cellcolor{red} & 0 & \verb~70~ & & \verb~            var settings = new GameWindowSettings();~\\
\cellcolor{red} & 0 & \verb~71~ & & \verb~            settings.IsMultiThreaded = false;~\\
\cellcolor{red} & 0 & \verb~72~ & & \verb~            var nativeSettings = new NativeWindowSettings();~\\
\cellcolor{red} & 0 & \verb~73~ & & \verb~            nativeSettings.Profile = ContextProfile.Any;~\\
\cellcolor{red} & 0 & \verb~74~ & & \verb~            nativeSettings.WindowState = WindowState.Normal;~\\
\cellcolor{red} & 0 & \verb~75~ & & \verb~            nativeSettings.API = ContextAPI.OpenGL;~\\
\cellcolor{red} & 0 & \verb~76~ & & \verb~            nativeSettings.APIVersion = new Version(2, 0);~\\
\cellcolor{red} & 0 & \verb~77~ & & \verb~            nativeSettings.IsFullscreen = fullscreen;~\\
\cellcolor{gray} &  & \verb~78~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~79~ & & \verb~            window = new GameWindow(settings, nativeSettings) {~\\
\cellcolor{red} & 0 & \verb~80~ & & \verb~                Title = title,~\\
\cellcolor{red} & 0 & \verb~81~ & & \verb~                Size = new OpenTK.Mathematics.Vector2i((int)width, (int)height)~\\
\cellcolor{red} & 0 & \verb~82~ & & \verb~            };~\\
\cellcolor{gray} &  & \verb~83~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~84~ & & \verb~            GL.ClearDepth(1);~\\
\cellcolor{red} & 0 & \verb~85~ & & \verb~            GL.ClearColor(0.0f, 0.0f, 0.0f, 1.0f);~\\
\cellcolor{gray} &  & \verb~86~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~87~ & & \verb~            isRunning = true;~\\
\cellcolor{red} & 0 & \verb~88~ & & \verb~            window.Context.MakeCurrent();~\\
\cellcolor{red} & 0 & \verb~89~ & & \verb~            window.IsVisible = true;~\\
\cellcolor{gray} &  & \verb~90~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~91~ & & \verb~            GL.Viewport(0, 0, window.Size.X, window.Size.Y);~\\
\cellcolor{red} & 0 & \verb~92~ & & \verb~            GL.MatrixMode(MatrixMode.Projection);~\\
\cellcolor{red} & 0 & \verb~93~ & & \verb~            GL.LoadIdentity();~\\
\cellcolor{red} & 0 & \verb~94~ & & \verb~            GL.Ortho(0.0,1.0,0.0,1.0, 0.0, 4.0);~\\
\cellcolor{red} & 0 & \verb~95~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~96~ & & \verb~~\\
\cellcolor{gray} &  & \verb~97~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~98~ & & \verb~        public Window(WindowArgs windowArgs) {~\\
\cellcolor{gray} &  & \verb~99~ & & \verb~            // keyboard layout~\\
\cellcolor{red} & 0 & \verb~100~ & & \verb~            switch(windowArgs.KeyboardLayout) {~\\
\cellcolor{gray} &  & \verb~101~ & & \verb~                case KeyboardLayout.Danish:~\\
\cellcolor{red} & 0 & \verb~102~ & & \verb~                    keyTransformer = new Input.Languages.DanishKeyTransformer();~\\
\cellcolor{red} & 0 & \verb~103~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~104~ & & \verb~                default:~\\
\cellcolor{red} & 0 & \verb~105~ & & \verb~                    throw new ArgumentException("Window(): only Danish keyboard layout is currently supported!");~\\
\cellcolor{gray} &  & \verb~106~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~107~ & & \verb~~\\
\cellcolor{gray} &  & \verb~108~ & & \verb~            // window dimensions~\\
\cellcolor{red} & 0 & \verb~109~ & & \verb~            uint width = windowArgs.Width;~\\
\cellcolor{red} & 0 & \verb~110~ & & \verb~            uint height = windowArgs.Height;~\\
\cellcolor{red} & 0 & \verb~111~ & & \verb~            switch (windowArgs.AspectRatio) {~\\
\cellcolor{gray} &  & \verb~112~ & & \verb~                case WindowAspectRatio.Aspect_Custom:~\\
\cellcolor{red} & 0 & \verb~113~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~114~ & & \verb~                case WindowAspectRatio.Aspect_1X1:~\\
\cellcolor{red} & 0 & \verb~115~ & & \verb~                    width = height;~\\
\cellcolor{red} & 0 & \verb~116~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~117~ & & \verb~                case WindowAspectRatio.Aspect_3X2:~\\
\cellcolor{red} & 0 & \verb~118~ & & \verb~                    width = (height * 3) / 2;~\\
\cellcolor{red} & 0 & \verb~119~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~120~ & & \verb~                case WindowAspectRatio.Aspect_4X3:~\\
\cellcolor{red} & 0 & \verb~121~ & & \verb~                    width = (height * 4) / 3;~\\
\cellcolor{red} & 0 & \verb~122~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~123~ & & \verb~                case WindowAspectRatio.Aspect_16X9:~\\
\cellcolor{red} & 0 & \verb~124~ & & \verb~                    width = (height * 16) / 9;~\\
\cellcolor{red} & 0 & \verb~125~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~126~ & & \verb~                default:~\\
\cellcolor{red} & 0 & \verb~127~ & & \verb~                    throw new ArgumentException("Window(): invalid aspect ratio!");~\\
\cellcolor{gray} &  & \verb~128~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~129~ & & \verb~~\\
\cellcolor{gray} &  & \verb~130~ & & \verb~            // create and bind OpenGL context~\\
\cellcolor{red} & 0 & \verb~131~ & & \verb~            ActivateThisWindowContext(windowArgs.Title, width, height, windowArgs.FullScreen);~\\
\cellcolor{gray} &  & \verb~132~ & & \verb~~\\
\cellcolor{gray} &  & \verb~133~ & & \verb~            // setup event handlers~\\
\cellcolor{red} & 0 & \verb~134~ & & \verb~            if (windowArgs.Resizable) {~\\
\cellcolor{red} & 0 & \verb~135~ & & \verb~                AddDefaultResizeHandler();~\\
\cellcolor{red} & 0 & \verb~136~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~137~ & & \verb~            AddDefaultKeyEventHandler();~\\
\cellcolor{red} & 0 & \verb~138~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~139~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~140~ & & \verb~         Window() {~\\
\cellcolor{red} & 0 & \verb~141~ & & \verb~            if (window != null) this.DestroyWindow();~\\
\cellcolor{red} & 0 & \verb~142~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~143~ & & \verb~~\\
\cellcolor{gray} &  & \verb~144~ & & \verb~~\\
\cellcolor{gray} &  & \verb~145~ & & \verb~        #region WINDOW_RESIZE~\\
\cellcolor{gray} &  & \verb~146~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~147~ & & \verb~        private void DefaultResizeHandler(ResizeEventArgs args) {~\\
\cellcolor{red} & 0 & \verb~148~ & & \verb~            if (!Resizable) {~\\
\cellcolor{red} & 0 & \verb~149~ & & \verb~                return;~\\
\cellcolor{gray} &  & \verb~150~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~151~ & & \verb~~\\
\cellcolor{gray} &  & \verb~152~ & & \verb~            // GL.Viewport(0, 0, window.Size.X, window.Size.Y);~\\
\cellcolor{red} & 0 & \verb~153~ & & \verb~            GL.Viewport(0, 0, args.Size.X, args.Size.Y); // TODO: Is that right?~\\
\cellcolor{red} & 0 & \verb~154~ & & \verb~            GL.MatrixMode(MatrixMode.Projection);~\\
\cellcolor{red} & 0 & \verb~155~ & & \verb~            GL.LoadIdentity();~\\
\cellcolor{red} & 0 & \verb~156~ & & \verb~            GL.Ortho(0.0, 1.0, 0.0, 1.0, 0.0, 4.0);~\\
\cellcolor{red} & 0 & \verb~157~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~158~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~159~ & & \verb~        private void AddDefaultResizeHandler() {~\\
\cellcolor{red} & 0 & \verb~160~ & & \verb~            window.Resize += DefaultResizeHandler;~\\
\cellcolor{red} & 0 & \verb~161~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~162~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~163~ & & \verb~        private void RemoveDefaultResizeHandler() {~\\
\cellcolor{red} & 0 & \verb~164~ & & \verb~            window.Resize -= DefaultResizeHandler;~\\
\cellcolor{red} & 0 & \verb~165~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~166~ & & \verb~~\\
\cellcolor{gray} &  & \verb~167~ & & \verb~        #endregion WINDOW_RESIZE~\\
\cellcolor{gray} &  & \verb~168~ & & \verb~~\\
\cellcolor{gray} &  & \verb~169~ & & \verb~        #region KEY_EVENT_HANDLERS~\\
\cellcolor{gray} &  & \verb~170~ & & \verb~~\\
\cellcolor{gray} &  & \verb~171~ & & \verb~~\\
\cellcolor{gray} &  & \verb~172~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~173~ & & \verb~        private void DefaultKeyEventHandler(KeyboardKeyEventArgs args) {~\\
\cellcolor{red} & 0 & \verb~174~ & & \verb~            switch(args.Key) {~\\
\cellcolor{gray} &  & \verb~175~ & & \verb~                case OpenTK.Windowing.GraphicsLibraryFramework.Keys.Escape:~\\
\cellcolor{red} & 0 & \verb~176~ & & \verb~                    CloseWindow();~\\
\cellcolor{red} & 0 & \verb~177~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~178~ & & \verb~                case OpenTK.Windowing.GraphicsLibraryFramework.Keys.F12:~\\
\cellcolor{red} & 0 & \verb~179~ & & \verb~                    SaveScreenShot();~\\
\cellcolor{red} & 0 & \verb~180~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~181~ & & \verb~                default:~\\
\cellcolor{red} & 0 & \verb~182~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~183~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~184~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~185~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~186~ & & \verb~        private void AddDefaultKeyEventHandler() {~\\
\cellcolor{red} & 0 & \verb~187~ & & \verb~            window.KeyDown += DefaultKeyEventHandler;~\\
\cellcolor{red} & 0 & \verb~188~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~189~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~190~ & & \verb~        private void RemoveDefaultKeyEventHandler() {~\\
\cellcolor{red} & 0 & \verb~191~ & & \verb~            window.KeyDown -= DefaultKeyEventHandler;~\\
\cellcolor{red} & 0 & \verb~192~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~193~ & & \verb~~\\
\cellcolor{gray} &  & \verb~194~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~195~ & & \verb~        /// Attach the specified keyHandler method argument to this window object.~\\
\cellcolor{gray} &  & \verb~196~ & & \verb~        /// All key inputs will thereafter be directed to this keyHandler.~\\
\cellcolor{gray} &  & \verb~197~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~198~ & & \verb~        public void SetKeyEventHandler(Action<KeyboardAction,KeyboardKey> keyHandler) {~\\
\cellcolor{red} & 0 & \verb~199~ & & \verb~            RemoveDefaultKeyEventHandler();~\\
\cellcolor{red} & 0 & \verb~200~ & & \verb~            window.KeyDown += args => {~\\
\cellcolor{red} & 0 & \verb~201~ & & \verb~                if (!args.IsRepeat) keyHandler(KeyboardAction.KeyPress, keyTransformer.TransformKey(args.Key));~\\
\cellcolor{red} & 0 & \verb~202~ & & \verb~            };~\\
\cellcolor{red} & 0 & \verb~203~ & & \verb~            window.KeyUp += args => {~\\
\cellcolor{red} & 0 & \verb~204~ & & \verb~                keyHandler(KeyboardAction.KeyRelease, keyTransformer.TransformKey(args.Key));~\\
\cellcolor{red} & 0 & \verb~205~ & & \verb~            };~\\
\cellcolor{red} & 0 & \verb~206~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~207~ & & \verb~~\\
\cellcolor{gray} &  & \verb~208~ & & \verb~        #endregion KEY_EVENT_HANDLERS~\\
\cellcolor{gray} &  & \verb~209~ & & \verb~~\\
\cellcolor{gray} &  & \verb~210~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~211~ & & \verb~        /// Check if the Window is still running.~\\
\cellcolor{gray} &  & \verb~212~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~213~ & & \verb~        public bool IsRunning() {~\\
\cellcolor{red} & 0 & \verb~214~ & & \verb~            return isRunning;~\\
\cellcolor{red} & 0 & \verb~215~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~216~ & & \verb~~\\
\cellcolor{gray} &  & \verb~217~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~218~ & & \verb~        /// Sets the window running variable to false such that calls to~\\
\cellcolor{gray} &  & \verb~219~ & & \verb~        /// `IsRunning()` afterwards will return false. This will allow one~\\
\cellcolor{gray} &  & \verb~220~ & & \verb~        /// to exit the game loop.~\\
\cellcolor{gray} &  & \verb~221~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~222~ & & \verb~        public void CloseWindow() {~\\
\cellcolor{red} & 0 & \verb~223~ & & \verb~            isRunning = false;~\\
\cellcolor{red} & 0 & \verb~224~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~225~ & & \verb~~\\
\cellcolor{gray} &  & \verb~226~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~227~ & & \verb~        /// Close the underlying OpenTK window object.~\\
\cellcolor{gray} &  & \verb~228~ & & \verb~        /// Do not call this method outside the engine.~\\
\cellcolor{gray} &  & \verb~229~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~230~ & & \verb~        public void DestroyWindow() {~\\
\cellcolor{red} & 0 & \verb~231~ & & \verb~            window.Close();~\\
\cellcolor{red} & 0 & \verb~232~ & & \verb~            window.Dispose();~\\
\cellcolor{red} & 0 & \verb~233~ & & \verb~            window = null;~\\
\cellcolor{red} & 0 & \verb~234~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~235~ & & \verb~~\\
\cellcolor{gray} &  & \verb~236~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~237~ & & \verb~        /// Clear the Window with a uniform background color.~\\
\cellcolor{gray} &  & \verb~238~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~239~ & & \verb~        public void Clear() {~\\
\cellcolor{red} & 0 & \verb~240~ & & \verb~            GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);~\\
\cellcolor{red} & 0 & \verb~241~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~242~ & & \verb~~\\
\cellcolor{gray} &  & \verb~243~ & & \verb~        #region SET_CLEAR_COLOR~\\
\cellcolor{gray} &  & \verb~244~ & & \verb~~\\
\cellcolor{gray} &  & \verb~245~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~246~ & & \verb~        /// Set color to be used as clear color when using the Window.Clear() method.~\\
\cellcolor{gray} &  & \verb~247~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~248~ & & \verb~        /// <param name="vec">Vec3F containing the RGB color values.</param>~\\
\cellcolor{gray} &  & \verb~249~ & & \verb~        /// <exception cref="ArgumentOutOfRangeException">Normalized color values must be~\\
\cellcolor{gray} &  & \verb~250~ & & \verb~        /// between 0 and 1.</exception>~\\
\cellcolor{red} & 0 & \verb~251~ & & \verb~        public void SetClearColor(Math.Vec3F vec) {~\\
\cellcolor{red} & 0 & \verb~252~ & & \verb~            if (vec.X < 0.0f || vec.X > 1.0f ||~\\
\cellcolor{red} & 0 & \verb~253~ & & \verb~                vec.Y < 0.0f || vec.Y > 1.0f ||~\\
\cellcolor{red} & 0 & \verb~254~ & & \verb~                vec.Z < 0.0f || vec.Z > 1.0f) {~\\
\cellcolor{red} & 0 & \verb~255~ & & \verb~                throw new ArgumentOutOfRangeException(~\\
\cellcolor{red} & 0 & \verb~256~ & & \verb~                    $"Normalized RGB Color values must be between 0 and 1: {vec}");~\\
\cellcolor{gray} &  & \verb~257~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~258~ & & \verb~            GL.ClearColor(vec.X, vec.Y, vec.Z, 1.0f);~\\
\cellcolor{red} & 0 & \verb~259~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~260~ & & \verb~~\\
\cellcolor{gray} &  & \verb~261~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~262~ & & \verb~        /// Set color to be used as clear color when using the Window.Clear() method.~\\
\cellcolor{gray} &  & \verb~263~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~264~ & & \verb~        /// <param name="vec">Vec3I containing the RGB color values.</param>~\\
\cellcolor{gray} &  & \verb~265~ & & \verb~        /// <exception cref="ArgumentOutOfRangeException">Color values must be between 0 and 255.</exception>~\\
\cellcolor{red} & 0 & \verb~266~ & & \verb~        public void SetClearColor(Math.Vec3I vec) {~\\
\cellcolor{red} & 0 & \verb~267~ & & \verb~            if (vec.X < 0 || vec.X > 255 ||~\\
\cellcolor{red} & 0 & \verb~268~ & & \verb~                vec.Y < 0 || vec.Y > 255 ||~\\
\cellcolor{red} & 0 & \verb~269~ & & \verb~                vec.Z < 0 || vec.Z > 255) {~\\
\cellcolor{red} & 0 & \verb~270~ & & \verb~                throw new ArgumentOutOfRangeException(~\\
\cellcolor{red} & 0 & \verb~271~ & & \verb~                    $"RGB Color values must be between 0 and 255: {vec}");~\\
\cellcolor{gray} &  & \verb~272~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~273~ & & \verb~            GL.ClearColor(vec.X / 255.0f, vec.Y / 255.0f, vec.Z / 255.0f, 1.0f);~\\
\cellcolor{red} & 0 & \verb~274~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~275~ & & \verb~~\\
\cellcolor{gray} &  & \verb~276~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~277~ & & \verb~        /// Set color to be used as clear color when using the Window.Clear() method.~\\
\cellcolor{gray} &  & \verb~278~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~279~ & & \verb~        /// <param name="r">red channel value</param>~\\
\cellcolor{gray} &  & \verb~280~ & & \verb~        /// <param name="g">green channel value</param>~\\
\cellcolor{gray} &  & \verb~281~ & & \verb~        /// <param name="b">blue channel value</param>~\\
\cellcolor{gray} &  & \verb~282~ & & \verb~        /// <exception cref="ArgumentOutOfRangeException">Normalized color values must be~\\
\cellcolor{gray} &  & \verb~283~ & & \verb~        /// between 0 and 1.</exception>~\\
\cellcolor{red} & 0 & \verb~284~ & & \verb~        public void SetClearColor(float r, float g, float b) {~\\
\cellcolor{red} & 0 & \verb~285~ & & \verb~            if (r < 0.0f || r > 1.0f ||~\\
\cellcolor{red} & 0 & \verb~286~ & & \verb~                g < 0.0f || g > 1.0f ||~\\
\cellcolor{red} & 0 & \verb~287~ & & \verb~                b < 0.0f || b > 1.0f) {~\\
\cellcolor{red} & 0 & \verb~288~ & & \verb~                throw new ArgumentOutOfRangeException(~\\
\cellcolor{red} & 0 & \verb~289~ & & \verb~                    $"Normalized RGB Color values must be between 0 and 1: ({r},{g},{b})");~\\
\cellcolor{gray} &  & \verb~290~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~291~ & & \verb~            GL.ClearColor(r, g, b, 1.0f);~\\
\cellcolor{red} & 0 & \verb~292~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~293~ & & \verb~~\\
\cellcolor{gray} &  & \verb~294~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~295~ & & \verb~        /// Set color to be used as clear color when using the Window.Clear() method.~\\
\cellcolor{gray} &  & \verb~296~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~297~ & & \verb~        /// <param name="r">red channel value</param>~\\
\cellcolor{gray} &  & \verb~298~ & & \verb~        /// <param name="g">green channel value</param>~\\
\cellcolor{gray} &  & \verb~299~ & & \verb~        /// <param name="b">blue channel value</param>~\\
\cellcolor{gray} &  & \verb~300~ & & \verb~        /// <exception cref="ArgumentOutOfRangeException">Color values must be between 0 and 255.</exception>~\\
\cellcolor{red} & 0 & \verb~301~ & & \verb~        public void SetClearColor(int r, int g, int b) {~\\
\cellcolor{red} & 0 & \verb~302~ & & \verb~            if (r < 0 || r > 255 ||~\\
\cellcolor{red} & 0 & \verb~303~ & & \verb~                g < 0 || g > 255 ||~\\
\cellcolor{red} & 0 & \verb~304~ & & \verb~                b < 0 || b > 255) {~\\
\cellcolor{red} & 0 & \verb~305~ & & \verb~                throw new ArgumentOutOfRangeException(~\\
\cellcolor{red} & 0 & \verb~306~ & & \verb~                    $"RGB Color values must be between 0 and 255: ({r},{g},{b})");~\\
\cellcolor{gray} &  & \verb~307~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~308~ & & \verb~            GL.ClearColor(r / 255.0f, g / 255.0f, b / 255.0f, 1.0f);~\\
\cellcolor{red} & 0 & \verb~309~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~310~ & & \verb~~\\
\cellcolor{gray} &  & \verb~311~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~312~ & & \verb~        /// Set color to be used as clear color when using the Window.Clear() method.~\\
\cellcolor{gray} &  & \verb~313~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~314~ & & \verb~        /// <param name="color">System.Drawing.Color object containing color channel values.</param>~\\
\cellcolor{red} & 0 & \verb~315~ & & \verb~        public void SetClearColor(System.Drawing.Color color) {~\\
\cellcolor{red} & 0 & \verb~316~ & & \verb~            SetClearColor(new Math.Vec3I(color.R, color.G, color.B));~\\
\cellcolor{red} & 0 & \verb~317~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~318~ & & \verb~~\\
\cellcolor{gray} &  & \verb~319~ & & \verb~        #endregion~\\
\cellcolor{gray} &  & \verb~320~ & & \verb~~\\
\cellcolor{gray} &  & \verb~321~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~322~ & & \verb~        /// Swap double buffers for the Window.~\\
\cellcolor{gray} &  & \verb~323~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~324~ & & \verb~        public void SwapBuffers() {~\\
\cellcolor{red} & 0 & \verb~325~ & & \verb~            window.SwapBuffers();~\\
\cellcolor{red} & 0 & \verb~326~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~327~ & & \verb~~\\
\cellcolor{gray} &  & \verb~328~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~329~ & & \verb~        /// Check for incoming keyboard or mouse events.~\\
\cellcolor{gray} &  & \verb~330~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~331~ & & \verb~        public void PollEvents() {~\\
\cellcolor{red} & 0 & \verb~332~ & & \verb~            window.ProcessEvents();~\\
\cellcolor{red} & 0 & \verb~333~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~334~ & & \verb~~\\
\cellcolor{gray} &  & \verb~335~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~336~ & & \verb~        /// Save a screenshot of the Window's current state.~\\
\cellcolor{gray} &  & \verb~337~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~338~ & & \verb~        /// <exception cref="GraphicsContextMissingException"></exception>~\\
\cellcolor{red} & 0 & \verb~339~ & & \verb~        public void SaveScreenShot() {~\\
\cellcolor{red} & 0 & \verb~340~ & & \verb~            if (window.Context == null) {~\\
\cellcolor{red} & 0 & \verb~341~ & & \verb~                throw new ArgumentNullException("GraphicsContextMissingException");~\\
\cellcolor{gray} &  & \verb~342~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~343~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~344~ & & \verb~            var bmp = new Bitmap(window.ClientSize.X, window.ClientSize.Y, PixelFormat.Format24bppRgb);~\\
\cellcolor{red} & 0 & \verb~345~ & & \verb~            var data = bmp.LockBits(new System.Drawing.Rectangle(0, 0, window.ClientSize.X, window.ClientSize.Y),~\\
\cellcolor{red} & 0 & \verb~346~ & & \verb~                                    ImageLockMode.WriteOnly,~\\
\cellcolor{red} & 0 & \verb~347~ & & \verb~                                    PixelFormat.Format24bppRgb);~\\
\cellcolor{red} & 0 & \verb~348~ & & \verb~            GL.ReadPixels(0, 0, window.ClientSize.X, window.ClientSize.Y,~\\
\cellcolor{red} & 0 & \verb~349~ & & \verb~                OpenTK.Graphics.OpenGL.PixelFormat.Bgr,~\\
\cellcolor{red} & 0 & \verb~350~ & & \verb~                PixelType.UnsignedByte, data.Scan0);~\\
\cellcolor{red} & 0 & \verb~351~ & & \verb~            bmp.UnlockBits(data);~\\
\cellcolor{gray} &  & \verb~352~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~353~ & & \verb~            bmp.RotateFlip(RotateFlipType.RotateNoneFlipY);~\\
\cellcolor{gray} &  & \verb~354~ & & \verb~~\\
\cellcolor{gray} &  & \verb~355~ & & \verb~            // save screenshot, not in bin/Debug (et sim.), but in a logical place~\\
\cellcolor{red} & 0 & \verb~356~ & & \verb~            var dir = new DirectoryInfo(Path.GetDirectoryName(~\\
\cellcolor{red} & 0 & \verb~357~ & & \verb~                System.Reflection.Assembly.GetExecutingAssembly().Location));~\\
\cellcolor{gray} &  & \verb~358~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~359~ & & \verb~            while (dir.Name != "bin") {~\\
\cellcolor{red} & 0 & \verb~360~ & & \verb~                dir = dir.Parent;~\\
\cellcolor{red} & 0 & \verb~361~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~362~ & & \verb~            dir = dir.Parent;~\\
\cellcolor{gray} &  & \verb~363~ & & \verb~~\\
\cellcolor{gray} &  & \verb~364~ & & \verb~            // build the save path~\\
\cellcolor{red} & 0 & \verb~365~ & & \verb~            var saveName = $"screenShot_{Window.screenShotCounter++}.bmp";~\\
\cellcolor{red} & 0 & \verb~366~ & & \verb~            var folder = Path.Combine(dir.ToString(), "screenShots");~\\
\cellcolor{red} & 0 & \verb~367~ & & \verb~            var path = Path.Combine(folder, saveName);~\\
\cellcolor{gray} &  & \verb~368~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~369~ & & \verb~            if (!Directory.Exists(folder)) {~\\
\cellcolor{red} & 0 & \verb~370~ & & \verb~                Directory.CreateDirectory(folder);~\\
\cellcolor{red} & 0 & \verb~371~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~372~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~373~ & & \verb~            bmp.Save(path);~\\
\cellcolor{red} & 0 & \verb~374~ & & \verb~            Console.WriteLine($"Screenshot saved as: {path}");~\\
\cellcolor{red} & 0 & \verb~375~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~376~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~377~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.GUI.WindowArgs}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.GUI.WindowArgs\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/GUI/WindowArgs.cs}\end{minipage} \\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 7\\
\textbf{Coverable lines:} & 7\\
\textbf{Total lines:} & 27\\
\textbf{Line coverage:} & 0\% (0 of 7)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 0\\
\textbf{Covered methods:} & 0\\
\textbf{Total methods:} & 7\\
\textbf{Method coverage:} & 0\% (0 of 7)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{get\_KeyboardLayout()} & 100\% & 1 & 0\%\\
\hline
\textbf{get\_Title()} & 100\% & 1 & 0\%\\
\hline
\textbf{get\_Width()} & 100\% & 1 & 0\%\\
\hline
\textbf{get\_Height()} & 100\% & 1 & 0\%\\
\hline
\textbf{get\_AspectRatio()} & 100\% & 1 & 0\%\\
\hline
\textbf{get\_FullScreen()} & 100\% & 1 & 0\%\\
\hline
\textbf{get\_Resizable()} & 100\% & 1 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/GUI/WindowArgs.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Input;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~namespace DIKUArcade.GUI {~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~    /// Arguments for constructing a DIKUArcade.Window object.~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~    /// Use this class to set fundamental properties of the window.~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~    public class WindowArgs {~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~        /* Globalisation settings */~\\
\cellcolor{red} & 0 & \verb~10~ & & \verb~        public KeyboardLayout KeyboardLayout { get; set; } = KeyboardLayout.Danish;~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~        /* Basic window properties */~\\
\cellcolor{red} & 0 & \verb~13~ & & \verb~        public string Title { get; set; } = "DIKUArcade";~\\
\cellcolor{red} & 0 & \verb~14~ & & \verb~        public uint Width { get; set; } = 500U;~\\
\cellcolor{red} & 0 & \verb~15~ & & \verb~        public uint Height { get; set; } = 500U;~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~~\\
\cellcolor{gray} &  & \verb~17~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~        /// Specify window aspect ratio. If this value is something else than `WindowAspectRatio.Aspect_Custom`,~\\
\cellcolor{gray} &  & \verb~19~ & & \verb~        /// then the width of the window will be calculated automatically based on the height.~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~21~ & & \verb~        public WindowAspectRatio AspectRatio { get; set; } = WindowAspectRatio.Aspect_Custom;~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~        /* Graphical properties */~\\
\cellcolor{red} & 0 & \verb~24~ & & \verb~        public bool FullScreen { get; set; } = false;~\\
\cellcolor{red} & 0 & \verb~25~ & & \verb~        public bool Resizable { get; set; } = true;~\\
\cellcolor{gray} &  & \verb~26~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Input.Languages.DanishKeyTransformer}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Input.Languages.DanishKeyTransformer\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{top/SU/DIKUGames/DIKUArcade/DIKUArcade/Input/Languages/DanishKeyTransformer.cs}\end{minipage} \\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 125\\
\textbf{Coverable lines:} & 125\\
\textbf{Total lines:} & 155\\
\textbf{Line coverage:} & 0\% (0 of 125)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 194\\
\textbf{Branch coverage:} & 0\% (0 of 194)\\
\textbf{Covered methods:} & 0\\
\textbf{Total methods:} & 1\\
\textbf{Method coverage:} & 0\% (0 of 1)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{TransformKey(...)} & 0\% & 194 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{top/SU/DIKUGames/DIKUArcade/DIKUArcade/Input/Languages/DanishKeyTransformer.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using OpenTK.Windowing.GraphicsLibraryFramework;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.Input;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using System;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~namespace DIKUArcade.Input.Languages~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~{~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~    /// Represents the Danish keyboard layout.~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~    public class DanishKeyTransformer : IKeyTransformer~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~    {~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~        public KeyboardKey TransformKey(Keys key)~\\
\cellcolor{red} & 0 & \verb~13~ & & \verb~        {~\\
\cellcolor{red} & 0 & \verb~14~ & & \verb~            switch (key)~\\
\cellcolor{gray} &  & \verb~15~ & & \verb~            {~\\
\cellcolor{red} & 0 & \verb~16~ & & \verb~                case Keys.Unknown: return KeyboardKey.Unknown;~\\
\cellcolor{red} & 0 & \verb~17~ & & \verb~                case Keys.Space: return KeyboardKey.Space;~\\
\cellcolor{red} & 0 & \verb~18~ & & \verb~                case Keys.Apostrophe: return KeyboardKey.Danish_OE;~\\
\cellcolor{red} & 0 & \verb~19~ & & \verb~                case Keys.Comma: return KeyboardKey.Comma;~\\
\cellcolor{red} & 0 & \verb~20~ & & \verb~                case Keys.Minus: return KeyboardKey.Plus;~\\
\cellcolor{red} & 0 & \verb~21~ & & \verb~                case Keys.Period: return KeyboardKey.Period;~\\
\cellcolor{red} & 0 & \verb~22~ & & \verb~                case Keys.Slash: return KeyboardKey.Minus;~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~24~ & & \verb~                case Keys.D0: return KeyboardKey.Num_0;~\\
\cellcolor{red} & 0 & \verb~25~ & & \verb~                case Keys.D1: return KeyboardKey.Num_1;~\\
\cellcolor{red} & 0 & \verb~26~ & & \verb~                case Keys.D2: return KeyboardKey.Num_2;~\\
\cellcolor{red} & 0 & \verb~27~ & & \verb~                case Keys.D3: return KeyboardKey.Num_3;~\\
\cellcolor{red} & 0 & \verb~28~ & & \verb~                case Keys.D4: return KeyboardKey.Num_4;~\\
\cellcolor{red} & 0 & \verb~29~ & & \verb~                case Keys.D5: return KeyboardKey.Num_5;~\\
\cellcolor{red} & 0 & \verb~30~ & & \verb~                case Keys.D6: return KeyboardKey.Num_6;~\\
\cellcolor{red} & 0 & \verb~31~ & & \verb~                case Keys.D7: return KeyboardKey.Num_7;~\\
\cellcolor{red} & 0 & \verb~32~ & & \verb~                case Keys.D8: return KeyboardKey.Num_8;~\\
\cellcolor{red} & 0 & \verb~33~ & & \verb~                case Keys.D9: return KeyboardKey.Num_9;~\\
\cellcolor{red} & 0 & \verb~34~ & & \verb~                case Keys.Semicolon: return KeyboardKey.Danish_AE;~\\
\cellcolor{red} & 0 & \verb~35~ & & \verb~                case Keys.Equal: return KeyboardKey.AcuteAccent;~\\
\cellcolor{gray} &  & \verb~36~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~37~ & & \verb~                case Keys.A: return KeyboardKey.A;~\\
\cellcolor{red} & 0 & \verb~38~ & & \verb~                case Keys.B: return KeyboardKey.B;~\\
\cellcolor{red} & 0 & \verb~39~ & & \verb~                case Keys.C: return KeyboardKey.C;~\\
\cellcolor{red} & 0 & \verb~40~ & & \verb~                case Keys.D: return KeyboardKey.D;~\\
\cellcolor{red} & 0 & \verb~41~ & & \verb~                case Keys.E: return KeyboardKey.E;~\\
\cellcolor{red} & 0 & \verb~42~ & & \verb~                case Keys.F: return KeyboardKey.F;~\\
\cellcolor{red} & 0 & \verb~43~ & & \verb~                case Keys.G: return KeyboardKey.G;~\\
\cellcolor{red} & 0 & \verb~44~ & & \verb~                case Keys.H: return KeyboardKey.H;~\\
\cellcolor{red} & 0 & \verb~45~ & & \verb~                case Keys.I: return KeyboardKey.I;~\\
\cellcolor{red} & 0 & \verb~46~ & & \verb~                case Keys.J: return KeyboardKey.J;~\\
\cellcolor{red} & 0 & \verb~47~ & & \verb~                case Keys.K: return KeyboardKey.K;~\\
\cellcolor{red} & 0 & \verb~48~ & & \verb~                case Keys.L: return KeyboardKey.L;~\\
\cellcolor{red} & 0 & \verb~49~ & & \verb~                case Keys.M: return KeyboardKey.M;~\\
\cellcolor{red} & 0 & \verb~50~ & & \verb~                case Keys.N: return KeyboardKey.N;~\\
\cellcolor{red} & 0 & \verb~51~ & & \verb~                case Keys.O: return KeyboardKey.O;~\\
\cellcolor{red} & 0 & \verb~52~ & & \verb~                case Keys.P: return KeyboardKey.P;~\\
\cellcolor{red} & 0 & \verb~53~ & & \verb~                case Keys.Q: return KeyboardKey.Q;~\\
\cellcolor{red} & 0 & \verb~54~ & & \verb~                case Keys.R: return KeyboardKey.R;~\\
\cellcolor{red} & 0 & \verb~55~ & & \verb~                case Keys.S: return KeyboardKey.S;~\\
\cellcolor{red} & 0 & \verb~56~ & & \verb~                case Keys.T: return KeyboardKey.T;~\\
\cellcolor{red} & 0 & \verb~57~ & & \verb~                case Keys.U: return KeyboardKey.U;~\\
\cellcolor{red} & 0 & \verb~58~ & & \verb~                case Keys.V: return KeyboardKey.V;~\\
\cellcolor{red} & 0 & \verb~59~ & & \verb~                case Keys.W: return KeyboardKey.W;~\\
\cellcolor{red} & 0 & \verb~60~ & & \verb~                case Keys.X: return KeyboardKey.X;~\\
\cellcolor{red} & 0 & \verb~61~ & & \verb~                case Keys.Y: return KeyboardKey.Y;~\\
\cellcolor{red} & 0 & \verb~62~ & & \verb~                case Keys.Z: return KeyboardKey.Z;~\\
\cellcolor{gray} &  & \verb~63~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~64~ & & \verb~                case Keys.LeftBracket: return KeyboardKey.Danish_AA;~\\
\cellcolor{red} & 0 & \verb~65~ & & \verb~                case Keys.Backslash: return KeyboardKey.Apostrophe;~\\
\cellcolor{red} & 0 & \verb~66~ & & \verb~                case Keys.RightBracket: return KeyboardKey.Diaresis;~\\
\cellcolor{red} & 0 & \verb~67~ & & \verb~                case Keys.GraveAccent: return KeyboardKey.FractionOneHalf;~\\
\cellcolor{red} & 0 & \verb~68~ & & \verb~                case Keys.Escape: return KeyboardKey.Escape;~\\
\cellcolor{red} & 0 & \verb~69~ & & \verb~                case Keys.Enter: return KeyboardKey.Enter;~\\
\cellcolor{red} & 0 & \verb~70~ & & \verb~                case Keys.Tab: return KeyboardKey.Tab;~\\
\cellcolor{red} & 0 & \verb~71~ & & \verb~                case Keys.Backspace: return KeyboardKey.Backspace;~\\
\cellcolor{red} & 0 & \verb~72~ & & \verb~                case Keys.Insert: return KeyboardKey.Insert;~\\
\cellcolor{red} & 0 & \verb~73~ & & \verb~                case Keys.Delete: return KeyboardKey.Delete;~\\
\cellcolor{gray} &  & \verb~74~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~75~ & & \verb~                case Keys.Right: return KeyboardKey.Right;~\\
\cellcolor{red} & 0 & \verb~76~ & & \verb~                case Keys.Left: return KeyboardKey.Left;~\\
\cellcolor{red} & 0 & \verb~77~ & & \verb~                case Keys.Down: return KeyboardKey.Down;~\\
\cellcolor{red} & 0 & \verb~78~ & & \verb~                case Keys.Up: return KeyboardKey.Up;~\\
\cellcolor{gray} &  & \verb~79~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~80~ & & \verb~                case Keys.PageUp: return KeyboardKey.PageUp;~\\
\cellcolor{red} & 0 & \verb~81~ & & \verb~                case Keys.PageDown: return KeyboardKey.PageDown;~\\
\cellcolor{red} & 0 & \verb~82~ & & \verb~                case Keys.Home: return KeyboardKey.Home;~\\
\cellcolor{red} & 0 & \verb~83~ & & \verb~                case Keys.End: return KeyboardKey.End;~\\
\cellcolor{gray} &  & \verb~84~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~85~ & & \verb~                case Keys.CapsLock: return KeyboardKey.CapsLock;~\\
\cellcolor{red} & 0 & \verb~86~ & & \verb~                case Keys.ScrollLock: return KeyboardKey.ScrollLock;~\\
\cellcolor{red} & 0 & \verb~87~ & & \verb~                case Keys.NumLock: return KeyboardKey.NumLock;~\\
\cellcolor{red} & 0 & \verb~88~ & & \verb~                case Keys.PrintScreen: return KeyboardKey.PrintScreen;~\\
\cellcolor{red} & 0 & \verb~89~ & & \verb~                case Keys.Pause: return KeyboardKey.Pause;~\\
\cellcolor{gray} &  & \verb~90~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~91~ & & \verb~                case Keys.F1: return KeyboardKey.F1;~\\
\cellcolor{red} & 0 & \verb~92~ & & \verb~                case Keys.F2: return KeyboardKey.F2;~\\
\cellcolor{red} & 0 & \verb~93~ & & \verb~                case Keys.F3: return KeyboardKey.F3;~\\
\cellcolor{red} & 0 & \verb~94~ & & \verb~                case Keys.F4: return KeyboardKey.F4;~\\
\cellcolor{red} & 0 & \verb~95~ & & \verb~                case Keys.F5: return KeyboardKey.F5;~\\
\cellcolor{red} & 0 & \verb~96~ & & \verb~                case Keys.F6: return KeyboardKey.F6;~\\
\cellcolor{red} & 0 & \verb~97~ & & \verb~                case Keys.F7: return KeyboardKey.F7;~\\
\cellcolor{red} & 0 & \verb~98~ & & \verb~                case Keys.F8: return KeyboardKey.F8;~\\
\cellcolor{red} & 0 & \verb~99~ & & \verb~                case Keys.F9: return KeyboardKey.F9;~\\
\cellcolor{red} & 0 & \verb~100~ & & \verb~                case Keys.F10: return KeyboardKey.F10;~\\
\cellcolor{red} & 0 & \verb~101~ & & \verb~                case Keys.F11: return KeyboardKey.F11;~\\
\cellcolor{red} & 0 & \verb~102~ & & \verb~                case Keys.F12: return KeyboardKey.F12;~\\
\cellcolor{red} & 0 & \verb~103~ & & \verb~                case Keys.F13: return KeyboardKey.F13;~\\
\cellcolor{red} & 0 & \verb~104~ & & \verb~                case Keys.F14: return KeyboardKey.F14;~\\
\cellcolor{red} & 0 & \verb~105~ & & \verb~                case Keys.F15: return KeyboardKey.F15;~\\
\cellcolor{red} & 0 & \verb~106~ & & \verb~                case Keys.F16: return KeyboardKey.F16;~\\
\cellcolor{red} & 0 & \verb~107~ & & \verb~                case Keys.F17: return KeyboardKey.F17;~\\
\cellcolor{red} & 0 & \verb~108~ & & \verb~                case Keys.F18: return KeyboardKey.F18;~\\
\cellcolor{red} & 0 & \verb~109~ & & \verb~                case Keys.F19: return KeyboardKey.F19;~\\
\cellcolor{red} & 0 & \verb~110~ & & \verb~                case Keys.F20: return KeyboardKey.F20;~\\
\cellcolor{red} & 0 & \verb~111~ & & \verb~                case Keys.F21: return KeyboardKey.F21;~\\
\cellcolor{red} & 0 & \verb~112~ & & \verb~                case Keys.F22: return KeyboardKey.F22;~\\
\cellcolor{red} & 0 & \verb~113~ & & \verb~                case Keys.F23: return KeyboardKey.F23;~\\
\cellcolor{red} & 0 & \verb~114~ & & \verb~                case Keys.F24: return KeyboardKey.F24;~\\
\cellcolor{red} & 0 & \verb~115~ & & \verb~                case Keys.F25: return KeyboardKey.F25;~\\
\cellcolor{gray} &  & \verb~116~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~117~ & & \verb~                case Keys.KeyPad0: return KeyboardKey.KeyPad0;~\\
\cellcolor{red} & 0 & \verb~118~ & & \verb~                case Keys.KeyPad1: return KeyboardKey.KeyPad1;~\\
\cellcolor{red} & 0 & \verb~119~ & & \verb~                case Keys.KeyPad2: return KeyboardKey.KeyPad2;~\\
\cellcolor{red} & 0 & \verb~120~ & & \verb~                case Keys.KeyPad3: return KeyboardKey.KeyPad3;~\\
\cellcolor{red} & 0 & \verb~121~ & & \verb~                case Keys.KeyPad4: return KeyboardKey.KeyPad4;~\\
\cellcolor{red} & 0 & \verb~122~ & & \verb~                case Keys.KeyPad5: return KeyboardKey.KeyPad5;~\\
\cellcolor{red} & 0 & \verb~123~ & & \verb~                case Keys.KeyPad6: return KeyboardKey.KeyPad6;~\\
\cellcolor{red} & 0 & \verb~124~ & & \verb~                case Keys.KeyPad7: return KeyboardKey.KeyPad7;~\\
\cellcolor{red} & 0 & \verb~125~ & & \verb~                case Keys.KeyPad8: return KeyboardKey.KeyPad8;~\\
\cellcolor{red} & 0 & \verb~126~ & & \verb~                case Keys.KeyPad9: return KeyboardKey.KeyPad9;~\\
\cellcolor{red} & 0 & \verb~127~ & & \verb~                case Keys.KeyPadDecimal: return KeyboardKey.KeyPadDecimal;~\\
\cellcolor{red} & 0 & \verb~128~ & & \verb~                case Keys.KeyPadDivide: return KeyboardKey.KeyPadDivide;~\\
\cellcolor{red} & 0 & \verb~129~ & & \verb~                case Keys.KeyPadMultiply: return KeyboardKey.KeyPadMultiply;~\\
\cellcolor{red} & 0 & \verb~130~ & & \verb~                case Keys.KeyPadSubtract: return KeyboardKey.KeyPadSubtract;~\\
\cellcolor{red} & 0 & \verb~131~ & & \verb~                case Keys.KeyPadAdd: return KeyboardKey.KeyPadAdd;~\\
\cellcolor{red} & 0 & \verb~132~ & & \verb~                case Keys.KeyPadEnter: return KeyboardKey.KeyPadEnter;~\\
\cellcolor{red} & 0 & \verb~133~ & & \verb~                case Keys.KeyPadEqual: return KeyboardKey.KeyPadEqual;~\\
\cellcolor{gray} &  & \verb~134~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~135~ & & \verb~                case Keys.LeftShift: return KeyboardKey.LeftShift;~\\
\cellcolor{red} & 0 & \verb~136~ & & \verb~                case Keys.LeftControl: return KeyboardKey.LeftControl;~\\
\cellcolor{red} & 0 & \verb~137~ & & \verb~                case Keys.LeftAlt: return KeyboardKey.LeftAlt;~\\
\cellcolor{red} & 0 & \verb~138~ & & \verb~                case Keys.LeftSuper: return KeyboardKey.LeftSuper;~\\
\cellcolor{red} & 0 & \verb~139~ & & \verb~                case Keys.RightShift: return KeyboardKey.RightShift;~\\
\cellcolor{red} & 0 & \verb~140~ & & \verb~                case Keys.RightControl: return KeyboardKey.RightControl;~\\
\cellcolor{red} & 0 & \verb~141~ & & \verb~                case Keys.RightAlt: return KeyboardKey.RightAlt;~\\
\cellcolor{red} & 0 & \verb~142~ & & \verb~                case Keys.RightSuper: return KeyboardKey.RightSuper;~\\
\cellcolor{red} & 0 & \verb~143~ & & \verb~                case Keys.Menu: return KeyboardKey.Menu;~\\
\cellcolor{gray} &  & \verb~144~ & & \verb~~\\
\cellcolor{gray} &  & \verb~145~ & & \verb~                default:~\\
\cellcolor{red} & 0 & \verb~146~ & & \verb~                    break;~\\
\cellcolor{gray} &  & \verb~147~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~148~ & & \verb~~\\
\cellcolor{gray} &  & \verb~149~ & & \verb~            // special case for Danish keyboard layout, since this key is not given a~\\
\cellcolor{gray} &  & \verb~150~ & & \verb~            // name by OpenTK 4.5.~\\
\cellcolor{red} & 0 & \verb~151~ & & \verb~            if ((int)key == 161) { return KeyboardKey.LessThan; }~\\
\cellcolor{red} & 0 & \verb~152~ & & \verb~            else { return KeyboardKey.Unknown; }~\\
\cellcolor{red} & 0 & \verb~153~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~154~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~155~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Math.Vec2D}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Math.Vec2D\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Math/Vec2D.cs}\end{minipage} \\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 39\\
\textbf{Coverable lines:} & 39\\
\textbf{Total lines:} & 61\\
\textbf{Line coverage:} & 0\% (0 of 39)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 0\\
\textbf{Covered methods:} & 0\\
\textbf{Total methods:} & 12\\
\textbf{Method coverage:} & 0\% (0 of 12)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{.ctor()} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Addition(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Subtraction(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Multiply(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Multiply(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Multiply(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{Dot(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{Length()} & 100\% & 1 & 0\%\\
\hline
\textbf{Copy()} & 100\% & 1 & 0\%\\
\hline
\textbf{GetHashCode()} & 100\% & 1 & 0\%\\
\hline
\textbf{ToString()} & 100\% & 1 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Math/Vec2D.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~namespace DIKUArcade.Math {~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~    public class Vec2D {~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~        public double X;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~        public double Y;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~6~ & & \verb~        public Vec2D(double x, double y) {~\\
\cellcolor{red} & 0 & \verb~7~ & & \verb~            X = x;~\\
\cellcolor{red} & 0 & \verb~8~ & & \verb~            Y = y;~\\
\cellcolor{red} & 0 & \verb~9~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~11~ & & \verb~        public Vec2D() : this(0.0f, 0.0f) { }~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~13~ & & \verb~        public static Vec2D operator +(Vec2D v1, Vec2D v2) {~\\
\cellcolor{red} & 0 & \verb~14~ & & \verb~            return new Vec2D(v1.X + v2.X, v1.Y + v2.Y);~\\
\cellcolor{red} & 0 & \verb~15~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~17~ & & \verb~        public static Vec2D operator -(Vec2D v1, Vec2D v2) {~\\
\cellcolor{red} & 0 & \verb~18~ & & \verb~            return new Vec2D(v1.X - v2.X, v1.Y - v2.Y);~\\
\cellcolor{red} & 0 & \verb~19~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~        // pairwise multiplication~\\
\cellcolor{red} & 0 & \verb~22~ & & \verb~        public static Vec2D operator *(Vec2D v1, Vec2D v2) {~\\
\cellcolor{red} & 0 & \verb~23~ & & \verb~            return new Vec2D(v1.X * v2.X, v1.Y * v2.Y);~\\
\cellcolor{red} & 0 & \verb~24~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~25~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~26~ & & \verb~        public static Vec2D operator *(Vec2D v, double s) {~\\
\cellcolor{red} & 0 & \verb~27~ & & \verb~            return new Vec2D(v.X * s, v.Y * s);~\\
\cellcolor{red} & 0 & \verb~28~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~29~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~30~ & & \verb~        public static Vec2D operator *(double s, Vec2D v) {~\\
\cellcolor{red} & 0 & \verb~31~ & & \verb~            return new Vec2D(v.X * s, v.Y * s);~\\
\cellcolor{red} & 0 & \verb~32~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~33~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~34~ & & \verb~        public static double Dot(Vec2D v1, Vec2D v2) {~\\
\cellcolor{red} & 0 & \verb~35~ & & \verb~            return v1.X * v2.X + v1.Y * v2.Y;~\\
\cellcolor{red} & 0 & \verb~36~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~37~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~38~ & & \verb~        public double Length() {~\\
\cellcolor{red} & 0 & \verb~39~ & & \verb~            return System.Math.Sqrt(X * X + Y * Y);~\\
\cellcolor{red} & 0 & \verb~40~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~41~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~42~ & & \verb~        public Vec2D Copy() {~\\
\cellcolor{red} & 0 & \verb~43~ & & \verb~            return new Vec2D(X, Y);~\\
\cellcolor{red} & 0 & \verb~44~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~45~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~46~ & & \verb~        public override int GetHashCode() {~\\
\cellcolor{gray} &  & \verb~47~ & & \verb~            // Source: http://stackoverflow.com/a/263416/5801152~\\
\cellcolor{gray} &  & \verb~48~ & & \verb~            unchecked // Overflow is fine, just wrap~\\
\cellcolor{red} & 0 & \verb~49~ & & \verb~            {~\\
\cellcolor{red} & 0 & \verb~50~ & & \verb~                var hash = 17;~\\
\cellcolor{red} & 0 & \verb~51~ & & \verb~                hash = hash * 23 + X.GetHashCode();~\\
\cellcolor{red} & 0 & \verb~52~ & & \verb~                hash = hash * 23 + Y.GetHashCode();~\\
\cellcolor{red} & 0 & \verb~53~ & & \verb~                return hash;~\\
\cellcolor{gray} &  & \verb~54~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~55~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~56~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~57~ & & \verb~        public override string ToString() {~\\
\cellcolor{red} & 0 & \verb~58~ & & \verb~            return $"Vec2D({X},{Y})";~\\
\cellcolor{red} & 0 & \verb~59~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~60~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~61~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Math.Vec2F}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Math.Vec2F\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Math/Vec2F.cs}\end{minipage} \\
\textbf{Covered lines:} & 14\\
\textbf{Uncovered lines:} & 31\\
\textbf{Coverable lines:} & 45\\
\textbf{Total lines:} & 70\\
\textbf{Line coverage:} & 31.1\% (14 of 45)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 0\\
\textbf{Covered methods:} & 5\\
\textbf{Total methods:} & 14\\
\textbf{Method coverage:} & 35.7\% (5 of 14)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 100\%\\
\hline
\textbf{.ctor()} & 100\% & 1 & 100\%\\
\hline
\textbf{op\_Addition(...)} & 100\% & 1 & 100\%\\
\hline
\textbf{op\_Subtraction(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Multiply(...)} & 100\% & 1 & 100\%\\
\hline
\textbf{op\_Multiply(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Multiply(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Division(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{Dot(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{Length()} & 100\% & 1 & 0\%\\
\hline
\textbf{Normalize(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{Copy()} & 100\% & 1 & 0\%\\
\hline
\textbf{GetHashCode()} & 100\% & 1 & 0\%\\
\hline
\textbf{ToString()} & 100\% & 1 & 100\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Math/Vec2F.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~namespace DIKUArcade.Math {~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~    public class Vec2F {~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~        public float X;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~        public float Y;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~~\\
\cellcolor{green} & 18300 & \verb~6~ & & \verb~        public Vec2F(float x, float y) {~\\
\cellcolor{green} & 9150 & \verb~7~ & & \verb~            X = x;~\\
\cellcolor{green} & 9150 & \verb~8~ & & \verb~            Y = y;~\\
\cellcolor{green} & 9150 & \verb~9~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~~\\
\cellcolor{green} & 12 & \verb~11~ & & \verb~        public Vec2F() : this(0.0f, 0.0f) { }~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~~\\
\cellcolor{green} & 1495 & \verb~13~ & & \verb~        public static Vec2F operator +(Vec2F v1, Vec2F v2) {~\\
\cellcolor{green} & 1495 & \verb~14~ & & \verb~            return new Vec2F(v1.X + v2.X, v1.Y + v2.Y);~\\
\cellcolor{green} & 1495 & \verb~15~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~17~ & & \verb~        public static Vec2F operator -(Vec2F v1, Vec2F v2) {~\\
\cellcolor{red} & 0 & \verb~18~ & & \verb~            return new Vec2F(v1.X - v2.X, v1.Y - v2.Y);~\\
\cellcolor{red} & 0 & \verb~19~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~        // pairwise multiplication~\\
\cellcolor{green} & 732 & \verb~22~ & & \verb~        public static Vec2F operator *(Vec2F v1, Vec2F v2) {~\\
\cellcolor{green} & 732 & \verb~23~ & & \verb~            return new Vec2F(v1.X * v2.X, v1.Y * v2.Y);~\\
\cellcolor{green} & 732 & \verb~24~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~25~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~26~ & & \verb~        public static Vec2F operator *(Vec2F v, float s) {~\\
\cellcolor{red} & 0 & \verb~27~ & & \verb~            return new Vec2F(v.X * s, v.Y * s);~\\
\cellcolor{red} & 0 & \verb~28~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~29~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~30~ & & \verb~        public static Vec2F operator *(float s, Vec2F v) {~\\
\cellcolor{red} & 0 & \verb~31~ & & \verb~            return new Vec2F(v.X * s, v.Y * s);~\\
\cellcolor{red} & 0 & \verb~32~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~33~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~34~ & & \verb~        public static Vec2F operator /(Vec2F v, float s) {~\\
\cellcolor{red} & 0 & \verb~35~ & & \verb~            return new Vec2F(v.X / s, v.Y / s);~\\
\cellcolor{red} & 0 & \verb~36~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~37~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~38~ & & \verb~        public static float Dot(Vec2F v1, Vec2F v2) {~\\
\cellcolor{red} & 0 & \verb~39~ & & \verb~            return v1.X * v2.X + v1.Y * v2.Y;~\\
\cellcolor{red} & 0 & \verb~40~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~41~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~42~ & & \verb~        public double Length() {~\\
\cellcolor{red} & 0 & \verb~43~ & & \verb~            return System.Math.Sqrt(X * X + Y * Y);~\\
\cellcolor{red} & 0 & \verb~44~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~45~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~46~ & & \verb~        public static Vec2F Normalize(Vec2F v) {~\\
\cellcolor{red} & 0 & \verb~47~ & & \verb~            return v.Copy() * (1.0f / (float)v.Length());~\\
\cellcolor{red} & 0 & \verb~48~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~49~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~50~ & & \verb~        public Vec2F Copy() {~\\
\cellcolor{red} & 0 & \verb~51~ & & \verb~            return new Vec2F(X, Y);~\\
\cellcolor{red} & 0 & \verb~52~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~53~ & & \verb~~\\
\cellcolor{gray} &  & \verb~54~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~55~ & & \verb~        public override int GetHashCode() {~\\
\cellcolor{gray} &  & \verb~56~ & & \verb~            // Source: http://stackoverflow.com/a/263416/5801152~\\
\cellcolor{gray} &  & \verb~57~ & & \verb~            unchecked // Overflow is fine, just wrap~\\
\cellcolor{red} & 0 & \verb~58~ & & \verb~            {~\\
\cellcolor{red} & 0 & \verb~59~ & & \verb~                var hash = 17;~\\
\cellcolor{red} & 0 & \verb~60~ & & \verb~                hash = hash * 23 + X.GetHashCode();~\\
\cellcolor{red} & 0 & \verb~61~ & & \verb~                hash = hash * 23 + Y.GetHashCode();~\\
\cellcolor{red} & 0 & \verb~62~ & & \verb~                return hash;~\\
\cellcolor{gray} &  & \verb~63~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~64~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~65~ & & \verb~~\\
\cellcolor{green} & 4 & \verb~66~ & & \verb~        public override string ToString() {~\\
\cellcolor{green} & 4 & \verb~67~ & & \verb~            return $"Vec2F({X},{Y})";~\\
\cellcolor{green} & 4 & \verb~68~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~69~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~70~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Math.Vec2I}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Math.Vec2I\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Math/Vec2I.cs}\end{minipage} \\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 36\\
\textbf{Coverable lines:} & 36\\
\textbf{Total lines:} & 57\\
\textbf{Line coverage:} & 0\% (0 of 36)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 0\\
\textbf{Covered methods:} & 0\\
\textbf{Total methods:} & 11\\
\textbf{Method coverage:} & 0\% (0 of 11)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{.ctor()} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Addition(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Subtraction(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Multiply(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Multiply(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Multiply(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{Dot(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{Length()} & 100\% & 1 & 0\%\\
\hline
\textbf{Copy()} & 100\% & 1 & 0\%\\
\hline
\textbf{GetHashCode()} & 100\% & 1 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Math/Vec2I.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~namespace DIKUArcade.Math {~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~    public class Vec2I {~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~        public int X;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~        public int Y;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~6~ & & \verb~        public Vec2I(int x, int y) {~\\
\cellcolor{red} & 0 & \verb~7~ & & \verb~            X = x;~\\
\cellcolor{red} & 0 & \verb~8~ & & \verb~            Y = y;~\\
\cellcolor{red} & 0 & \verb~9~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~11~ & & \verb~        public Vec2I() : this(0, 0) { }~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~13~ & & \verb~        public static Vec2I operator +(Vec2I v1, Vec2I v2) {~\\
\cellcolor{red} & 0 & \verb~14~ & & \verb~            return new Vec2I(v1.X + v2.X, v1.Y + v2.Y);~\\
\cellcolor{red} & 0 & \verb~15~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~17~ & & \verb~        public static Vec2I operator -(Vec2I v1, Vec2I v2) {~\\
\cellcolor{red} & 0 & \verb~18~ & & \verb~            return new Vec2I(v1.X - v2.X, v1.Y - v2.Y);~\\
\cellcolor{red} & 0 & \verb~19~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~        // pairwise multiplication~\\
\cellcolor{red} & 0 & \verb~22~ & & \verb~        public static Vec2I operator *(Vec2I v1, Vec2I v2) {~\\
\cellcolor{red} & 0 & \verb~23~ & & \verb~            return new Vec2I(v1.X * v2.X, v1.Y * v2.Y);~\\
\cellcolor{red} & 0 & \verb~24~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~25~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~26~ & & \verb~        public static Vec2I operator *(Vec2I v, int s) {~\\
\cellcolor{red} & 0 & \verb~27~ & & \verb~            return new Vec2I(v.X * s, v.Y * s);~\\
\cellcolor{red} & 0 & \verb~28~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~29~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~30~ & & \verb~        public static Vec2I operator *(int s, Vec2I v) {~\\
\cellcolor{red} & 0 & \verb~31~ & & \verb~            return new Vec2I(v.X * s, v.Y * s);~\\
\cellcolor{red} & 0 & \verb~32~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~33~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~34~ & & \verb~        public static int Dot(Vec2I v1, Vec2I v2) {~\\
\cellcolor{red} & 0 & \verb~35~ & & \verb~            return v1.X * v2.X + v1.Y * v2.Y;~\\
\cellcolor{red} & 0 & \verb~36~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~37~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~38~ & & \verb~        public double Length() {~\\
\cellcolor{red} & 0 & \verb~39~ & & \verb~            return System.Math.Sqrt(X * X + Y * Y);~\\
\cellcolor{red} & 0 & \verb~40~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~41~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~42~ & & \verb~        public Vec2I Copy() {~\\
\cellcolor{red} & 0 & \verb~43~ & & \verb~            return new Vec2I(X, Y);~\\
\cellcolor{red} & 0 & \verb~44~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~45~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~46~ & & \verb~        public override int GetHashCode() {~\\
\cellcolor{gray} &  & \verb~47~ & & \verb~            // Source: http://stackoverflow.com/a/263416/5801152~\\
\cellcolor{gray} &  & \verb~48~ & & \verb~            unchecked // Overflow is fine, just wrap~\\
\cellcolor{red} & 0 & \verb~49~ & & \verb~            {~\\
\cellcolor{red} & 0 & \verb~50~ & & \verb~                var hash = 17;~\\
\cellcolor{red} & 0 & \verb~51~ & & \verb~                hash = hash * 23 + X.GetHashCode();~\\
\cellcolor{red} & 0 & \verb~52~ & & \verb~                hash = hash * 23 + Y.GetHashCode();~\\
\cellcolor{red} & 0 & \verb~53~ & & \verb~                return hash;~\\
\cellcolor{gray} &  & \verb~54~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~55~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~56~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~57~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Math.Vec3D}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Math.Vec3D\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Math/Vec3D.cs}\end{minipage} \\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 38\\
\textbf{Coverable lines:} & 38\\
\textbf{Total lines:} & 60\\
\textbf{Line coverage:} & 0\% (0 of 38)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 0\\
\textbf{Covered methods:} & 0\\
\textbf{Total methods:} & 11\\
\textbf{Method coverage:} & 0\% (0 of 11)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{.ctor()} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Addition(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Subtraction(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Multiply(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Multiply(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Multiply(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{Dot(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{Length()} & 100\% & 1 & 0\%\\
\hline
\textbf{Copy()} & 100\% & 1 & 0\%\\
\hline
\textbf{GetHashCode()} & 100\% & 1 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Math/Vec3D.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~namespace DIKUArcade.Math {~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~    public class Vec3D {~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~        public double X;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~        public double Y;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~        public double Z;~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~7~ & & \verb~        public Vec3D(double x, double y, double z) {~\\
\cellcolor{red} & 0 & \verb~8~ & & \verb~            X = x;~\\
\cellcolor{red} & 0 & \verb~9~ & & \verb~            Y = y;~\\
\cellcolor{red} & 0 & \verb~10~ & & \verb~            Z = z;~\\
\cellcolor{red} & 0 & \verb~11~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~13~ & & \verb~        public Vec3D() : this(0.0f, 0.0f, 0.0f) { }~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~15~ & & \verb~        public static Vec3D operator +(Vec3D v1, Vec3D v2) {~\\
\cellcolor{red} & 0 & \verb~16~ & & \verb~            return new Vec3D(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);~\\
\cellcolor{red} & 0 & \verb~17~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~19~ & & \verb~        public static Vec3D operator -(Vec3D v1, Vec3D v2) {~\\
\cellcolor{red} & 0 & \verb~20~ & & \verb~            return new Vec3D(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);~\\
\cellcolor{red} & 0 & \verb~21~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~        // pairwise multiplication~\\
\cellcolor{red} & 0 & \verb~24~ & & \verb~        public static Vec3D operator *(Vec3D v1, Vec3D v2) {~\\
\cellcolor{red} & 0 & \verb~25~ & & \verb~            return new Vec3D(v1.X * v2.X, v1.Y * v2.Y, v1.Z * v2.Z);~\\
\cellcolor{red} & 0 & \verb~26~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~28~ & & \verb~        public static Vec3D operator *(Vec3D v, double s) {~\\
\cellcolor{red} & 0 & \verb~29~ & & \verb~            return new Vec3D(v.X * s, v.Y * s, v.Z * s);~\\
\cellcolor{red} & 0 & \verb~30~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~31~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~32~ & & \verb~        public static Vec3D operator *(double s, Vec3D v) {~\\
\cellcolor{red} & 0 & \verb~33~ & & \verb~            return new Vec3D(v.X * s, v.Y * s, v.Z * s);~\\
\cellcolor{red} & 0 & \verb~34~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~35~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~36~ & & \verb~        public static double Dot(Vec3D v1, Vec3D v2) {~\\
\cellcolor{red} & 0 & \verb~37~ & & \verb~            return v1.X * v2.X + v1.Y * v2.Y + v1.Z * v2.Z;~\\
\cellcolor{red} & 0 & \verb~38~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~39~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~40~ & & \verb~        public double Length() {~\\
\cellcolor{red} & 0 & \verb~41~ & & \verb~            return System.Math.Sqrt(X * X + Y * Y + Z * Z);~\\
\cellcolor{red} & 0 & \verb~42~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~43~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~44~ & & \verb~        public Vec3D Copy() {~\\
\cellcolor{red} & 0 & \verb~45~ & & \verb~            return new Vec3D(X, Y, Z);~\\
\cellcolor{red} & 0 & \verb~46~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~47~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~48~ & & \verb~        public override int GetHashCode() {~\\
\cellcolor{gray} &  & \verb~49~ & & \verb~            // Source: http://stackoverflow.com/a/263416/5801152~\\
\cellcolor{gray} &  & \verb~50~ & & \verb~            unchecked // Overflow is fine, just wrap~\\
\cellcolor{red} & 0 & \verb~51~ & & \verb~            {~\\
\cellcolor{red} & 0 & \verb~52~ & & \verb~                var hash = 17;~\\
\cellcolor{red} & 0 & \verb~53~ & & \verb~                hash = hash * 23 + X.GetHashCode();~\\
\cellcolor{red} & 0 & \verb~54~ & & \verb~                hash = hash * 23 + Y.GetHashCode();~\\
\cellcolor{red} & 0 & \verb~55~ & & \verb~                hash = hash * 23 + Z.GetHashCode();~\\
\cellcolor{red} & 0 & \verb~56~ & & \verb~                return hash;~\\
\cellcolor{gray} &  & \verb~57~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~58~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~59~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~60~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Math.Vec3F}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Math.Vec3F\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Math/Vec3F.cs}\end{minipage} \\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 38\\
\textbf{Coverable lines:} & 38\\
\textbf{Total lines:} & 60\\
\textbf{Line coverage:} & 0\% (0 of 38)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 0\\
\textbf{Covered methods:} & 0\\
\textbf{Total methods:} & 11\\
\textbf{Method coverage:} & 0\% (0 of 11)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{.ctor()} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Addition(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Subtraction(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Multiply(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Multiply(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Multiply(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{Dot(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{Length()} & 100\% & 1 & 0\%\\
\hline
\textbf{Copy()} & 100\% & 1 & 0\%\\
\hline
\textbf{GetHashCode()} & 100\% & 1 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Math/Vec3F.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~namespace DIKUArcade.Math {~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~    public class Vec3F {~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~        public float X;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~        public float Y;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~        public float Z;~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~7~ & & \verb~        public Vec3F(float x, float y, float z) {~\\
\cellcolor{red} & 0 & \verb~8~ & & \verb~            X = x;~\\
\cellcolor{red} & 0 & \verb~9~ & & \verb~            Y = y;~\\
\cellcolor{red} & 0 & \verb~10~ & & \verb~            Z = z;~\\
\cellcolor{red} & 0 & \verb~11~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~13~ & & \verb~        public Vec3F() : this(0.0f, 0.0f, 0.0f) { }~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~15~ & & \verb~        public static Vec3F operator +(Vec3F v1, Vec3F v2) {~\\
\cellcolor{red} & 0 & \verb~16~ & & \verb~            return new Vec3F(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);~\\
\cellcolor{red} & 0 & \verb~17~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~19~ & & \verb~        public static Vec3F operator -(Vec3F v1, Vec3F v2) {~\\
\cellcolor{red} & 0 & \verb~20~ & & \verb~            return new Vec3F(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);~\\
\cellcolor{red} & 0 & \verb~21~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~        // pairwise multiplication~\\
\cellcolor{red} & 0 & \verb~24~ & & \verb~        public static Vec3F operator *(Vec3F v1, Vec3F v2) {~\\
\cellcolor{red} & 0 & \verb~25~ & & \verb~            return new Vec3F(v1.X * v2.X, v1.Y * v2.Y, v1.Z * v2.Z);~\\
\cellcolor{red} & 0 & \verb~26~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~28~ & & \verb~        public static Vec3F operator *(Vec3F v, float s) {~\\
\cellcolor{red} & 0 & \verb~29~ & & \verb~            return new Vec3F(v.X * s, v.Y * s, v.Z * s);~\\
\cellcolor{red} & 0 & \verb~30~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~31~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~32~ & & \verb~        public static Vec3F operator *(float s, Vec3F v) {~\\
\cellcolor{red} & 0 & \verb~33~ & & \verb~            return new Vec3F(v.X * s, v.Y * s, v.Z * s);~\\
\cellcolor{red} & 0 & \verb~34~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~35~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~36~ & & \verb~        public static float Dot(Vec3F v1, Vec3F v2) {~\\
\cellcolor{red} & 0 & \verb~37~ & & \verb~            return v1.X * v2.X + v1.Y * v2.Y + v1.Z * v2.Z;~\\
\cellcolor{red} & 0 & \verb~38~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~39~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~40~ & & \verb~        public double Length() {~\\
\cellcolor{red} & 0 & \verb~41~ & & \verb~            return System.Math.Sqrt(X * X + Y * Y + Z * Z);~\\
\cellcolor{red} & 0 & \verb~42~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~43~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~44~ & & \verb~        public Vec3F Copy() {~\\
\cellcolor{red} & 0 & \verb~45~ & & \verb~            return new Vec3F(X, Y, Z);~\\
\cellcolor{red} & 0 & \verb~46~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~47~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~48~ & & \verb~        public override int GetHashCode() {~\\
\cellcolor{gray} &  & \verb~49~ & & \verb~            // Source: http://stackoverflow.com/a/263416/5801152~\\
\cellcolor{gray} &  & \verb~50~ & & \verb~            unchecked // Overflow is fine, just wrap~\\
\cellcolor{red} & 0 & \verb~51~ & & \verb~            {~\\
\cellcolor{red} & 0 & \verb~52~ & & \verb~                var hash = 17;~\\
\cellcolor{red} & 0 & \verb~53~ & & \verb~                hash = hash * 23 + X.GetHashCode();~\\
\cellcolor{red} & 0 & \verb~54~ & & \verb~                hash = hash * 23 + Y.GetHashCode();~\\
\cellcolor{red} & 0 & \verb~55~ & & \verb~                hash = hash * 23 + Z.GetHashCode();~\\
\cellcolor{red} & 0 & \verb~56~ & & \verb~                return hash;~\\
\cellcolor{gray} &  & \verb~57~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~58~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~59~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~60~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Math.Vec3I}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Math.Vec3I\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Math/Vec3I.cs}\end{minipage} \\
\textbf{Covered lines:} & 5\\
\textbf{Uncovered lines:} & 33\\
\textbf{Coverable lines:} & 38\\
\textbf{Total lines:} & 60\\
\textbf{Line coverage:} & 13.1\% (5 of 38)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 0\\
\textbf{Covered methods:} & 1\\
\textbf{Total methods:} & 11\\
\textbf{Method coverage:} & 9\% (1 of 11)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 100\%\\
\hline
\textbf{.ctor()} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Addition(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Subtraction(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Multiply(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Multiply(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Multiply(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{Dot(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{Length()} & 100\% & 1 & 0\%\\
\hline
\textbf{Copy()} & 100\% & 1 & 0\%\\
\hline
\textbf{GetHashCode()} & 100\% & 1 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Math/Vec3I.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~namespace DIKUArcade.Math {~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~    public class Vec3I {~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~        public int X;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~        public int Y;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~        public int Z;~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~~\\
\cellcolor{green} & 314 & \verb~7~ & & \verb~        public Vec3I(int x, int y, int z) {~\\
\cellcolor{green} & 157 & \verb~8~ & & \verb~            X = x;~\\
\cellcolor{green} & 157 & \verb~9~ & & \verb~            Y = y;~\\
\cellcolor{green} & 157 & \verb~10~ & & \verb~            Z = z;~\\
\cellcolor{green} & 157 & \verb~11~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~13~ & & \verb~        public Vec3I() : this(0, 0, 0) { }~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~15~ & & \verb~        public static Vec3I operator +(Vec3I v1, Vec3I v2) {~\\
\cellcolor{red} & 0 & \verb~16~ & & \verb~            return new Vec3I(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);~\\
\cellcolor{red} & 0 & \verb~17~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~19~ & & \verb~        public static Vec3I operator -(Vec3I v1, Vec3I v2) {~\\
\cellcolor{red} & 0 & \verb~20~ & & \verb~            return new Vec3I(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);~\\
\cellcolor{red} & 0 & \verb~21~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~        // pairwise multiplication~\\
\cellcolor{red} & 0 & \verb~24~ & & \verb~        public static Vec3I operator *(Vec3I v1, Vec3I v2) {~\\
\cellcolor{red} & 0 & \verb~25~ & & \verb~            return new Vec3I(v1.X * v2.X, v1.Y * v2.Y, v1.Z * v2.Z);~\\
\cellcolor{red} & 0 & \verb~26~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~28~ & & \verb~        public static Vec3I operator *(Vec3I v, int s) {~\\
\cellcolor{red} & 0 & \verb~29~ & & \verb~            return new Vec3I(v.X * s, v.Y * s, v.Z * s);~\\
\cellcolor{red} & 0 & \verb~30~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~31~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~32~ & & \verb~        public static Vec3I operator *(int s, Vec3I v) {~\\
\cellcolor{red} & 0 & \verb~33~ & & \verb~            return new Vec3I(v.X * s, v.Y * s, v.Z * s);~\\
\cellcolor{red} & 0 & \verb~34~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~35~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~36~ & & \verb~        public static int Dot(Vec3I v1, Vec3I v2) {~\\
\cellcolor{red} & 0 & \verb~37~ & & \verb~            return v1.X * v2.X + v1.Y * v2.Y + v1.Z * v2.Z;~\\
\cellcolor{red} & 0 & \verb~38~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~39~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~40~ & & \verb~        public double Length() {~\\
\cellcolor{red} & 0 & \verb~41~ & & \verb~            return System.Math.Sqrt(X * X + Y * Y + Z * Z);~\\
\cellcolor{red} & 0 & \verb~42~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~43~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~44~ & & \verb~        public Vec3I Copy() {~\\
\cellcolor{red} & 0 & \verb~45~ & & \verb~            return new Vec3I(X, Y, Z);~\\
\cellcolor{red} & 0 & \verb~46~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~47~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~48~ & & \verb~        public override int GetHashCode() {~\\
\cellcolor{gray} &  & \verb~49~ & & \verb~            // Source: http://stackoverflow.com/a/263416/5801152~\\
\cellcolor{gray} &  & \verb~50~ & & \verb~            unchecked // Overflow is fine, just wrap~\\
\cellcolor{red} & 0 & \verb~51~ & & \verb~            {~\\
\cellcolor{red} & 0 & \verb~52~ & & \verb~                var hash = 17;~\\
\cellcolor{red} & 0 & \verb~53~ & & \verb~                hash = hash * 23 + X.GetHashCode();~\\
\cellcolor{red} & 0 & \verb~54~ & & \verb~                hash = hash * 23 + Y.GetHashCode();~\\
\cellcolor{red} & 0 & \verb~55~ & & \verb~                hash = hash * 23 + Z.GetHashCode();~\\
\cellcolor{red} & 0 & \verb~56~ & & \verb~                return hash;~\\
\cellcolor{gray} &  & \verb~57~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~58~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~59~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~60~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Math.Vec4D}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Math.Vec4D\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Math/Vec4D.cs}\end{minipage} \\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 40\\
\textbf{Coverable lines:} & 40\\
\textbf{Total lines:} & 63\\
\textbf{Line coverage:} & 0\% (0 of 40)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 0\\
\textbf{Covered methods:} & 0\\
\textbf{Total methods:} & 11\\
\textbf{Method coverage:} & 0\% (0 of 11)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{.ctor()} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Addition(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Subtraction(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Multiply(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Multiply(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Multiply(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{Dot(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{Length()} & 100\% & 1 & 0\%\\
\hline
\textbf{Copy()} & 100\% & 1 & 0\%\\
\hline
\textbf{GetHashCode()} & 100\% & 1 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Math/Vec4D.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~namespace DIKUArcade.Math {~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~    public class Vec4D {~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~        public double W;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~        public double X;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~        public double Y;~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~        public double Z;~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~8~ & & \verb~        public Vec4D(double x, double y, double z, double w) {~\\
\cellcolor{red} & 0 & \verb~9~ & & \verb~            X = x;~\\
\cellcolor{red} & 0 & \verb~10~ & & \verb~            Y = y;~\\
\cellcolor{red} & 0 & \verb~11~ & & \verb~            Z = z;~\\
\cellcolor{red} & 0 & \verb~12~ & & \verb~            W = w;~\\
\cellcolor{red} & 0 & \verb~13~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~15~ & & \verb~        public Vec4D() : this(0.0f, 0.0f, 0.0f, 0.0f) { }~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~17~ & & \verb~        public static Vec4D operator +(Vec4D v1, Vec4D v2) {~\\
\cellcolor{red} & 0 & \verb~18~ & & \verb~            return new Vec4D(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z, v1.W + v2.W);~\\
\cellcolor{red} & 0 & \verb~19~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~21~ & & \verb~        public static Vec4D operator -(Vec4D v1, Vec4D v2) {~\\
\cellcolor{red} & 0 & \verb~22~ & & \verb~            return new Vec4D(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z, v1.W - v2.W);~\\
\cellcolor{red} & 0 & \verb~23~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~24~ & & \verb~~\\
\cellcolor{gray} &  & \verb~25~ & & \verb~        // pairwise multiplication~\\
\cellcolor{red} & 0 & \verb~26~ & & \verb~        public static Vec4D operator *(Vec4D v1, Vec4D v2) {~\\
\cellcolor{red} & 0 & \verb~27~ & & \verb~            return new Vec4D(v1.X * v2.X, v1.Y * v2.Y, v1.Z * v2.Z, v1.W * v2.W);~\\
\cellcolor{red} & 0 & \verb~28~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~29~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~30~ & & \verb~        public static Vec4D operator *(Vec4D v, double s) {~\\
\cellcolor{red} & 0 & \verb~31~ & & \verb~            return new Vec4D(v.X * s, v.Y * s, v.Z * s, v.W * s);~\\
\cellcolor{red} & 0 & \verb~32~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~33~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~34~ & & \verb~        public static Vec4D operator *(double s, Vec4D v) {~\\
\cellcolor{red} & 0 & \verb~35~ & & \verb~            return new Vec4D(v.X * s, v.Y * s, v.Z * s, v.W * s);~\\
\cellcolor{red} & 0 & \verb~36~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~37~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~38~ & & \verb~        public static double Dot(Vec4D v1, Vec4D v2) {~\\
\cellcolor{red} & 0 & \verb~39~ & & \verb~            return v1.X * v2.X + v1.Y * v2.Y + v1.Z * v2.Z + v1.W * v2.W;~\\
\cellcolor{red} & 0 & \verb~40~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~41~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~42~ & & \verb~        public double Length() {~\\
\cellcolor{red} & 0 & \verb~43~ & & \verb~            return System.Math.Sqrt(X * X + Y * Y + Z * Z + W * W);~\\
\cellcolor{red} & 0 & \verb~44~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~45~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~46~ & & \verb~        public Vec4D Copy() {~\\
\cellcolor{red} & 0 & \verb~47~ & & \verb~            return new Vec4D(X, Y, Z, W);~\\
\cellcolor{red} & 0 & \verb~48~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~49~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~50~ & & \verb~        public override int GetHashCode() {~\\
\cellcolor{gray} &  & \verb~51~ & & \verb~            // Source: http://stackoverflow.com/a/263416/5801152~\\
\cellcolor{gray} &  & \verb~52~ & & \verb~            unchecked // Overflow is fine, just wrap~\\
\cellcolor{red} & 0 & \verb~53~ & & \verb~            {~\\
\cellcolor{red} & 0 & \verb~54~ & & \verb~                var hash = 17;~\\
\cellcolor{red} & 0 & \verb~55~ & & \verb~                hash = hash * 23 + X.GetHashCode();~\\
\cellcolor{red} & 0 & \verb~56~ & & \verb~                hash = hash * 23 + Y.GetHashCode();~\\
\cellcolor{red} & 0 & \verb~57~ & & \verb~                hash = hash * 23 + Z.GetHashCode();~\\
\cellcolor{red} & 0 & \verb~58~ & & \verb~                hash = hash * 23 + W.GetHashCode();~\\
\cellcolor{red} & 0 & \verb~59~ & & \verb~                return hash;~\\
\cellcolor{gray} &  & \verb~60~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~61~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~62~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~63~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Math.Vec4F}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Math.Vec4F\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Math/Vec4F.cs}\end{minipage} \\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 40\\
\textbf{Coverable lines:} & 40\\
\textbf{Total lines:} & 63\\
\textbf{Line coverage:} & 0\% (0 of 40)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 0\\
\textbf{Covered methods:} & 0\\
\textbf{Total methods:} & 11\\
\textbf{Method coverage:} & 0\% (0 of 11)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{.ctor()} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Addition(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Subtraction(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Multiply(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Multiply(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Multiply(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{Dot(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{Length()} & 100\% & 1 & 0\%\\
\hline
\textbf{Copy()} & 100\% & 1 & 0\%\\
\hline
\textbf{GetHashCode()} & 100\% & 1 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Math/Vec4F.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~namespace DIKUArcade.Math {~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~    public class Vec4F {~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~        public float W;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~        public float X;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~        public float Y;~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~        public float Z;~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~8~ & & \verb~        public Vec4F(float x, float y, float z, float w) {~\\
\cellcolor{red} & 0 & \verb~9~ & & \verb~            X = x;~\\
\cellcolor{red} & 0 & \verb~10~ & & \verb~            Y = y;~\\
\cellcolor{red} & 0 & \verb~11~ & & \verb~            Z = z;~\\
\cellcolor{red} & 0 & \verb~12~ & & \verb~            W = w;~\\
\cellcolor{red} & 0 & \verb~13~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~15~ & & \verb~        public Vec4F() : this(0.0f, 0.0f, 0.0f, 0.0f) { }~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~17~ & & \verb~        public static Vec4F operator +(Vec4F v1, Vec4F v2) {~\\
\cellcolor{red} & 0 & \verb~18~ & & \verb~            return new Vec4F(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z, v1.W + v2.W);~\\
\cellcolor{red} & 0 & \verb~19~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~21~ & & \verb~        public static Vec4F operator -(Vec4F v1, Vec4F v2) {~\\
\cellcolor{red} & 0 & \verb~22~ & & \verb~            return new Vec4F(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z, v1.W - v2.W);~\\
\cellcolor{red} & 0 & \verb~23~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~24~ & & \verb~~\\
\cellcolor{gray} &  & \verb~25~ & & \verb~        // pairwise multiplication~\\
\cellcolor{red} & 0 & \verb~26~ & & \verb~        public static Vec4F operator *(Vec4F v1, Vec4F v2) {~\\
\cellcolor{red} & 0 & \verb~27~ & & \verb~            return new Vec4F(v1.X * v2.X, v1.Y * v2.Y, v1.Z * v2.Z, v1.W * v2.W);~\\
\cellcolor{red} & 0 & \verb~28~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~29~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~30~ & & \verb~        public static Vec4F operator *(Vec4F v, float s) {~\\
\cellcolor{red} & 0 & \verb~31~ & & \verb~            return new Vec4F(v.X * s, v.Y * s, v.Z * s, v.W * s);~\\
\cellcolor{red} & 0 & \verb~32~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~33~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~34~ & & \verb~        public static Vec4F operator *(float s, Vec4F v) {~\\
\cellcolor{red} & 0 & \verb~35~ & & \verb~            return new Vec4F(v.X * s, v.Y * s, v.Z * s, v.W * s);~\\
\cellcolor{red} & 0 & \verb~36~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~37~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~38~ & & \verb~        public static float Dot(Vec4F v1, Vec4F v2) {~\\
\cellcolor{red} & 0 & \verb~39~ & & \verb~            return v1.X * v2.X + v1.Y * v2.Y + v1.Z * v2.Z + v1.W * v2.W;~\\
\cellcolor{red} & 0 & \verb~40~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~41~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~42~ & & \verb~        public double Length() {~\\
\cellcolor{red} & 0 & \verb~43~ & & \verb~            return System.Math.Sqrt(X * X + Y * Y + Z * Z + W * W);~\\
\cellcolor{red} & 0 & \verb~44~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~45~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~46~ & & \verb~        public Vec4F Copy() {~\\
\cellcolor{red} & 0 & \verb~47~ & & \verb~            return new Vec4F(X, Y, Z, W);~\\
\cellcolor{red} & 0 & \verb~48~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~49~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~50~ & & \verb~        public override int GetHashCode() {~\\
\cellcolor{gray} &  & \verb~51~ & & \verb~            // Source: http://stackoverflow.com/a/263416/5801152~\\
\cellcolor{gray} &  & \verb~52~ & & \verb~            unchecked // Overflow is fine, just wrap~\\
\cellcolor{red} & 0 & \verb~53~ & & \verb~            {~\\
\cellcolor{red} & 0 & \verb~54~ & & \verb~                var hash = 17;~\\
\cellcolor{red} & 0 & \verb~55~ & & \verb~                hash = hash * 23 + X.GetHashCode();~\\
\cellcolor{red} & 0 & \verb~56~ & & \verb~                hash = hash * 23 + Y.GetHashCode();~\\
\cellcolor{red} & 0 & \verb~57~ & & \verb~                hash = hash * 23 + Z.GetHashCode();~\\
\cellcolor{red} & 0 & \verb~58~ & & \verb~                hash = hash * 23 + W.GetHashCode();~\\
\cellcolor{red} & 0 & \verb~59~ & & \verb~                return hash;~\\
\cellcolor{gray} &  & \verb~60~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~61~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~62~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~63~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Math.Vec4I}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Math.Vec4I\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Math/Vec4I.cs}\end{minipage} \\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 40\\
\textbf{Coverable lines:} & 40\\
\textbf{Total lines:} & 63\\
\textbf{Line coverage:} & 0\% (0 of 40)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 0\\
\textbf{Covered methods:} & 0\\
\textbf{Total methods:} & 11\\
\textbf{Method coverage:} & 0\% (0 of 11)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{.ctor()} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Addition(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Subtraction(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Multiply(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Multiply(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{op\_Multiply(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{Dot(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{Length()} & 100\% & 1 & 0\%\\
\hline
\textbf{Copy()} & 100\% & 1 & 0\%\\
\hline
\textbf{GetHashCode()} & 100\% & 1 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Math/Vec4I.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~namespace DIKUArcade.Math {~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~    public class Vec4I {~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~        public int W;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~        public int X;~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~        public int Y;~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~        public int Z;~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~8~ & & \verb~        public Vec4I(int x, int y, int z, int w) {~\\
\cellcolor{red} & 0 & \verb~9~ & & \verb~            X = x;~\\
\cellcolor{red} & 0 & \verb~10~ & & \verb~            Y = y;~\\
\cellcolor{red} & 0 & \verb~11~ & & \verb~            Z = z;~\\
\cellcolor{red} & 0 & \verb~12~ & & \verb~            W = w;~\\
\cellcolor{red} & 0 & \verb~13~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~15~ & & \verb~        public Vec4I() : this(0, 0, 0, 0) { }~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~17~ & & \verb~        public static Vec4I operator +(Vec4I v1, Vec4I v2) {~\\
\cellcolor{red} & 0 & \verb~18~ & & \verb~            return new Vec4I(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z, v1.W + v2.W);~\\
\cellcolor{red} & 0 & \verb~19~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~21~ & & \verb~        public static Vec4I operator -(Vec4I v1, Vec4I v2) {~\\
\cellcolor{red} & 0 & \verb~22~ & & \verb~            return new Vec4I(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z, v1.W - v2.W);~\\
\cellcolor{red} & 0 & \verb~23~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~24~ & & \verb~~\\
\cellcolor{gray} &  & \verb~25~ & & \verb~        // pairwise multiplication~\\
\cellcolor{red} & 0 & \verb~26~ & & \verb~        public static Vec4I operator *(Vec4I v1, Vec4I v2) {~\\
\cellcolor{red} & 0 & \verb~27~ & & \verb~            return new Vec4I(v1.X * v2.X, v1.Y * v2.Y, v1.Z * v2.Z, v1.W * v2.W);~\\
\cellcolor{red} & 0 & \verb~28~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~29~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~30~ & & \verb~        public static Vec4I operator *(Vec4I v, int s) {~\\
\cellcolor{red} & 0 & \verb~31~ & & \verb~            return new Vec4I(v.X * s, v.Y * s, v.Z * s, v.W * s);~\\
\cellcolor{red} & 0 & \verb~32~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~33~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~34~ & & \verb~        public static Vec4I operator *(int s, Vec4I v) {~\\
\cellcolor{red} & 0 & \verb~35~ & & \verb~            return new Vec4I(v.X * s, v.Y * s, v.Z * s, v.W * s);~\\
\cellcolor{red} & 0 & \verb~36~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~37~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~38~ & & \verb~        public static int Dot(Vec4I v1, Vec4I v2) {~\\
\cellcolor{red} & 0 & \verb~39~ & & \verb~            return v1.X * v2.X + v1.Y * v2.Y + v1.Z * v2.Z + v1.W * v2.W;~\\
\cellcolor{red} & 0 & \verb~40~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~41~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~42~ & & \verb~        public double Length() {~\\
\cellcolor{red} & 0 & \verb~43~ & & \verb~            return System.Math.Sqrt(X * X + Y * Y + Z * Z + W * W);~\\
\cellcolor{red} & 0 & \verb~44~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~45~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~46~ & & \verb~        public Vec4I Copy() {~\\
\cellcolor{red} & 0 & \verb~47~ & & \verb~            return new Vec4I(X, Y, Z, W);~\\
\cellcolor{red} & 0 & \verb~48~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~49~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~50~ & & \verb~        public override int GetHashCode() {~\\
\cellcolor{gray} &  & \verb~51~ & & \verb~            // Source: http://stackoverflow.com/a/263416/5801152~\\
\cellcolor{gray} &  & \verb~52~ & & \verb~            unchecked // Overflow is fine, just wrap~\\
\cellcolor{red} & 0 & \verb~53~ & & \verb~            {~\\
\cellcolor{red} & 0 & \verb~54~ & & \verb~                var hash = 17;~\\
\cellcolor{red} & 0 & \verb~55~ & & \verb~                hash = hash * 23 + X.GetHashCode();~\\
\cellcolor{red} & 0 & \verb~56~ & & \verb~                hash = hash * 23 + Y.GetHashCode();~\\
\cellcolor{red} & 0 & \verb~57~ & & \verb~                hash = hash * 23 + Z.GetHashCode();~\\
\cellcolor{red} & 0 & \verb~58~ & & \verb~                hash = hash * 23 + W.GetHashCode();~\\
\cellcolor{red} & 0 & \verb~59~ & & \verb~                return hash;~\\
\cellcolor{gray} &  & \verb~60~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~61~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~62~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~63~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Physics.CollisionData}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Physics.CollisionData\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{ome/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Physics/CollisionData.cs}\end{minipage} \\
\textbf{Covered lines:} & 3\\
\textbf{Uncovered lines:} & 0\\
\textbf{Coverable lines:} & 3\\
\textbf{Total lines:} & 23\\
\textbf{Line coverage:} & 100\% (3 of 3)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 0\\
\textbf{Covered methods:} & 3\\
\textbf{Total methods:} & 3\\
\textbf{Method coverage:} & 100\% (3 of 3)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{get\_Collision()} & 100\% & 1 & 100\%\\
\hline
\textbf{get\_DirectionFactor(} & 100\% & 1 & 100\%\\
\hline
\textbf{get\_CollisionDir()} & 100\% & 1 & 100\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{ome/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Physics/CollisionData.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using DIKUArcade.Math;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~namespace DIKUArcade.Physics {~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~    public class CollisionData {~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~        /// Indicating whether or not a collision has occured.~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 1584 & \verb~8~ & & \verb~        public bool Collision { get; set; }~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~        /// This factor should be multiplied onto the actor shape's~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~        /// direction vector to get the closest position to the~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~        /// incident object.~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 804 & \verb~15~ & & \verb~        public Vec2F DirectionFactor { get; set; }~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~~\\
\cellcolor{gray} &  & \verb~17~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~        /// The surface normal of the incident object, indicating~\\
\cellcolor{gray} &  & \verb~19~ & & \verb~        /// from which direction a collision has occured.~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 1573 & \verb~21~ & & \verb~        public CollisionDirection CollisionDir { get; set; } // might sometimes be useful!~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Physics.CollisionDetection}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Physics.CollisionDetection\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{agnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Physics/CollisionDetection.cs}\end{minipage} \\
\textbf{Covered lines:} & 80\\
\textbf{Uncovered lines:} & 31\\
\textbf{Coverable lines:} & 111\\
\textbf{Total lines:} & 184\\
\textbf{Line coverage:} & 72\% (80 of 111)\\
\textbf{Covered branches:} & 32\\
\textbf{Total branches:} & 48\\
\textbf{Branch coverage:} & 66.6\% (32 of 48)\\
\textbf{Covered methods:} & 1\\
\textbf{Total methods:} & 2\\
\textbf{Method coverage:} & 50\% (1 of 2)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{Aabb\_C(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{Aabb(...)} & 66.66\% & 48 & 73.39\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{agnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Physics/CollisionDetection.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using System;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using DIKUArcade.Entities;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~using DIKUArcade.Math;~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~namespace DIKUArcade.Physics {~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~    // https://learnopengl.com/In-Practice/2D-Game/Collisions/Collision-detection~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~    // Potentially allow for AABB with circles.~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~    // Or use SAT.~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~    public class CollisionDetection {~\\
\cellcolor{red} & 0 & \verb~11~ & & \verb~        public static CollisionData Aabb_C(DynamicShape actor, Shape shape) {~\\
\cellcolor{red} & 0 & \verb~12~ & & \verb~            throw new NotImplementedException("CollisionDetection.Aabb_C is not finished!");~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~            /*~\\
\cellcolor{gray} &  & \verb~15~ & & \verb~            var data = new CollisionData {~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~                Collision = false,~\\
\cellcolor{gray} &  & \verb~17~ & & \verb~                DirectionFactor = new Vec2F(1.0f, 1.0f),~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~                CollisionDir = CollisionDirection.CollisionDirUnchecked~\\
\cellcolor{gray} &  & \verb~19~ & & \verb~            };~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~            var circRadius = shape.Extent.Y/2;~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~            var circCenter = new Vec2F(shape.Position.X + shape.Extent.X/2, shape.Position.Y + shape.Extent.Y/2);~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~~\\
\cellcolor{gray} &  & \verb~24~ & & \verb~            var staLowerLeft = new Vec2F(shape.Position.X, shape.Position.Y);~\\
\cellcolor{gray} &  & \verb~25~ & & \verb~            var staUpperRight = new Vec2F(shape.Position.X + shape.Extent.X,~\\
\cellcolor{gray} &  & \verb~26~ & & \verb~                shape.Position.Y + shape.Extent.Y);~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~            var staCenter = new Vec2F(shape.Position.X + shape.Extent.X/2, shape.Position.Y + shape.Extent.Y/2);~\\
\cellcolor{gray} &  & \verb~28~ & & \verb~~\\
\cellcolor{gray} &  & \verb~29~ & & \verb~            var D = circCenter - staCenter;~\\
\cellcolor{gray} &  & \verb~30~ & & \verb~~\\
\cellcolor{gray} &  & \verb~31~ & & \verb~            // Clamp D to width/2 height/2 and add it to staCenter~\\
\cellcolor{gray} &  & \verb~32~ & & \verb~~\\
\cellcolor{gray} &  & \verb~33~ & & \verb~            return data;~\\
\cellcolor{gray} &  & \verb~34~ & & \verb~            */~\\
\cellcolor{gray} &  & \verb~35~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~36~ & & \verb~~\\
\cellcolor{green} & 785 & \verb~37~ & & \verb~        public static CollisionData Aabb(DynamicShape actor, Shape shape) {~\\
\cellcolor{green} & 785 & \verb~38~ & & \verb~            var data = new CollisionData {~\\
\cellcolor{green} & 785 & \verb~39~ & & \verb~                Collision = false,~\\
\cellcolor{green} & 785 & \verb~40~ & & \verb~                DirectionFactor = new Vec2F(1.0f, 1.0f),~\\
\cellcolor{green} & 785 & \verb~41~ & & \verb~                CollisionDir = CollisionDirection.CollisionDirUnchecked~\\
\cellcolor{green} & 785 & \verb~42~ & & \verb~            };~\\
\cellcolor{gray} &  & \verb~43~ & & \verb~~\\
\cellcolor{green} & 785 & \verb~44~ & & \verb~            var dynLowerLeft = new Vec2F(actor.Position.X, actor.Position.Y);~\\
\cellcolor{green} & 785 & \verb~45~ & & \verb~            var dynUpperRight = new Vec2F(actor.Position.X + actor.Extent.X,~\\
\cellcolor{green} & 785 & \verb~46~ & & \verb~                actor.Position.Y + actor.Extent.Y);~\\
\cellcolor{gray} &  & \verb~47~ & & \verb~~\\
\cellcolor{green} & 785 & \verb~48~ & & \verb~            var staLowerLeft = new Vec2F(shape.Position.X, shape.Position.Y);~\\
\cellcolor{green} & 785 & \verb~49~ & & \verb~            var staUpperRight = new Vec2F(shape.Position.X + shape.Extent.X,~\\
\cellcolor{green} & 785 & \verb~50~ & & \verb~                shape.Position.Y + shape.Extent.Y);~\\
\cellcolor{gray} &  & \verb~51~ & & \verb~~\\
\cellcolor{gray} &  & \verb~52~ & & \verb~            // inactive movement in both x- and y-direction~\\
\cellcolor{orange} & 785 & \verb~53~ & & \verb~            if(System.Math.Abs(actor.Direction.X) < 1e-6f && System.Math.Abs(actor.Direction.Y) < 1e-6f) {~\\
\cellcolor{red} & 0 & \verb~54~ & & \verb~                return data;~\\
\cellcolor{gray} &  & \verb~55~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~56~ & & \verb~~\\
\cellcolor{gray} &  & \verb~57~ & & \verb~            // inactive movement in x-direction~\\
\cellcolor{green} & 785 & \verb~58~ & & \verb~            else if(System.Math.Abs(actor.Direction.X) < 1e-6f)~\\
\cellcolor{green} & 777 & \verb~59~ & & \verb~            {~\\
\cellcolor{gray} &  & \verb~60~ & & \verb~                float entryDistanceY, exitDistanceY;~\\
\cellcolor{green} & 777 & \verb~61~ & & \verb~                if(actor.Direction.Y < 0.0f)~\\
\cellcolor{green} & 732 & \verb~62~ & & \verb~                {~\\
\cellcolor{green} & 732 & \verb~63~ & & \verb~                    entryDistanceY = staUpperRight.Y - dynLowerLeft.Y;~\\
\cellcolor{green} & 732 & \verb~64~ & & \verb~                    exitDistanceY = staLowerLeft.Y - dynUpperRight.Y;~\\
\cellcolor{green} & 732 & \verb~65~ & & \verb~                    data.CollisionDir = CollisionDirection.CollisionDirDown;~\\
\cellcolor{green} & 732 & \verb~66~ & & \verb~                }~\\
\cellcolor{gray} &  & \verb~67~ & & \verb~                else~\\
\cellcolor{green} & 45 & \verb~68~ & & \verb~                {~\\
\cellcolor{green} & 45 & \verb~69~ & & \verb~                    entryDistanceY = staLowerLeft.Y - dynUpperRight.Y;~\\
\cellcolor{green} & 45 & \verb~70~ & & \verb~                    exitDistanceY = staUpperRight.Y - dynLowerLeft.Y;~\\
\cellcolor{green} & 45 & \verb~71~ & & \verb~                    data.CollisionDir = CollisionDirection.CollisionDirUp;~\\
\cellcolor{green} & 45 & \verb~72~ & & \verb~                }~\\
\cellcolor{gray} &  & \verb~73~ & & \verb~~\\
\cellcolor{green} & 777 & \verb~74~ & & \verb~                var entryTimeY = entryDistanceY / actor.Direction.Y;~\\
\cellcolor{green} & 777 & \verb~75~ & & \verb~                var exitTimeY = exitDistanceY / actor.Direction.Y;~\\
\cellcolor{gray} &  & \verb~76~ & & \verb~~\\
\cellcolor{green} & 777 & \verb~77~ & & \verb~                bool xOverlaps = staUpperRight.X > dynLowerLeft.X && staLowerLeft.X < dynUpperRight.X;~\\
\cellcolor{gray} &  & \verb~78~ & & \verb~~\\
\cellcolor{green} & 777 & \verb~79~ & & \verb~                if(entryTimeY < exitTimeY && entryTimeY >= 0.0f && entryTimeY < 1.0f && xOverlaps)~\\
\cellcolor{green} & 15 & \verb~80~ & & \verb~                {~\\
\cellcolor{green} & 15 & \verb~81~ & & \verb~                    data.DirectionFactor.Y = entryTimeY;~\\
\cellcolor{green} & 15 & \verb~82~ & & \verb~                    data.Collision = true;~\\
\cellcolor{green} & 15 & \verb~83~ & & \verb~                    return data;~\\
\cellcolor{gray} &  & \verb~84~ & & \verb~                }~\\
\cellcolor{gray} &  & \verb~85~ & & \verb~                else~\\
\cellcolor{green} & 762 & \verb~86~ & & \verb~                {~\\
\cellcolor{green} & 762 & \verb~87~ & & \verb~                    return data;~\\
\cellcolor{gray} &  & \verb~88~ & & \verb~                }~\\
\cellcolor{gray} &  & \verb~89~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~90~ & & \verb~            // inactive movement in y-direction~\\
\cellcolor{green} & 8 & \verb~91~ & & \verb~            else if(System.Math.Abs(actor.Direction.Y) < 1e-6f)~\\
\cellcolor{green} & 6 & \verb~92~ & & \verb~            {~\\
\cellcolor{gray} &  & \verb~93~ & & \verb~                float entryDistanceX, exitDistanceX;~\\
\cellcolor{green} & 6 & \verb~94~ & & \verb~                if(actor.Direction.X < 0.0f)~\\
\cellcolor{green} & 3 & \verb~95~ & & \verb~                {~\\
\cellcolor{green} & 3 & \verb~96~ & & \verb~                    entryDistanceX = staUpperRight.X - dynLowerLeft.X;~\\
\cellcolor{green} & 3 & \verb~97~ & & \verb~                    exitDistanceX = staLowerLeft.X - dynUpperRight.X;~\\
\cellcolor{green} & 3 & \verb~98~ & & \verb~                    data.CollisionDir = CollisionDirection.CollisionDirLeft;~\\
\cellcolor{green} & 3 & \verb~99~ & & \verb~                }~\\
\cellcolor{gray} &  & \verb~100~ & & \verb~                else~\\
\cellcolor{green} & 3 & \verb~101~ & & \verb~                {~\\
\cellcolor{green} & 3 & \verb~102~ & & \verb~                    entryDistanceX = staLowerLeft.X - dynUpperRight.X;~\\
\cellcolor{green} & 3 & \verb~103~ & & \verb~                    exitDistanceX = staUpperRight.X - dynLowerLeft.X;~\\
\cellcolor{green} & 3 & \verb~104~ & & \verb~                    data.CollisionDir = CollisionDirection.CollisionDirRight;~\\
\cellcolor{green} & 3 & \verb~105~ & & \verb~                }~\\
\cellcolor{gray} &  & \verb~106~ & & \verb~~\\
\cellcolor{green} & 6 & \verb~107~ & & \verb~                float entryTimeX = entryDistanceX / actor.Direction.X;~\\
\cellcolor{green} & 6 & \verb~108~ & & \verb~                float exitTimeX = exitDistanceX / actor.Direction.X;~\\
\cellcolor{gray} &  & \verb~109~ & & \verb~~\\
\cellcolor{orange} & 6 & \verb~110~ & & \verb~                bool yOverlaps = staUpperRight.Y > dynLowerLeft.Y && staLowerLeft.Y < dynUpperRight.Y;~\\
\cellcolor{gray} &  & \verb~111~ & & \verb~~\\
\cellcolor{green} & 6 & \verb~112~ & & \verb~                if(entryTimeX < exitTimeX && entryTimeX >= 0.0f && entryTimeX < 1.0f && yOverlaps)~\\
\cellcolor{green} & 4 & \verb~113~ & & \verb~                {~\\
\cellcolor{green} & 4 & \verb~114~ & & \verb~                    data.DirectionFactor.X = entryTimeX;~\\
\cellcolor{green} & 4 & \verb~115~ & & \verb~                    data.Collision = true;~\\
\cellcolor{green} & 4 & \verb~116~ & & \verb~                }~\\
\cellcolor{green} & 6 & \verb~117~ & & \verb~                return data;~\\
\cellcolor{gray} &  & \verb~118~ & & \verb~            }~\\
\cellcolor{gray} &  & \verb~119~ & & \verb~            // active movement in both x- and y-direction~\\
\cellcolor{gray} &  & \verb~120~ & & \verb~            else~\\
\cellcolor{green} & 2 & \verb~121~ & & \verb~            {~\\
\cellcolor{green} & 2 & \verb~122~ & & \verb~                var entryDistance = new Vec2F();~\\
\cellcolor{green} & 2 & \verb~123~ & & \verb~                var exitDistance = new Vec2F();~\\
\cellcolor{gray} &  & \verb~124~ & & \verb~~\\
\cellcolor{orange} & 2 & \verb~125~ & & \verb~                if(actor.Direction.X < 0.0f)~\\
\cellcolor{red} & 0 & \verb~126~ & & \verb~                {~\\
\cellcolor{red} & 0 & \verb~127~ & & \verb~                    entryDistance.X = staUpperRight.X - dynLowerLeft.X;~\\
\cellcolor{red} & 0 & \verb~128~ & & \verb~                    exitDistance.X = staLowerLeft.X - dynUpperRight.X;~\\
\cellcolor{red} & 0 & \verb~129~ & & \verb~                }~\\
\cellcolor{gray} &  & \verb~130~ & & \verb~                else~\\
\cellcolor{green} & 2 & \verb~131~ & & \verb~                {~\\
\cellcolor{green} & 2 & \verb~132~ & & \verb~                    entryDistance.X = staLowerLeft.X - dynUpperRight.X;~\\
\cellcolor{green} & 2 & \verb~133~ & & \verb~                    exitDistance.X = staUpperRight.X - dynLowerLeft.X;~\\
\cellcolor{green} & 2 & \verb~134~ & & \verb~                }~\\
\cellcolor{orange} & 2 & \verb~135~ & & \verb~                if(actor.Direction.Y < 0.0f)~\\
\cellcolor{red} & 0 & \verb~136~ & & \verb~                {~\\
\cellcolor{red} & 0 & \verb~137~ & & \verb~                    entryDistance.Y = staUpperRight.Y - dynLowerLeft.Y;~\\
\cellcolor{red} & 0 & \verb~138~ & & \verb~                    exitDistance.Y = staLowerLeft.Y - dynUpperRight.Y;~\\
\cellcolor{red} & 0 & \verb~139~ & & \verb~                }~\\
\cellcolor{gray} &  & \verb~140~ & & \verb~                else~\\
\cellcolor{green} & 2 & \verb~141~ & & \verb~                {~\\
\cellcolor{green} & 2 & \verb~142~ & & \verb~                    entryDistance.Y = staLowerLeft.Y - dynUpperRight.Y;~\\
\cellcolor{green} & 2 & \verb~143~ & & \verb~                    exitDistance.Y = staUpperRight.Y - dynLowerLeft.Y;~\\
\cellcolor{green} & 2 & \verb~144~ & & \verb~                }~\\
\cellcolor{gray} &  & \verb~145~ & & \verb~~\\
\cellcolor{green} & 2 & \verb~146~ & & \verb~                var entryTime = new Vec2F(entryDistance.X / actor.Direction.X, entryDistance.Y / actor.Direction.Y);~\\
\cellcolor{green} & 2 & \verb~147~ & & \verb~                var exitTime = new Vec2F(exitDistance.X / actor.Direction.X, exitDistance.Y / actor.Direction.Y);~\\
\cellcolor{gray} &  & \verb~148~ & & \verb~~\\
\cellcolor{green} & 2 & \verb~149~ & & \verb~                float entryTimeMax = System.Math.Max(entryTime.X, entryTime.Y);~\\
\cellcolor{green} & 2 & \verb~150~ & & \verb~                float exitTimeMin = System.Math.Min(exitTime.X, exitTime.Y);~\\
\cellcolor{gray} &  & \verb~151~ & & \verb~~\\
\cellcolor{orange} & 2 & \verb~152~ & & \verb~                if(entryTimeMax < exitTimeMin && (entryTime.X >= 0.0f || entryTime.Y >= 0.0f) &&~\\
\cellcolor{green} & 2 & \verb~153~ & & \verb~                   entryTime.X < 1.0f && entryTime.Y < 1.0f)~\\
\cellcolor{red} & 0 & \verb~154~ & & \verb~                {~\\
\cellcolor{red} & 0 & \verb~155~ & & \verb~                    if (entryTime.X > entryTime.Y)~\\
\cellcolor{red} & 0 & \verb~156~ & & \verb~                    {~\\
\cellcolor{red} & 0 & \verb~157~ & & \verb~                        data.DirectionFactor.X = entryTimeMax;~\\
\cellcolor{red} & 0 & \verb~158~ & & \verb~                        if (actor.Direction.X < 0.0f) {~\\
\cellcolor{red} & 0 & \verb~159~ & & \verb~                            data.CollisionDir = CollisionDirection.CollisionDirRight;~\\
\cellcolor{red} & 0 & \verb~160~ & & \verb~                        } else {~\\
\cellcolor{red} & 0 & \verb~161~ & & \verb~                            data.CollisionDir = CollisionDirection.CollisionDirLeft;~\\
\cellcolor{red} & 0 & \verb~162~ & & \verb~                        }~\\
\cellcolor{red} & 0 & \verb~163~ & & \verb~                    }~\\
\cellcolor{gray} &  & \verb~164~ & & \verb~                    else~\\
\cellcolor{red} & 0 & \verb~165~ & & \verb~                    {~\\
\cellcolor{red} & 0 & \verb~166~ & & \verb~                        data.DirectionFactor.Y = entryTimeMax;~\\
\cellcolor{red} & 0 & \verb~167~ & & \verb~                        if (actor.Direction.Y < 0.0f) {~\\
\cellcolor{red} & 0 & \verb~168~ & & \verb~                            data.CollisionDir = CollisionDirection.CollisionDirUp;~\\
\cellcolor{red} & 0 & \verb~169~ & & \verb~                        } else {~\\
\cellcolor{red} & 0 & \verb~170~ & & \verb~                            data.CollisionDir = CollisionDirection.CollisionDirDown;~\\
\cellcolor{red} & 0 & \verb~171~ & & \verb~                        }~\\
\cellcolor{red} & 0 & \verb~172~ & & \verb~                    }~\\
\cellcolor{gray} &  & \verb~173~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~174~ & & \verb~                    data.Collision = true;~\\
\cellcolor{red} & 0 & \verb~175~ & & \verb~                    return data;~\\
\cellcolor{gray} &  & \verb~176~ & & \verb~                }~\\
\cellcolor{gray} &  & \verb~177~ & & \verb~                else~\\
\cellcolor{green} & 2 & \verb~178~ & & \verb~                {~\\
\cellcolor{green} & 2 & \verb~179~ & & \verb~                    return data;~\\
\cellcolor{gray} &  & \verb~180~ & & \verb~                }~\\
\cellcolor{gray} &  & \verb~181~ & & \verb~            }~\\
\cellcolor{green} & 785 & \verb~182~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~183~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~184~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Timers.GameTimer}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Timers.GameTimer\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Timers/GameTimer.cs}\end{minipage} \\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 57\\
\textbf{Coverable lines:} & 57\\
\textbf{Total lines:} & 100\\
\textbf{Line coverage:} & 0\% (0 of 57)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 12\\
\textbf{Branch coverage:} & 0\% (0 of 12)\\
\textbf{Covered methods:} & 0\\
\textbf{Total methods:} & 8\\
\textbf{Method coverage:} & 0\% (0 of 8)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{get\_CapturedUpdates(} & 100\% & 1 & 0\%\\
\hline
\textbf{get\_CapturedFrames()} & 100\% & 1 & 0\%\\
\hline
\textbf{.ctor()} & 100\% & 1 & 0\%\\
\hline
\textbf{.ctor(...)} & 0\% & 4 & 0\%\\
\hline
\textbf{MeasureTime()} & 100\% & 1 & 0\%\\
\hline
\textbf{ShouldUpdate()} & 0\% & 2 & 0\%\\
\hline
\textbf{ShouldRender()} & 0\% & 4 & 0\%\\
\hline
\textbf{ShouldReset()} & 0\% & 2 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Timers/GameTimer.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using System;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~using System.Diagnostics;~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~namespace DIKUArcade.Timers {~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~    public class GameTimer {~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~        private double lastTime;~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~        private double timer;~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~        private double updateTimeLimit;~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~        private double renderTimeLimit;~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~        private double deltaUpdateTime;~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~        private double deltaRenderTime;~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~        private double nowTime;~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~15~ & & \verb~        /// Get the last observed UPS count~\\
\cellcolor{gray} &  & \verb~16~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~17~ & & \verb~        public int CapturedUpdates { get; private set; }~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~19~ & & \verb~        /// Get the last observed FPS count~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~21~ & & \verb~        public int CapturedFrames { get; private set; }~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~        private int updates;~\\
\cellcolor{gray} &  & \verb~24~ & & \verb~        private int frames;~\\
\cellcolor{gray} &  & \verb~25~ & & \verb~~\\
\cellcolor{gray} &  & \verb~26~ & & \verb~        private int desiredMaxFPS;~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~~\\
\cellcolor{gray} &  & \verb~28~ & & \verb~        private Stopwatch stopwatch;~\\
\cellcolor{gray} &  & \verb~29~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~30~ & & \verb~        public GameTimer() : this(30, 30) {}~\\
\cellcolor{gray} &  & \verb~31~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~32~ & & \verb~        public GameTimer(int ups, int fps = 0) {~\\
\cellcolor{red} & 0 & \verb~33~ & & \verb~            if (ups < 0 || fps < 0) {~\\
\cellcolor{red} & 0 & \verb~34~ & & \verb~                throw new ArgumentOutOfRangeException(~\\
\cellcolor{red} & 0 & \verb~35~ & & \verb~                    $"GameTimer must have positive count values: (ups={ups},fps={fps})");~\\
\cellcolor{gray} &  & \verb~36~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~37~ & & \verb~            desiredMaxFPS = fps;~\\
\cellcolor{gray} &  & \verb~38~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~39~ & & \verb~            stopwatch = new Stopwatch();~\\
\cellcolor{red} & 0 & \verb~40~ & & \verb~            stopwatch.Start();~\\
\cellcolor{gray} &  & \verb~41~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~42~ & & \verb~            updateTimeLimit = 1.0 / ups;~\\
\cellcolor{red} & 0 & \verb~43~ & & \verb~            renderTimeLimit = 1.0 / fps;~\\
\cellcolor{red} & 0 & \verb~44~ & & \verb~            lastTime = stopwatch.ElapsedMilliseconds / 1000.0; // elapsed seconds~\\
\cellcolor{red} & 0 & \verb~45~ & & \verb~            deltaUpdateTime = 0.0;~\\
\cellcolor{red} & 0 & \verb~46~ & & \verb~            deltaRenderTime = 0.0;~\\
\cellcolor{red} & 0 & \verb~47~ & & \verb~            nowTime = 0.0;~\\
\cellcolor{red} & 0 & \verb~48~ & & \verb~            timer = lastTime;~\\
\cellcolor{gray} &  & \verb~49~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~50~ & & \verb~            frames = 0;~\\
\cellcolor{red} & 0 & \verb~51~ & & \verb~            updates = 0;~\\
\cellcolor{red} & 0 & \verb~52~ & & \verb~            CapturedFrames = 0;~\\
\cellcolor{red} & 0 & \verb~53~ & & \verb~            CapturedUpdates = 0;~\\
\cellcolor{red} & 0 & \verb~54~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~55~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~56~ & & \verb~        public void MeasureTime() {~\\
\cellcolor{red} & 0 & \verb~57~ & & \verb~            nowTime = stopwatch.ElapsedMilliseconds / 1000.0;~\\
\cellcolor{red} & 0 & \verb~58~ & & \verb~            deltaUpdateTime += (nowTime - lastTime) / updateTimeLimit;~\\
\cellcolor{red} & 0 & \verb~59~ & & \verb~            deltaRenderTime += (nowTime - lastTime) / renderTimeLimit;~\\
\cellcolor{red} & 0 & \verb~60~ & & \verb~            lastTime = nowTime;~\\
\cellcolor{red} & 0 & \verb~61~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~62~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~63~ & & \verb~        public bool ShouldUpdate() {~\\
\cellcolor{red} & 0 & \verb~64~ & & \verb~            var ret = deltaUpdateTime >= 1.0;~\\
\cellcolor{red} & 0 & \verb~65~ & & \verb~            if (ret) {~\\
\cellcolor{red} & 0 & \verb~66~ & & \verb~                updates++;~\\
\cellcolor{red} & 0 & \verb~67~ & & \verb~                deltaUpdateTime--;~\\
\cellcolor{red} & 0 & \verb~68~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~69~ & & \verb~            return ret;~\\
\cellcolor{red} & 0 & \verb~70~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~71~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~72~ & & \verb~        public bool ShouldRender() {~\\
\cellcolor{red} & 0 & \verb~73~ & & \verb~            if (desiredMaxFPS < 1) {~\\
\cellcolor{red} & 0 & \verb~74~ & & \verb~                return true;~\\
\cellcolor{gray} &  & \verb~75~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~76~ & & \verb~            var ret = deltaRenderTime >= 1.0;~\\
\cellcolor{red} & 0 & \verb~77~ & & \verb~            if (ret) {~\\
\cellcolor{red} & 0 & \verb~78~ & & \verb~                frames++;~\\
\cellcolor{red} & 0 & \verb~79~ & & \verb~                deltaRenderTime--;~\\
\cellcolor{red} & 0 & \verb~80~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~81~ & & \verb~            return ret;~\\
\cellcolor{red} & 0 & \verb~82~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~83~ & & \verb~~\\
\cellcolor{gray} &  & \verb~84~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~85~ & & \verb~        /// The timer will reset if 1 second has passed.~\\
\cellcolor{gray} &  & \verb~86~ & & \verb~        /// This information can be used to update game logic in any way desireable.~\\
\cellcolor{gray} &  & \verb~87~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~88~ & & \verb~        public bool ShouldReset() {~\\
\cellcolor{red} & 0 & \verb~89~ & & \verb~            var ret = (stopwatch.ElapsedMilliseconds / 1000.0) - timer > 1.0;~\\
\cellcolor{red} & 0 & \verb~90~ & & \verb~            if (ret) {~\\
\cellcolor{red} & 0 & \verb~91~ & & \verb~                timer += 1.0;~\\
\cellcolor{red} & 0 & \verb~92~ & & \verb~                CapturedUpdates = updates;~\\
\cellcolor{red} & 0 & \verb~93~ & & \verb~                CapturedFrames = frames;~\\
\cellcolor{red} & 0 & \verb~94~ & & \verb~                updates = 0;~\\
\cellcolor{red} & 0 & \verb~95~ & & \verb~                frames = 0;~\\
\cellcolor{red} & 0 & \verb~96~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~97~ & & \verb~            return ret;~\\
\cellcolor{red} & 0 & \verb~98~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~99~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~100~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Timers.StaticTimer}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Timers.StaticTimer\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Timers/StaticTimer.cs}\end{minipage} \\
\textbf{Covered lines:} & 14\\
\textbf{Uncovered lines:} & 15\\
\textbf{Coverable lines:} & 29\\
\textbf{Total lines:} & 59\\
\textbf{Line coverage:} & 48.2\% (14 of 29)\\
\textbf{Covered branches:} & 1\\
\textbf{Total branches:} & 4\\
\textbf{Branch coverage:} & 25\% (1 of 4)\\
\textbf{Covered methods:} & 4\\
\textbf{Total methods:} & 7\\
\textbf{Method coverage:} & 57.1\% (4 of 7)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.cctor()} & 100\% & 1 & 100\%\\
\hline
\textbf{GetElapsedMillisecon} & 100\% & 1 & 0\%\\
\hline
\textbf{GetElapsedSeconds()} & 100\% & 1 & 100\%\\
\hline
\textbf{GetElapsedMinutes()} & 100\% & 1 & 0\%\\
\hline
\textbf{RestartTimer()} & 100\% & 1 & 100\%\\
\hline
\textbf{PauseTimer()} & 0\% & 2 & 0\%\\
\hline
\textbf{ResumeTimer()} & 50.0\% & 2 & 50.0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Timers/StaticTimer.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using System.Diagnostics;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~namespace DIKUArcade.Timers {~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~    /// <summary>~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~    /// Static timer initialized on engine startup. Can be used for~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~    /// animations based on static, discrete time intervals.~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~    /// </summary>~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~    public class StaticTimer {~\\
\cellcolor{gray} &  & \verb~10~ & & \verb~        private static Stopwatch timer;~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~        private static bool paused;~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~~\\
\cellcolor{green} & 1 & \verb~13~ & & \verb~        static StaticTimer() {~\\
\cellcolor{green} & 1 & \verb~14~ & & \verb~            StaticTimer.timer = new Stopwatch();~\\
\cellcolor{green} & 1 & \verb~15~ & & \verb~            StaticTimer.timer.Start();~\\
\cellcolor{green} & 1 & \verb~16~ & & \verb~            StaticTimer.paused = false;~\\
\cellcolor{green} & 1 & \verb~17~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~18~ & & \verb~~\\
\cellcolor{gray} &  & \verb~19~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~20~ & & \verb~        /// Get the number of elapsed milliseconds since application start~\\
\cellcolor{gray} &  & \verb~21~ & & \verb~        /// </summary>~\\
\cellcolor{red} & 0 & \verb~22~ & & \verb~        public static long GetElapsedMilliseconds() {~\\
\cellcolor{red} & 0 & \verb~23~ & & \verb~            return StaticTimer.timer.ElapsedMilliseconds;~\\
\cellcolor{red} & 0 & \verb~24~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~25~ & & \verb~~\\
\cellcolor{gray} &  & \verb~26~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~        /// Get the number of elapsed seconds since application start~\\
\cellcolor{gray} &  & \verb~28~ & & \verb~        /// </summary>~\\
\cellcolor{green} & 15 & \verb~29~ & & \verb~        public static double GetElapsedSeconds() {~\\
\cellcolor{green} & 15 & \verb~30~ & & \verb~            return StaticTimer.timer.ElapsedMilliseconds / 1000.0;~\\
\cellcolor{green} & 15 & \verb~31~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~32~ & & \verb~~\\
\cellcolor{gray} &  & \verb~33~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~34~ & & \verb~        /// Get the number of elapsed minutes since application start~\\
\cellcolor{gray} &  & \verb~35~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~36~ & & \verb~        /// <returns></returns>~\\
\cellcolor{red} & 0 & \verb~37~ & & \verb~        public static double GetElapsedMinutes() {~\\
\cellcolor{red} & 0 & \verb~38~ & & \verb~            return StaticTimer.timer.ElapsedMilliseconds / 60000.0;~\\
\cellcolor{red} & 0 & \verb~39~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~40~ & & \verb~~\\
\cellcolor{green} & 9 & \verb~41~ & & \verb~        public static void RestartTimer() {~\\
\cellcolor{green} & 9 & \verb~42~ & & \verb~            StaticTimer.timer.Restart();~\\
\cellcolor{green} & 9 & \verb~43~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~44~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~45~ & & \verb~        public static void PauseTimer() {~\\
\cellcolor{red} & 0 & \verb~46~ & & \verb~            if (!StaticTimer.paused) {~\\
\cellcolor{red} & 0 & \verb~47~ & & \verb~                StaticTimer.timer.Stop();~\\
\cellcolor{red} & 0 & \verb~48~ & & \verb~                StaticTimer.paused = true;~\\
\cellcolor{red} & 0 & \verb~49~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~50~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~51~ & & \verb~~\\
\cellcolor{green} & 1 & \verb~52~ & & \verb~        public static void ResumeTimer() {~\\
\cellcolor{orange} & 1 & \verb~53~ & & \verb~            if (StaticTimer.paused) {~\\
\cellcolor{red} & 0 & \verb~54~ & & \verb~                StaticTimer.timer.Start();~\\
\cellcolor{red} & 0 & \verb~55~ & & \verb~                StaticTimer.paused = false;~\\
\cellcolor{red} & 0 & \verb~56~ & & \verb~            }~\\
\cellcolor{green} & 1 & \verb~57~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~58~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~59~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Timers.TimePeriod}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Timers.TimePeriod\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Timers/TimePeriod.cs}\end{minipage} \\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 16\\
\textbf{Coverable lines:} & 16\\
\textbf{Total lines:} & 30\\
\textbf{Line coverage:} & 0\% (0 of 16)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 6\\
\textbf{Branch coverage:} & 0\% (0 of 6)\\
\textbf{Covered methods:} & 0\\
\textbf{Total methods:} & 5\\
\textbf{Method coverage:} & 0\% (0 of 5)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{.ctor(...)} & 100\% & 1 & 0\%\\
\hline
\textbf{NewMilliseconds(...)} & 0\% & 2 & 0\%\\
\hline
\textbf{NewSeconds(...)} & 0\% & 2 & 0\%\\
\hline
\textbf{NewMinutes(...)} & 0\% & 2 & 0\%\\
\hline
\textbf{ToMilliseconds()} & 100\% & 1 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Timers/TimePeriod.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using System;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~namespace DIKUArcade.Timers {~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~    public struct TimePeriod {~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~        // A TimeSpan will internally be represented as an amount of milliseconds.~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~        private readonly System.Int64 value;~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~9~ & & \verb~        private TimePeriod(System.Int64 value) {~\\
\cellcolor{red} & 0 & \verb~10~ & & \verb~            this.value = value;~\\
\cellcolor{red} & 0 & \verb~11~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~13~ & & \verb~        public static TimePeriod NewMilliseconds(System.Int64 value) {~\\
\cellcolor{red} & 0 & \verb~14~ & & \verb~            if (value < 0) { throw new System.ArgumentOutOfRangeException("value cannot be negative."); }~\\
\cellcolor{red} & 0 & \verb~15~ & & \verb~            return new TimePeriod(value);~\\
\cellcolor{red} & 0 & \verb~16~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~17~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~18~ & & \verb~        public static TimePeriod NewSeconds(System.Double value) {~\\
\cellcolor{red} & 0 & \verb~19~ & & \verb~            if (value < 0.0) { throw new System.ArgumentOutOfRangeException("value cannot be negative."); }~\\
\cellcolor{red} & 0 & \verb~20~ & & \verb~            return new TimePeriod((System.Int64)System.Math.Floor(value * 1000));~\\
\cellcolor{red} & 0 & \verb~21~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~23~ & & \verb~        public static TimePeriod NewMinutes(System.Double value) {~\\
\cellcolor{red} & 0 & \verb~24~ & & \verb~            if (value < 0.0) { throw new System.ArgumentOutOfRangeException("value cannot be negative."); }~\\
\cellcolor{red} & 0 & \verb~25~ & & \verb~            return new TimePeriod((System.Int64)System.Math.Floor(value * 60000));~\\
\cellcolor{red} & 0 & \verb~26~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~27~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~28~ & & \verb~        public System.Int64 ToMilliseconds() => value;~\\
\cellcolor{gray} &  & \verb~29~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~30~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Utilities.FileIO}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Utilities.FileIO\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{/home/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Utilities/FileIO.cs}\end{minipage} \\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 9\\
\textbf{Coverable lines:} & 9\\
\textbf{Total lines:} & 23\\
\textbf{Line coverage:} & 0\% (0 of 9)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 2\\
\textbf{Branch coverage:} & 0\% (0 of 2)\\
\textbf{Covered methods:} & 0\\
\textbf{Total methods:} & 1\\
\textbf{Method coverage:} & 0\% (0 of 1)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{GetProjectPath()} & 0\% & 2 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{/home/magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Utilities/FileIO.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using System.IO;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~namespace DIKUArcade.Utilities {~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~    public class FileIO {~\\
\cellcolor{gray} &  & \verb~5~ & & \verb~~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~        /// <summary>~\\
\cellcolor{gray} &  & \verb~7~ & & \verb~        /// Return the platform-specific path of the current project directory~\\
\cellcolor{gray} &  & \verb~8~ & & \verb~        /// </summary>~\\
\cellcolor{gray} &  & \verb~9~ & & \verb~        /// <returns></returns>~\\
\cellcolor{red} & 0 & \verb~10~ & & \verb~        public static string GetProjectPath() {~\\
\cellcolor{gray} &  & \verb~11~ & & \verb~            // find base path~\\
\cellcolor{red} & 0 & \verb~12~ & & \verb~            var dir = new DirectoryInfo(Path.GetDirectoryName(~\\
\cellcolor{red} & 0 & \verb~13~ & & \verb~                System.Reflection.Assembly.GetExecutingAssembly().Location));~\\
\cellcolor{gray} &  & \verb~14~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~15~ & & \verb~            while (dir.Name != "bin") {~\\
\cellcolor{red} & 0 & \verb~16~ & & \verb~                dir = dir.Parent;~\\
\cellcolor{red} & 0 & \verb~17~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~18~ & & \verb~            dir = dir.Parent;~\\
\cellcolor{gray} &  & \verb~19~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~20~ & & \verb~            return dir.FullName.ToString();~\\
\cellcolor{red} & 0 & \verb~21~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~22~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~23~ & & \verb~}~\\
\end{longtable}
\newpage
\section{DIKUArcade.Utilities.RandomGenerator}
\subsection{Summary}
\begin{longtable}[l]{ll}
\textbf{Class:} & DIKUArcade.Utilities.RandomGenerator\\
\textbf{Assembly:} & DIKUArcade\\
\textbf{File(s):} & \begin{minipage}[t]{12cm}{magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Utilities/RandomGenerator.cs}\end{minipage} \\
\textbf{Covered lines:} & 0\\
\textbf{Uncovered lines:} & 6\\
\textbf{Coverable lines:} & 6\\
\textbf{Total lines:} & 13\\
\textbf{Line coverage:} & 0\% (0 of 6)\\
\textbf{Covered branches:} & 0\\
\textbf{Total branches:} & 2\\
\textbf{Branch coverage:} & 0\% (0 of 2)\\
\textbf{Covered methods:} & 0\\
\textbf{Total methods:} & 2\\
\textbf{Method coverage:} & 0\% (0 of 2)\\
\end{longtable}
\subsection{Metrics}
\begin{longtable}[l]{|l|r|r|r|}
\hline
\textbf{Method} & \textbf{Branch coverage} & \textbf{Cyclomatic complexity} & \textbf{Line coverage}\\
\hline
\textbf{get\_Generator()} & 100\% & 1 & 0\%\\
\hline
\textbf{.cctor()} & 0\% & 2 & 0\%\\
\hline
\end{longtable}
\subsection{File(s)}
\subsubsection{magnus/Desktop/SU/DIKUGames/DIKUArcade/DIKUArcade/Utilities/RandomGenerator.cs}
\begin{longtable}[l]{lrrll}
\textbf{} & \textbf{\#} & \textbf{Line} & \textbf{} & \textbf{Line coverage}\\
\cellcolor{gray} &  & \verb~1~ & & \verb~using System;~\\
\cellcolor{gray} &  & \verb~2~ & & \verb~~\\
\cellcolor{gray} &  & \verb~3~ & & \verb~namespace DIKUArcade.Utilities {~\\
\cellcolor{gray} &  & \verb~4~ & & \verb~    public class RandomGenerator {~\\
\cellcolor{red} & 0 & \verb~5~ & & \verb~        public static Random Generator { get; private set; }~\\
\cellcolor{gray} &  & \verb~6~ & & \verb~~\\
\cellcolor{red} & 0 & \verb~7~ & & \verb~        static RandomGenerator() {~\\
\cellcolor{red} & 0 & \verb~8~ & & \verb~            if (RandomGenerator.Generator == null) {~\\
\cellcolor{red} & 0 & \verb~9~ & & \verb~                RandomGenerator.Generator = new Random();~\\
\cellcolor{red} & 0 & \verb~10~ & & \verb~            }~\\
\cellcolor{red} & 0 & \verb~11~ & & \verb~        }~\\
\cellcolor{gray} &  & \verb~12~ & & \verb~    }~\\
\cellcolor{gray} &  & \verb~13~ & & \verb~}~\\
\end{longtable}
\end{document}